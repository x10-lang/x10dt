<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Example</title>
</head>

<body>

This example illustrates 2-d Jacobi iteration.

<div class="p"><!----></div>
<pre>
 public class Jacobi  {
   const int N=6;
   const double epsilon = 0.002;
   const double epsilon2 = 0.000000001;
   const region R = [0:N+1, 0:N+1];
   const region RInner= [1:N, 1:N];
   const distribution D = distribution.factory.block(R);
   const distribution DInner = D | RInner;
   const distribution DBoundary = D - RInner;
   const int EXPECTED_ITERS=97;
   const double EXPECTED_ERR=0.0018673382039402497;

<div class="p"><!----></div>
   double[D] B = new double[D] (point p[i,j])
       {return DBoundary.contains(p) 
                ? (N-1)/2 : N*(i-1)+(j-1);};

<div class="p"><!----></div>
   public boolean run() {
      int iters = 0;
      double err;
      while(true) {
        double[.] Temp = 
           new double[DInner] (point [i,j]) 
             {return (read(i+1,j)+read(i-1,j)
                      +read(i,j+1)+read(i,j-1))/4.0;};       
        if((err=((B | DInner) - Temp).abs().sum()) 
            &lt; epsilon)
           break; 
        B.update(Temp);
        iters++; 
      }
      System.out.println("Error="+err);
      System.out.println("Iterations="+iters);
      return Math.abs(err-EXPECTED_ERR)&lt;epsilon2 
          &amp;&amp; iters==EXPECTED_ITERS;
   }
   public double read(final int i, final int j) {
      return future(D[i,j]) B[i,j].force();
   }
   public static void main(String args[]) {
      boolean b= (new Jacobi()).run();
      System.out.println("++++++ "
                         + (b? "Test succeeded."
                             :"Test failed."));
      System.exit(b?0:1);
   }
}
</pre>
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.80.<br />On 07 Jun 2008, 13:43.</small>
</body>
</html>