<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>The Nullable Type Constructor</title>
</head>

<body>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;The Nullable Type Constructor</h2>
<a name="NullableTypeConstructor">
</a>

<div class="p"><!----></div>
 X10 supports the prefix type constructor, <tt>nullable</tt>.  For any
type <tt>T</tt>, the type <tt>nullable T</tt> contains all the values of
type <tt>T</tt>, and a special <tt>null</tt> value, unless <tt>T</tt> already
contains <tt>null</tt>. This value is designated by the literal <tt>
null</tt>, which is special in that it has the type <tt>nullable T</tt> for all types
<tt>T</tt>.

<div class="p"><!----></div>
The visibility of the type <tt>nullable T</tt> is the same as the
visibility of <tt>T</tt>. The members of the type <tt>nullable T</tt> are
the same as those of type <tt>T</tt>. Note that because of this <tt>
nullable</tt> may not be regarded as a generic class; rather it is a
special type constructor.

<div class="p"><!----></div>

<div class="p"><!----></div>
This type constructor can be used in any type expression used to
declare variables (e.g. local variables, method parameters,
class fields, iterator parameters, try/catch parameters etc).
It may be applied to value types, reference types or aggregate types.
It may not be used in an <tt>extends</tt> clause or an <tt>implements</tt>
clause in a class or interface declaration. It may not be used 
in a new expression - a new expression is used to construct 

<div class="p"><!----></div>
If <tt>T</tt> is a value
(respectively, reference) type, then <tt>nullable T</tt> is defined to be
a value (respectively, reference) type.

<div class="p"><!----></div>
An immediate consequence of the definition of <tt>nullable</tt> is that
for any type <tt>T</tt>, the type <tt>nullable nullable T</tt> is equal to
the type <tt>nullable T</tt>.

<div class="p"><!----></div>
Any attempt to access a field or invoke a method on the value <tt>
null</tt> results in a <tt>NullPointerException</tt>.

<div class="p"><!----></div>
An expression <tt>e</tt> of type <tt>nullable T</tt> may be checked for nullity
using the expression <tt>e==null</tt>. (It is a compile time error for
the static type of <tt>e</tt> to not be <tt>nullable T</tt>, for some <tt>T</tt>.)

<div class="p"><!----></div>

<b>Conversions&nbsp;&nbsp;</b>
<tt>null</tt> can be passed as an argument to a method call whose
corresponding formal parameter is of type <tt>nullable T</tt> for some type
<tt>T</tt>. (This is a widening reference conversion, per [,Sec
5.1.4].) Similarly it may be returned from a method call of
return type <tt>nullable T</tt> for some type <tt>T</tt>.

<div class="p"><!----></div>
For any value <tt>v</tt> of type <tt>T</tt>, the class cast expression <tt>
(nullable T) v</tt> succeeds and specifies a value of type <tt>nullable
T</tt>. This value may be seen as the "boxed" version of <tt>v</tt>.

<div class="p"><!----></div>
 X10 permits the widening reference conversion from any type <tt>T</tt>
to the type <tt>nullable T1</tt> if <tt>T</tt> can be widened to the type <tt>
T1</tt>. Thus, the type <tt>T</tt> is a subtype of the type <tt>nullable T</tt>.

<div class="p"><!----></div>
Correspondingly, a value <tt>e</tt> of type <tt>nullable T</tt> can be cast to the
type <tt>T</tt>, resulting in a <tt>NullPointerException</tt> if <tt>e</tt> is
<tt>null</tt> and <tt>nullable T</tt> is not equal to <tt>T</tt>, and in the
corresponding value of type <tt>T</tt> otherwise.  If <tt>T</tt> is a value
type this may be seen as the "unboxing" operator.

<div class="p"><!----></div>
The expression <tt>(T) null</tt> throws a <tt>ClassCastException</tt> if <tt>
T</tt> is not equal to <tt>nullable T</tt>; otherwise it returns <tt>null</tt> at type
<tt>T</tt>. Thus it may be used to check whether <tt>T=nullable T</tt>.

<div class="p"><!----></div>

<b>Arrays of nullary type&nbsp;&nbsp;</b>
The nullary type constructor may also be used in (aggregate) instance
creation expressions (e.g. <tt>new (nullable T)[R]</tt>). In such a
case <tt>T</tt> must designate a class. Each member of the array is
initialized to <tt>null</tt>, unless an explicit array initializer is
specified.

<div class="p"><!----></div>

<b>Implementation notes&nbsp;&nbsp;</b>
A value of type <tt>nullable T</tt> may be implemented by boxing a value of
type <tt>T</tt> unless the value is already boxed. The literal <tt>null</tt>
may be represented as the unique null reference.

<div class="p"><!----></div>

<b> Java compatibility&nbsp;&nbsp;</b>

<div class="p"><!----></div>
 Java provides a somewhat different treatment of <tt>null</tt>.  A
class definition extends a nullable type to produce a nullable type,
whereas primitive types such as <tt>int</tt> are not nullable - the
programmer has to explicitly use a boxed version of <tt>int</tt>, <tt>
Integer</tt>, to get the effect of <tt>nullable int</tt>. Wherever  Java uses a
variable at reference type <tt>S</tt>, and at runtime the variable may
carry the value <tt>null</tt>, the  X10 programmer should declare the
variable at type <tt>nullable S</tt>. However, there are many situations
in  Java in which a variable at reference type <tt>S</tt> can be
statically determined to not carry null as a value. Such variables
should be declared at type <tt>S</tt> in  X10

<div class="p"><!----></div>

<b>Design rationale&nbsp;&nbsp;</b>

<div class="p"><!----></div>
The need for <tt>nullable</tt> arose because  X10 has value types and
reference types, and arguably the ability to add a <tt>null</tt> value to
a type is orthogonal to whether the type is a value type or a
reference type. This argues for the notion of nullability as a type
constructor.

<div class="p"><!----></div>
The key question that remains is whether it should be possible to
define "towers", that is, define the type constructor in such a way
that <tt>nullable nullable T</tt> is distinct from <tt>nullable T</tt>. Here
one would think of nullable as a disjoint sum type constructor that
adds a value <tt>null</tt> to the interpretation of its argument type
even if it already has that value. Thus <tt>nullable nullable T</tt> is
distinct from <tt>nullable T</tt> because it has one more <tt>null</tt>
value. Explicit injection/projection functions (of signature <tt>T -&#62;
nullable T</tt> to <tt>nullable T -&#62;T</tt>) would need to be provided.

<div class="p"><!----></div>
The designers of  X10 felt that while such a definition might be
mathematically tenable, and programmatically interesting, it was
likely to be too confusing for programmers. More importantly, it would
be a deviation from current practice that is not forced by the core
focus of  X10 (concurrency and distribution). Hence the decision to
collapse the tower.  As discussed below, this results in no loss of
expressiveness because towers can be obtained through explicit
programming.

<div class="p"><!----></div>

<b>Examples&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Consider the following class:

<div class="p"><!----></div>
<pre>
final value Box { 
  public nullable Object datum; 
  public Box(nullable Object v) { this.datum = v; }
}
</pre>

<div class="p"><!----></div>
Now one may use a variable <tt>x</tt> at type <tt>nullable Box</tt> to
distinguish between the <tt>null</tt> at type <tt>nullable Box</tt> and at type
<tt>nullable Object</tt>. In the first case the value
of <tt>x</tt> will be <tt>null</tt>, in the second case the value of <tt>x.datum</tt> will
be <tt>null</tt>.

<div class="p"><!----></div>
Such a type may be used to define efficient code for memoization:

<div class="p"><!----></div>
<pre>
abstract class Memo  {
  (nullable Box)[]  values; 
  Memo(int n) {
    // initialized to all nulls
    values = new (nullable Box)[n]; 
  }
  nullable Object compute(int key); 
  nullable Object lookup(int key) { 
   if (values[key] != null) 
     return values[key].datum;
   V val = compute(key);
   values[key] = new Box(val);
   return val;
  }
}
</pre>

<div class="p"><!----></div>
</body>
</html>