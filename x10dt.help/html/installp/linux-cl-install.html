<html>
<body>

<h1>Linux X10 Command Line Installation</h1>
In order to run X10 on Linux, you need to satisfy the follow pre-requisites.
<h2>Prereqs</h2>
<ul>
	<li>gcc/g++ 4.2.x or higher (for the X10 C++ backend)</li>
	<li>java 1.5.0_x or higher (for the X10 Java backend)</li>
</ul>

<h4>gcc/g++</h4>
gcc is included with the os. Do the following to verify the location and version
<pre>
whereis gcc
gcc -v
</pre>
In my case, running Fedora 9, gcc version 4.3.0 is installed

<h4>java</h4>
Although Java is often times included with Linux, it usually is the OpenJDK runtime
environment. Do the following to verify the location and version
<pre>
	whereis java
	java -version
</pre>
In the case of Fedora 9, java version 1.6.0 is installed.
However, it is recommended that you download and install the latest Sun JDK for 1.5.0_x or 1.6.0_x.
<pre>
	cd /usr
	mkdir java
	cd java
	cp ~/Download/jdk-1_5_0_11-linux-i586.bin .
	chmod 777 jdk-1_5_0_11-linux-i586.bin
	./jdk-1_5_0_11-linux-i586.bin
	...license...
	yes
</pre>
Then you should modify your .bash_profile file to contain this directory in the PATH statement.
<pre>
.bash_profile
PATH=/usr/java/jdk1.5.0_11/bin:$PATH
export PATH
</pre>
Then modify your .bashrc file to define JAVA_HOME
<pre>
.bashrc
JAVA_HOME=/usr/java/jdk1.5.0_11
export JAVA_HOME
</pre>

<h4>Running x10 programs using <tt>Sockets</tt> backend</h4>
<p>
The sockets transport replaces <tt>pgas_sockets</tt> (which is closed-source, and requires some setup), and is currently the default backend if you don't compile with the "-x10rt" flag. You set an run configuration variable <tt>Number of places</tt> to specify the number of places. If this is not set, it defaults to 1 place on the local machine, and prints a warning. 
There are two ways to specify the machines to run on: 
<ul>
<li>Set the run configuration variable <tt>host file</tt> to the full path for a hostfile. The hostfile is a simple text file that contains a list of hostnames to run on, with one line per machine. 
<li>Set the run configuration variable <tt>list of hosts</tt>, to a list of hostnames, one per line without spaces. This run configuration variable is checked only if <tt>host file</tt> was not set. 
</ul>
Both of the above will wrap if there are more places than hostnames specified. For example, setting <tt>Number of places to 4</tt> and <tt>list of hosts to host1,host2</tt> will cause places 0 and 2 to run on host1, and places 1 and 3 to run on host2. If neither of the above is set, and there is more than 1 place, then it defaults to running everything on localhost, and prints a warning. You can set <tt>list of hosts to localhost</tt> to get the same effect without warning. 
If you're running on more than one machine, you should have public/private key ssh authentication set up, so you can ssh from one machine to another without getting a password prompt. You should also have your executable and hostfile available in the same location on every machine listed in the hostfile. You compile your program, and with ssh in place, and the run configuration variables set, you run your executable. You don't have to launch from one of the machines in the hostfile, but you do need to have the ssh authentication set up between the machine you launch from and the first machine in the list. 
<p>
Please note that currently, the Sockets backend will not work in an environment with mixed POWER and x86 hardware, due to different endianness. 

<h4>Running with <tt>Standalone</tt> backend</h4>
<p>
Standalone sets up shared memory regions and forks off one instance of the program per place. The places all run on the local machine. There is one run configuration variable "Number of places", which should be set to the number of places. If not set, it defaults to 1 and prints a warning. The standalone has transport has a limit on the size of the data blocks that can be sent (about 512k), because of the shared memory regions. To run, just compile, set the run configuration variable, and run your executable. This transport is a good choice if you're running everything one one machine and don't use large messages. 

<p>
It helps a lot to have passwordless ssh working between the machine
where the manager process is running and the compute nodes.


<h2>Comments</h2>
Comments and suggestions are welcome. 
Please send email to 
<a href="mailto:cals@us.ibm.com">Cal Swart (cals@us.ibm.com)</a>

</body>

</html>