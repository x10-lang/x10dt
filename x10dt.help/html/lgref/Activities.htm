<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>`</title>

<div class="p"><!----></div>
`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
    




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />Activities</h1><a name="XtenActivities">
</a>


<div class="p"><!----></div>
An <em>activity</em> is a statement being executed, independently, with its own
local variables; it may be thought of as a very light-weight thread. An
X10 computation may have many concurrent activities executing at any
give time.  All X10 code runs as part of an activity; when an X10 program is
started, the <b>main</b> method is invoked in an activity, called the <em>root
activity</em>.

<div class="p"><!----></div>
Activities coordinate their execution by various control and data structures.
For example, 
<b>when(x==0);</b> blocks the current activity until some other activity
sets <b>x</b> to zero.  However, activities determine the places at which they
may be blocked and resumed, by <b>when</b> and similar constructs.  There are
no means by which one activity can arbitrarily interrupt, block, or resume
another, no method  <b>activity.interrupt()</b>.

<div class="p"><!----></div>
An activity may be <em>running</em>, <em>blocked</em> on some condition or <em>
terminated</em>. If it is terminated, it is terminated in the same way that its
statement is: in particular, if the statement terminates abruptly, the
activity terminates abruptly for the same reason.
(&#167;).

<div class="p"><!----></div>
Activities can be long-running entities with a good deal of local state.  In
particular they can involve recursive method calls (and therefore have runtime
stacks).  However, activities can also be short-running light-weight entities,
<em>e.g.</em>, it is reasonable to have an activity that simply increments a variable.

<div class="p"><!----></div>
An activity may asynchronously and in parallel launch activities at
other places.  Every activity except the initial <b>main</b> activity is spawned
by another.  Thus, at any instant, the activities in a program form a tree.

<div class="p"><!----></div>
X10 uses this tree in crucial ways.  
First is the distinction 
between <em>local</em> termination and <em>global</em>
termination of a statement. The execution of a statement by an
activity is said to terminate locally when the activity has finished
all its computation. (For instance the
creation of an asynchronous activity terminates locally when the
activity has been created.)  It is said to terminate globally when it
has terminated locally and all activities that it may have spawned at
any place have, recursively, terminated globally.
For example, consider: 
<pre>
async {s1();}
async {s2();}
</pre>
The primary activity spawns two child activities and then terminates locally,
very quickly.  The child activities may take arbitrary amounts of time to
terminate (and may spawn grandchildren).  When <b>s1()</b>, <b>s2()</b>, and
all their descendants terminate locally, then the primary activity terminates
globally. 

<div class="p"><!----></div>
The program as a whole terminates when the root activity terminates globally.
In particular, X10 does not permit the creation of 
daemon threads-threads that outlive the lifetime of the root
activity.  We say that an X10 computation is <em>rooted</em>
(&#167;).

<div class="p"><!----></div>
<em>
<b>Future Extensions.&nbsp;&nbsp;</b> We may permit the initial activity to be a daemon activity
to permit reactive computations, such as webservers, that may not
terminate.</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;The X10 rooted exception model</h2>
<a name="ExceptionModel">
</a>




<div class="p"><!----></div>
The rooted nature of X10 computations permits the definition of a
<em>rooted exception model.</em> In multi-threaded programming languages
there is a natural parent-child relationship between a thread and a
thread that it spawns. Typically the parent thread continues execution
in parallel with the child thread. Therefore the parent thread cannot
serve to catch any exceptions thrown by the child thread. 

<div class="p"><!----></div>
The presence of a root activity and the concept of global termination permits
X10 to adopt a more powerful exception model. In any state of the
computation, say that an activity A is <em>a root of</em> an activity B if
A is an ancestor of B and A is blocked at a statement (such as the
<b>finish</b> statement &#167;) awaiting the termination of B (and
possibly other activities). For every X10 computation, the <em>root-of</em>
relation is guaranteed to be a tree. The root of the tree is the root activity
of the entire computation. If A is the nearest root of B, the path from
A to B is called the <em>activation path</em> for the activity.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>

<div class="p"><!----></div>
We may now state the exception model for X10.  An uncaught exception
propagates up the activation path to its nearest root activity, where
it may be handled locally or propagated up the <em>root-of</em> tree when
the activity terminates (based on the semantics of the statement being
executed by the activity).<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>  
There is always a good place to put a <b>try</b>-<b>catch</b> block to catch
exceptions thrown by an asynchronous activity.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp; <tt>at</tt>: Place Changing</h2><a name="AtStatement">
</a>



<div class="p"><!----></div>
An activity may change place synchronously using the <b>at</b> statement or
<b>at</b> expression. This is an expensive operation and must be used
with care.

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">AtStatement    ::= at PlaceExpSingleList Statement </td></tr>
<tr><td align="right">
 AtExp    ::= at PlaceExpSingleList ClosureBody </td></tr>
<tr><td align="right">
</td></tr></table>
</em>

<div class="p"><!----></div>
An activity executing statement <b>at (q) S</b> at a place <b>p</b>
evaluates <b>q</b> at <b>p</b> and then moves to <b>q</b> to execute
<b>S</b> as follows. Note that the value obtained by evaluating <b>q</b>
is not necessarily distinct from <b>p</b> (e.g. <b>q</b> may be
<b>here</b>).

<div class="p"><!----></div>
First, the runtime identifies the object graph at <b>p</b> reachable
from lexically scoped initialized variables (say, <b>v1</b>,...,
<b>vn</b>) referenced in <b>S</b>.  Second this graph is <em>
  serialized</em> into a buffer and transmitted to place <b>q</b>.  Third,
the variables <b>v1</b>,..., <b>vn</b> are re-created at <b>q</b> and
initialized with the objects obtained by deserializing the buffer at
<b>q</b>. Fourth, <b>S</b> is executed at <b>q</b> (in an environment in
which the variable <b>vi</b> refers to the re-created variable at
<b>q</b>).

<div class="p"><!----></div>
On normal termination of <b>S</b> control returns to <b>p</b> and
execution is continued with the statement following <b>at (q) S</b>. If
<b>S</b> terminates abruptly with exception <b>E</b>, <b>E</b> is
serialized into a buffer, the buffer is communicated to <b>p</b> where
it is deserialized into an exception <b>E1</b> and <b>at (e) S</b>
throws <b>E1</b>.

<div class="p"><!----></div>
Since <b>at(e) S</b> is a synchronous constructs usual control-flow
constructs such as <b>break</b>, <b>continue</b>, <b>return</b> and 
<b>throw</b> are permitted in <b>S</b>.  All concurrency related
constructs - <b>async</b>, <b>finish</b>, <b>atomic</b>, <b>when</b> are
also permitted.

<div class="p"><!----></div>
<em>Limitation</em> In <b>at(e) S</b>, <b>S</b> is permitted to access only
those immutable variables in the surrounding scope that are definitely
initialized.

<div class="p"><!----></div>
Note that since values accessed across an <b>at</b> boundary are
copied, the programmer may wish to adopt the discipline that either
variables accessed across an <b>at</b> boundary  contain only structs 
or stateless objects, or the methods invoked on them do not access any
mutable state on the objects. Otherwise the programmer has to ensure
that side effects are made to the correct copy of the object. For this
the struct <b>x10.lang.GlobalRef[T]</b> is often useful.

<div class="p"><!----></div>

<b>Serialization and deserialization.&nbsp;&nbsp;</b>


The X10 runtime provides a default mechanism for
serializing/deserializing an object graph with a given set of roots.
This mechanism may be overridden by the programmer on a per class or
struct basiss as described in <b>x10.io.CustomSerialization</b>. 
The default mechanism performs a
deep copy of the object graph (that is, it copies the object or struct
and, recursively, the values contained in its fields), but does not
traverse <b>transient</b> fields. Instead on serialization the default
value &#167; for the type of the field is used.

<div class="p"><!----></div>
A struct <b>s</b> of type <b>x10.lang.GlobalRef[T]</b> 
is serialized as a unique global reference to its contained object
<b>o</b> (of type <b>T</b>).  Please see the documentation
of <b>x10.lang.GlobalRef[T]</b> for more details.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Discussion</h3>
<b>at(p)S</b> does <em>not</em> start a new activity.  It should be thought of as
transporting the current activity to <b>p</b>, running <b>S</b> there, and then
transporting it back.  <b>async</b> is the only construct in the
language that starts a new activity. In different contexts, each one
of the following makes sense:
(1) <b>async at(p) S</b> (spawn an activity locally to execute <b>S</b> at
<b>p</b>; here <b>p</b> is evaluated by the spawned activity) , 
(2) <b>at(p) async S</b> (evaluate <b>p</b> and then at <b>p</b> spawn an
activity to execute <b>S</b>), and,
(3) <b>async at(p) async S</b>. 

<div class="p"><!----></div>
As a consequence of this, <b>S</b> may contain constructs which only make sense
within a single activity.  
For example, 
<pre>
    for(x in globalRefsToThings) 
      if (at(x.home) x().nice()) 
        return x();
</pre>
returns the first nice thing in a collection.   If we had used 
<b>async at(x.home)</b>, this would not be allowed; 
you can't <b>return</b> from an
<b>async</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Implicit copying from <tt>at</tt> </h3>


<div class="p"><!----></div>
<b>at(p)S</b> copies nearly all data that <b>S</b> might reference, and sends it
to place <b>p</b>, before executing <b>S</b> there. The only things that are not
copied are values only reachable through <b>GlobalRef</b>s and <b>transient</b>
fields.    If <b>x</b> is a
variable name referring to some object <b>ob</b> outside of <b>S</b>, then the
same variable name <b>x</b> refers to a deep copy <b>ob&#8242;</b> of <b>ob</b>
inside of <b>S</b>.  In this way the body <b>S</b> is in a separate block with
different variable bindings.

<div class="p"><!----></div>
For example, consider the following program.
<pre>
val c = new Cell[Int](9); // (1)
at (here) {               // (2)
   assert(c() == 9);      // (3)
   c.set(8);              // (4)
   assert(c() == 8);      // (5)
}
assert(c() == 9);         // (6)
</pre>
The <b>at</b> statement implicitly copies the <b>Cell</b> and its contents.  
After <b>(1)</b>, <b>c</b> is a <b>Cell</b> containing 9; call that cell c<sub>1</sub>
At <b>(2)</b>, that cell is copied, resulting in another cell c<sub>2</sub> whose
contents are also 9, as tested at <b>(3)</b>.
(Note that the copying behavior of <b>at</b> happens <em>even when the
destination place is the same as the starting place</em>- even with
<b>at(here)</b>.)
At <b>(4)</b>, the contents of c<sub>2</sub> are changed to 8, as confirmed at <b>(5)</b>; the contents of
c<sub>1</sub> are of course untouched.    Finally, at <b>(c)</b>, outside the scope
of the <b>at</b> started at line <b>(2)</b>, <b>c</b> refers to its original
value c<sub>1</sub> rather than the copy c<sub>2</sub>.  

<div class="p"><!----></div>
The <b>at</b> statement induces a <em>deep copy</em>.  Not only does it copy the
values of variables, it copies values that they refer to through zero or more
levels of reference.  Structures are preserved as well: if two fields
<b>x.f</b> and <b>x.g</b> refer to the same object o<sub>1</sub> in the original, then
<b>x.f</b> and <b>x.g</b> will both refer to the same object o<sub>2</sub> in the
copy.  

<div class="p"><!----></div>
For example, in the following variation of the preceding example,
<b>a</b>'s original value a<sub>1</sub> is an array with two references to the same
<b>Cell[Int]</b> c<sub>1</sub>.  The fact that a<sub>1</sub>(0) and a<sub>1</sub>(1) are both
identical to c<sub>1</sub> is demonstrated in <b>(A)</b>-<b>(C)</b>, as a<sub>1</sub>(0) is modified
and a<sub>1</sub>(1) is observed to change.  In <b>(D)</b>-<b>(F)</b>, the copy
a<sub>2</sub> is tested in the same way, showing that a<sub>2</sub>(0) and a<sub>2</sub>(1) both
refer to the same <b>Cell[Int]</b> c<sub>2</sub>.  However, the test at <b>(G)</b>
shows that c<sub>2</sub> is a different cell from c<sub>1</sub>, because changes to
c<sub>2</sub> did not propagate to c<sub>1</sub>.  
<pre>
val c = new Cell[Int](5);
val a = new Array[Cell[Int]][c,c];
assert(a(0)() == 5 &amp;&amp; a(1)() == 5);     // (A)
c.set(6);                               // (B)
assert(a(0)() == 6 &amp;&amp; a(1)() == 6);     // (C)
at(here) {
  assert(a(0)() == 6 &amp;&amp; a(1)() == 6);   // (D)
  c.set(7);                             // (E)
  assert(a(0)() == 7 &amp;&amp; a(1)() == 7);   // (F)
}
assert(a(0)() == 6 &amp;&amp; a(1)() == 6);     // (G)
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.2.1">
2.2.1</a>&nbsp;&nbsp;Copying and Transient Fields</h4>




<div class="p"><!----></div>
Recall that fields of classes and structs marked <b>transient</b> are not copied by
<b>at</b>.  Instead, they are set to the default values for their types. Types
that do not have default values cannot be used in <b>transient</b> fields.

<div class="p"><!----></div>
In the following example, every <b>Trans</b> object has an <b>a</b>-field equal
to 1.  However, despite the initializer on the <b>b</b> field, it is not the
case that every <b>Trans</b> has <b>b==2</b>.  Since <b>b</b> is <b>transient</b>,
when the <b>Trans</b> value <b>this</b> is copied at <b>at(here){...}</b> in
<b>example()</b>, its <b>b</b> field is not copied, and the default value for an
<b>Int</b>, 0, is used instead.  
Note that we could not make a transient field <b>c : Intc != 0</b>, since the
type has no default value, and copying would in fact set it to zero.
<pre>
class Trans {
   val a : Int = 1;
   transient val b : Int = 2;
   //ERROR transient val c : Int{c != 0} = 3;
   def example() {
     assert(a == 1 &amp;&amp; b == 2);
     at(here) {
        assert(a == 1 &amp;&amp; b == 0);
     }
   }
}
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.2.2">
2.2.2</a>&nbsp;&nbsp;Copying and GlobalRef</h4>
<a name="GlobalRef">
</a>



<div class="p"><!----></div>
A <b>GlobalRef[T]</b> (say <b>g</b>) contains a reference to
a value of type <b>T</b>, in a form which can be transmitted, and a <b>Place</b>
<b>g.home</b> indicating where the value lives. When a 
<b>GlobalRef</b> is serialized an opaque, globally uniqe handle to
the enclosed value <b>o</b> is passed. 

<div class="p"><!----></div>
The following example does not copy the value <b>huge</b>.  However, <b>huge</b>
would have been copied if it had been put into a <b>Cell</b>, or simply used
directly. 
<pre>
val huge = &#196; potentially big thing";
val href = GlobalRef(huge);
at (here) {
   use(href);
  }
}
</pre>

<div class="p"><!----></div>
Values protected in <b>GlobalRef</b>s can be retrieved by the <b>g.apply()</b>
method, often abbreviated simply <b>g()</b>.  <b>g.apply()</b> is guarded; it can
only be called when <b>g.home == here</b>.  If you  want to do anything other
than pass a global reference around or compare two of them for equality, you
need to placeshift back to the home place of the reference, often with
<b>at(g.home)</b>.   For example, the following  program modifies the
command-line argument array.

<div class="p"><!----></div>
<pre>
  public static def main(argv: Array[String](1)) {
    val argref = GlobalRef[Array[String](1)](argv);
    at(here.next()) use(argref);
  }
  static def use(argref : GlobalRef[Array[String](1)]) {
    at(argref.home) {
      val argv = argref();
      argv(0) = "Hi!";
    }
  }
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.2.3">
2.2.3</a>&nbsp;&nbsp;Warnings about <b>at</b></h4>
There are two dangers involved with <b>at</b>: 

<ul>
<li> Careless use of <b>at</b> can result in copying and transmission
of very large data structures.  In particular, it is very easy to capture
<b>this</b> - a field reference will do it - and accidentally copy everything
that <b>this</b> refers to, which can be very large.
<div class="p"><!----></div>
</li>

<li> As seen in the examples above, a local variable reference
  <b>x</b> may refer to different objects in different nested <b>at</b>
  scopes The programmer must either ensure that a variable accessed
  across an <b>at</b> boundary has no mutable state or be prepared to
  reason about which copy gets modified.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.2.4">
2.2.4</a>&nbsp;&nbsp;<tt>at</tt> and Variables</h4>


<div class="p"><!----></div>
<b>var</b> variables can be set at the place that they are declared, but not
from other places.  This allows a straightforward way to transmit several
pieces of information back from an <b>at(somewhereElse)</b>, as shown by the
following example which computes the roots of the quadratic equation 
ax<sup>2</sup> + bx + c = 0.  
For the sake of the example, we assume that 
<tt>mathProcessor()</tt> returns a Place suitable for calculation.  In practice
it would rarely if ever make sense to send such a small calculation to another
place. 

<div class="p"><!----></div>
The starting place has local <b>var</b>s <b>r</b> and <b>s</b>, which will hold
the roots.  (They are initialized to 0+0i because of
&#167;.) 
The computation at the math processor evaluates the roots of the equation.
These roots are bound to math processor local <b>val</b> variables <b>rr</b> and
<b>ss</b>.  An inner place-shifting <b>at(h)</b> moves the computation back to
the initial place, stored for that purpose in <b>h</b>, at which values can be
assigned to the variables <b>r</b> 
and <b>s</b> at the starting place.  Note that we take care to send only the
minimal information across <b>at</b> boundaries; in particular we do not 
send the discriminant back to <b>h</b>.  When the intermediate results are
large and the desired data small, the savings can be substantial.

<div class="p"><!----></div>
<pre>
def printRootsOfQuadratic(a:Complex, b:Complex, c:Complex) {
  var r : Complex = Complex(0,0);
  var s : Complex = Complex(0,0);
  val h = here;
  at(mathProcessor()) {
    val disc = Math.sqrt(b*b - 4*a*c);
    val rr = (-b + disc) / (2*a);
    val ss = (-b - disc) / (2*a);
    at(h) {
      r = rr; s = ss;
    }
  }
  Console.OUT.println("r = " + r + "; s = " + s);
}
</pre>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;<b>async</b>: Spawning an activity</h2><a name="AsynchronousActivity">
</a><a name="AsyncActivity">
</a>



<div class="p"><!----></div>
Asynchronous activities serve as a single abstraction for supporting a
wide range of concurrency constructs such as message passing, threads,
DMA, streaming, data prefetching. (In general, asynchronous operations
are better suited for supporting scalability than synchronous
operations.)

<div class="p"><!----></div>
An activity is created by executing the <b>async</b> statement: 

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">AsyncStatement    ::= <b>async</b> ClockedClause<sup>?</sup>&nbsp;Statement </td></tr>
<tr><td align="right">
    &#124; <b>clocked</b> <b>async</b> Statement</td></tr>
<tr><td align="right">ClockedClause    ::= <b>clocked</b> <b>(</b> ClockList <b>)</b> </td></tr>
<tr><td align="right">
</td></tr></table>
</em>

<div class="p"><!----></div>
The basic form of <b>async</b> is <b>async S</b>, which starts a new activity
located <b>here</b> executing <b>S</b>.   (For the clocked form, see
&#167;.)  

<div class="p"><!----></div>

<div class="p"><!----></div>
Multiple activities launched by a single activity at another place are not
ordered in any way. They are added to the set of activities at the target
place and will be executed based on the local scheduler's decisions.
If some particular sequencing of events is needed, <b>when</b>, <b>atomic</b>,
<b>finish</b>, clocks, and other X10 constructs can be used.
X10 implementations are not required to have fair schedulers,
though every implementation should make a best faith effort to ensure
that every activity eventually gets a chance to make forward progress.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
The statement in the body of an <b>async</b> is subject to the
restriction that it must be acceptable as the body of a <b>void</b>
method for an anonymous inner class declared at that point in the code. As
such, it may reference variables in lexically enclosing scopes.


<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Finish</h2><a name="finish">
</a>
The statement <b>finish S</b> converts global termination to local
termination.

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">FinishStatement    ::= <b>finish</b> Statement </td></tr>
<tr><td align="right">
    &#124; <b>clocked</b> <b>finish</b> Statement</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
An activity A executes <b>finish S</b> by executing <b>S</b> and
then waiting for all activities spawned by <b>S</b> (directly or
indirectly, here or at other places) to terminate. An activity may
terminate normally, or abruptly, i.e. by throwing an exception.
All exceptions thrown by spawned activities are caught and
accumulated. 

<div class="p"><!----></div>
<b>finish S</b> terminates locally when all activities spawned by
<b>S</b> terminate globally (either abruptly or normally). If <b>S</b>
terminates normally, then <b>finish S</b> terminates normally and A
continues execution with the next statement after <b>finish S</b>.  If
<b>S</b> or one of the activities spawned by it terminate abruptly,
then <b>finish S</b> terminates abruptly and throws a single exception,
<b>x10.lang.MultipleExceptions</b> formed from the collection of
exceptions accumulated at <b>finish S</b>.

<div class="p"><!----></div>
Thus <b>finish S</b> statement serves as a collection point for
uncaught exceptions generated during the execution of <b>S</b>.

<div class="p"><!----></div>
Note that repeatedly <b>finish</b>ing a statement has little effect after
the first <b>finish</b>: <b>finish finish S</b> is indistinguishable
from <b>finish S</b> if <b>S</b> throws no exceptions.  (If <b>S</b> throws
exceptions, <b>finish S</b> wraps them in one layer of 
<b>MultipleExceptions</b> and <b>finish finish S</b> in two layers.)

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Initial activity</h2><a name="initial-computation">
</a>



<div class="p"><!----></div>
An X10 computation is initiated from the command line on the
presentation of a class or struct name <b>C</b>. The class or struct must have a
<b>public static def main(a: Array[String](1)):void</b> method, 
or a <b>public static def main(a: Array[String]):void</b> method, 
otherwise an exception is thrown
and the computation terminates.  The single statement
<pre>
finish async (Place.FIRST_PLACE) {
  C.main(s);
}
</pre>
 is executed where <b>s</b> is a one-dimensional <b>Array</b> of
strings created 
from the command line arguments. This single activity is the root activity
for the entire computation. (See &#167; for a discussion of
places.)

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Ateach statements</h2><a name="ateach-section">
</a>

 The <b>ateach</b> construct is deprecated.

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">AtEachStatement    ::= <b>ateach</b> <b>(</b> LoopIndex <b>in</b> Exp <b>)</b> ClockedClause<sup>?</sup>&nbsp;Statement </td></tr>
<tr><td align="right">
    &#124; <b>ateach</b> <b>(</b> Exp <b>)</b> Statement</td></tr>
<tr><td align="right">LoopIndexDeclarator    ::= Id HasResultType<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">
    &#124; <b>[</b> IdList <b>]</b> HasResultType<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; Id <b>[</b> IdList <b>]</b> HasResultType<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">LoopIndex    ::= Mods<sup>?</sup>&nbsp;LoopIndexDeclarator </td></tr>
<tr><td align="right">
    &#124; Mods<sup>?</sup>&nbsp;VarKeyword LoopIndexDeclarator</td></tr>
<tr><td align="right"></td></tr></table>
</em>
In <b>ateach(p in D) S</b>, <b>D</b> must be either of type <b>Dist</b>
(see &#167;) or of type <b>DistArray[T]</b> (see
&#167;), and <b>p</b> will be of type <b>Point</b> (see
&#167;). If <b>D</b> is an <b>DistArray[T]</b>, then
<b>ateach (p in D)S</b> is identical to 
<b>ateach(p in D.dist)S</b>; the iteration is over the array's underlying
distribution.   

<div class="p"><!----></div>
Instead of writing <b>ateach (p in D) S</b> the programmer should write 
<b>for(p in D) at(D(p)) async S</b> to get the same effect. 
For each point <b>p</b> in <b>D</b>, at place <b>D(p)</b>, <b>S</b> is
executed simultaneously.

<div class="p"><!----></div>
However, this often results in excessive communication and parallelism. Instead the
programmer may want to write: 
<pre>
for (place in D.places()) async at (place) {
    for (p in D</td><td width="150">
&#124;here) {
        S(p);
    }
}
</pre>

<div class="p"><!----></div>
If the programmer wishes to execute <b>S</b> in parallel at each place,
<b>S(p)</b> may be replaced by 
<b>async S(p)</b>
.

<div class="p"><!----></div>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Atomic blocks</h2><a name="AtomicBlocks">
</a>


<div class="p"><!----></div>
X10's <b>atomic</b> blocks provide a high-level construct for coordinating
the mutation of shared data. 
A programmer may use atomic blocks to guarantee that invariants of
shared data-structures are maintained even as they are being accessed
simultaneously by multiple activities running in the same place.  

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">AtomicStatement    ::= <b>atomic</b> Statement </td></tr>
<tr><td align="right">
 WhenStatement    ::= <b>when</b> <b>(</b> Exp <b>)</b> Statement </td></tr>
<tr><td align="right">
</td></tr></table>
</em>

<div class="p"><!----></div>
For example, consider a class <b>Redund[T]</b>, which encapsulates a list
<b>list</b> and, (redundantly) keeps the size of the list in a second field
<b>size</b>.  Then <b>r:Redund[T]</b> has the invariant 
<b>r.list.size() == r.size</b>, which must be true at any point at which
no method calls on <b>r</b> are active.

<div class="p"><!----></div>
If the <b>add</b> method on <b>Redund</b> (which adds an element to the list) 
were defined as: 
<pre>
def add(x:T) { // Incorrect
  this.list.add(x);
  this.size = this.size + 1;
}
</pre>
Then two activities simultaneously adding elements to the same <b>r</b> could break the
invariant.  Suppose that <b>r</b> starts out empty.  Let the first activity
perform the <b>list.add</b>, and compute <b>this.size+1</b>, which is 1, but not store it
back into <b>this.size</b> yet.  
(At this point, <b>r.list.size()==1</b> and <b>r.size==0</b>; the invariant
expression is false, but, as the first call to <b>r.add()</b> is active, the
invariant does not need to be true - it only needs to be true when the
call finishes.)
Now, let the second activity do its call to
<b>add</b> to completion, which finishes with <b>r.size==1</b>.  
(As before, the invariant expression is false, but a call to <b>r.add()</b> is
still active, so the invariant need not be true.)
Finally, let
the first activity finish, which assigns the <b>1</b> computed before back into
<b>this.size</b>.  At the end, there are two elements in <b>r.list</b>, but
<b>r.size==1</b>. Since there are no calls to <b>r.add()</b> active, the
invariant must be true, but it is not.

<div class="p"><!----></div>
In this case, the invariant can be maintained by making the increment atomic.
Doing so forbids that sequence of events; the <b>atomic</b> block cannot be
stopped partway.  
<pre>
def add(x:T) { 
  this.list.add(x);
  atomic { this.size = this.size + 1; }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Unconditional atomic blocks</h3>
The simplest form of an atomic block is the <em>unconditional
atomic block</em>: <b>atomic S</b>.
It is executed by an activity as if in a single step
during which all other concurrent activities in the same place are
blocked. If execution of the statement may throw an exception, it is
the programmer's responsibility to wrap the atomic block within a
<b>try</b>/<b>finally</b> clause and include undo code in the finally
clause. Thus the <b>atomic</b> statement only guarantees atomicity on
successful execution, not on a faulty execution.

<div class="p"><!----></div>

<div class="p"><!----></div>
Atomic blocks are closely related to non-blocking synchronization
constructs [], and can be used to implement 
non-blocking concurrent algorithms.

<div class="p"><!----></div>
Code executed inside of <b>atomic S</b> and <b>when S</b> is subject
to certain restrictions. A violation of these restrictions causes an 
<b>IllegalOperationException</b> to be thrown at the point of the violation.

<div class="p"><!----></div>

<ul>
<li> <b>S</b> may not spawn another activity.
<div class="p"><!----></div>
</li>

<li> <b>S</b> may not use any blocking statements; <b>when</b>, <b>next</b>,
      <b>finish</b>.  (The use of a nested <b>atomic</b> is permitted.)
<div class="p"><!----></div>
</li>

<li> <b>S</b> may not <b>force()</b> a <b>Future</b>.
<div class="p"><!----></div>
</li>

<li> <b>S</b> may not use <b>at</b> expressions.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<div class="p"><!----></div>

<b>Consequences.&nbsp;&nbsp;</b>
Note an important property of an (unconditional) atomic block:

<div class="p"><!----></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table><tr><td nowrap="nowrap" align="right" colspan="1"> <b><b>atomic</b> {<b>s</b><b>1</b><b>;</b> <b>atomic</b> <b>s</b><b>2</b>}</b> = <b><b>atomic</b> {<b>s</b><b>1</b><b>;</b> <b>s</b><b>2</b>}</b></td></tr></table></td><td width="50%"></td><td width="1" align="right">(1)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Atomic blocks do not introduce deadlocks.    They may exhibit all the bad
behavior of sequential programs, including throwing exceptions and running
forever, but they are guaranteed not to deadlock.

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.1.1">
7.1.1</a>&nbsp;&nbsp;Example</h4>

<div class="p"><!----></div>
The following class method implements a (generic) compare and swap (CAS) operation:

<div class="p"><!----></div>
<pre>
var target:Object = null;
public atomic def CAS(old1: Object, new1: Object): Boolean {
   if (target.equals(old1)) {
     target = new1;
     return true;
   }
   return false;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Conditional atomic blocks</h3>



<div class="p"><!----></div>
Conditional atomic blocks allow the activity to wait for some condition to be
satisfied before executing an atomic block. For example, consider a
<b>Redund</b> class holding a list <b>r.list</b> and, redundantly, its length
<b>r.size</b>.  A <b>pop</b> operation will delay until the <b>Redund</b> is
nonempty, and then remove an element and update the length.  
<pre>
def pop():T {
  var ret : T;
  when(size&#62;0) {
    ret = list.removeAt(0);
    size -;
    }
  return ret;
}
</pre>

<div class="p"><!----></div>
The execution of the test is atomic with the execution of the block.  This is
important; it means that no other activity can sneak in and make the condition
be false before the block is executed.  In this example, two <b>pop</b>s
executing on a list with one element would work properly. Without the
conditional atomic block - even doing the decrement atomically - one call to
<b>pop</b> could pass the <b>size&#62;0</b> guard; then the other call could run to
completion (removing the only element of the list); then, when the first call
proceeds, its <b>removeAt</b> will fail.  

<div class="p"><!----></div>
Note that <b>if</b> would not work here.  
<b>if(size&#62;0) atomic{size--; return list.removeAt(0);}</b> allows another
activity to act between the test and the atomic block.  
And 
<b>atomic{ if(size&#62;0) {size--; ret = list.removeAt(0);}}</b> 
does not wait for <b>size&#62;0</b> to become true.

<div class="p"><!----></div>
Conditional atomic blocks are of the form <b>when(b)S</b>; 
<b>b</b> is called the <em>guard</em>, and <b>S</b> the <em>body</em>.

<div class="p"><!----></div>
An activity executing such a statement suspends until such time as the  guard
is true in the current state. In that state, the 
body is executed. 
The checking of the guards and the execution of the corresponding
guarded statement is done atomically. 

<div class="p"><!----></div>
X10 does not guarantee that a conditional atomic block
will execute if its condition holds only intermittently. For, based on
the vagaries of the scheduler, the precise instant at which a
condition holds may be missed. Therefore the programmer is advised to
ensure that conditions being tested by conditional atomic blocks are
eventually stable, , they will continue to hold until the block
executes (the action in the body of the block may cause the condition
to not hold any more).

<div class="p"><!----></div>

<div class="p"><!----></div>
The statement <b>when (true) S</b> is
behaviorally identical to <b>atomic S</b>: it never suspends.

<div class="p"><!----></div>
The body <b>S</b> of <b>when(b)S</b> is subject to the same restrictions that
the body of <b>await S</b> is.  The guard is subject to the same restrictions
as well.  Furthermore, guards should not have side effects.

<div class="p"><!----></div>

<div class="p"><!----></div>
Note that this implies that guarded statements are required to be <em>
flat</em>, that is, they may not contain conditional atomic blocks. (The
implementation of nested conditional atomic blocks may require
sophisticated operational techniques such as rollbacks.)

<div class="p"><!----></div>
The following class shows how to implement a bounded buffer of size
1 in X10 for repeated communication between a sender and a
receiver.  The call <b>buf.send(ob)</b> waits until the buffer has space, and
then puts <b>ob</b> into it.  Dually, <b>buf.receive()</b> waits until the
buffer has something in it, and then returns that thing.

<div class="p"><!----></div>
<pre>
class OneBuffer[T] {
  var datum: T;
  def this(t:T) { this.datum = t; this.filled = true; }
  var filled: Boolean;
  public def send(v: T) {
    when (!filled) {
      this.datum = v;
      this.filled = true;
    }
  }
  public def receive(): T {
    when (filled) {
      v: T = datum;
      filled = false;
      return v;
    }
  }
}
</pre>


<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Note
  that depending on the state of the computation the activation path may
  traverse activities that are running, blocked or terminated.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>In X10 v2.1 the <b>finish</b>
statement is the only statement that marks its activity as a root
activity. Future versions of the language may introduce more such
statements.
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.89.<br />On 16 Oct 2010, 13:23.</small>
</html>
