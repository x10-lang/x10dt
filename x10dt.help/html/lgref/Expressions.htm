<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>`</title>

<div class="p"><!----></div>
 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
  <h1><a name="tth_chAp1">
Chapter 11 </a><br />Expressions</h1><a name="XtenExpressions">
</a>

<div class="p"><!----></div>
X10 has a rich expression language.
Evaluating an expression produces a value, or, in a few cases, no value. 
Expression evaluation may have side effects, such as change of the value of a 
<b>var</b> variable or a data structure, allocation of new values, or throwing
an exception. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Literals</h2>


<div class="p"><!----></div>
Literals denote fixed values of built-in types. 
The syntax for literals is given in &#167;. 

<div class="p"><!----></div>
The type that X10 gives a literal often includes its value. <em>E.g.</em>, <b>1</b>
is of type <b>Int{self==1}</b>, and <b>true</b> is of type
<b>Boolean{self==true}</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;<tt>this</tt></h2>



<div class="p"><!----></div>
       <em>  
<table>
<tr><td align="right">Primary ::= <b>this</b> () </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> <b>this</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The expression <b>this</b> is a  local <b>val</b> containing a reference
to an instance of the lexically enclosing class.
It may be used only within the body of an instance method, a
constructor, or in the initializer of a instance field - that is, the places
where there is an instance of the class under consideration.

<div class="p"><!----></div>
Within an inner class, <b>this</b> may be qualified with the
name of a lexically enclosing class.  In this case, it
represents an instance of that enclosing class.  

<div class="p"><!----></div>
<b>Outer</b> is a class containing <b>Inner</b>.  Each instance of
<b>Inner</b> has a reference <b>Outer.this</b> to the <b>Outer</b> involved in its
creation.  <b>Inner</b> has access to the fields of <b>Outer.this</b>.  Note
that <b>Inner</b>

<div class="p"><!----></div>
has its own <b>three</b> field, which is different from and not even the same
type as <b>Outer.this.three</b>. 
<pre>
class Outer {
  val three = 3;
  class Inner {
     val three = "THREE";
     def example()  {
       assert Outer.this.three == 3;
       assert three.equals("THREE");
       assert this.three.equals("THREE");
     }
  }
}
</pre>


<div class="p"><!----></div>
The type of a <b>this</b> expression is the
innermost enclosing class, or the qualifying class,
constrained by the class invariant and the
method guard, if any.

<div class="p"><!----></div>
The <b>this</b> expression may also be used within constraints in
a class or interface header (the class invariant and
<b>extends</b> and <b>implements</b> clauses).  Here, the type of
<b>this</b> is restricted so that only properties declared in the
class header itself, and specifically not any members declared in the class
body or in supertypes, are accessible through <b>this</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Local variables</h2>

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">Id ::= <b>IDENTIFIER</b>  </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A local variable expression consists simply of the name of the local variable,
field of the current object, formal parameter in scope, etc. It evaluates to
the value of the local variable. 

<div class="p"><!----></div>
<b>n</b> in the second line below is a local
variable expression.  The <b>n</b> in the first line is not; it is part of a
local variable declaration.
<pre>
val n = 22;
val m = n + 56;
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Field access</h2>
<a name="FieldAccess">
</a>


<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">FieldAccess ::= Primary <b>.</b> Id </td></tr>
<tr><td align="right">&#124; <b>super</b> <b>.</b> Id </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> <b>super</b>  <b>.</b> Id </td></tr>
<tr><td align="right">&#124; Primary <b>.</b> <b>class</b>  </td></tr>
<tr><td align="right">&#124; <b>super</b> <b>.</b> <b>class</b>  </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> <b>super</b>  <b>.</b> <b>class</b>  </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A field of an object instance may be  accessed
with a field access expression.

<div class="p"><!----></div>
The type of the access is the declared type of the field with the
actual target substituted for <b>this</b> in the type. 

<div class="p"><!----></div>
The declaration of <b>b</b> below has a constraint involving <b>this</b>.  
The use of an instance of it, <b>f.b</b>, has the same constraint involving
<b>f</b> instead of <b>this</b>, as required.
<pre>
class Fielded {
  public val a : Int = 1;
  public val b : Int{this.a == b} = this.a;
  static def example() {
    val f : Fielded = new Fielded();
    assert f.a == 1 &amp;&amp; f.b == 1;
    val fb : Int{fb == f.a} = f.b;
    assert fb == 1;
  }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The field accessed is selected from the fields and value properties
of the static type of the target and its superclasses.

<div class="p"><!----></div>
If the field target is given by the keyword <b>super</b>, the target's type is
the superclass of the enclosing class.  This form is used to access fields of
the parent class hidden by same-named fields of the current class.

<div class="p"><!----></div>
If the field target is <b>Cls.super</b>, then the target's type is <b>Cls</b>,
which must be an  enclosing class.  This (admittedly
obscure) form is used to access fields of an ancestor class which are shadowed
by same-named fields of some more recent ancestor.  

<div class="p"><!----></div>
This illustrates all four cases of field access.
<pre>
class Uncle {
  public static val f = 1;
}
class Parent {
  public val f = 2;
}
class Ego extends Parent {
  public val f = 3;
  class Child extends Ego {
     public val f = 4;
     def example() { 
        assert Uncle.f == 1; 
        assert Ego.super.f == 2;
        assert super.f == 3;
        assert this.f == 4;
        assert f == 4;
     }
  }
}
</pre>


<div class="p"><!----></div>
If the field target is <b>null</b>, a <b>NullPointerException</b>
is thrown.
If the field target is a class name, a static field is selected.
It is illegal to access  a field that is not visible from
the current context.
It is illegal to access a non-static field
through a static field access expression.  However, it is legal to access a
static field through a non-static reference.

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Function Literals</h2>
Function literals are described in &#167;.

<div class="p"><!----></div>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Calls</h2>
<a name="Call">
</a>
<a name="MethodInvocation">
</a>
<a name="MethodInvocationSubstitution">
</a>









<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">MethodInvocation ::= MethodName TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">&#124; Primary <b>.</b> Id TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">&#124; <b>super</b> <b>.</b> Id TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> <b>super</b>  <b>.</b> Id TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">&#124; Primary TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">ArgumentList ::= Exp </td></tr>
<tr><td align="right">&#124; ArgumentList <b>,</b> Exp </td></tr>
<tr><td align="right">MethodName ::= Id </td></tr>
<tr><td align="right">&#124; AmbiguousName <b>.</b> Id </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A <em>MethodInvocation</em> may be to either a <b>static</b> method, an
instance method, or a closure.

<div class="p"><!----></div>
The syntax for method invocations is ambiguous. <b>ob.m()</b> could either be
the invocation of a method named <b>m</b> on object <b>ob</b>, or the
application of a function held in a field <b>ob.m</b>.   If both are defined on
the same class, X10 resolves <b>ob.m()</b> to the invocation of the 
method.  If the application of a function in a field is desired, use
an alternate syntax which makes the intent clear to X10, such as
<b>(ob.m)()</b>. 

<div class="p"><!----></div>
<pre>
class Callsome {
  static val closure : () =&#62; Int = () =&#62; 1;
  static def method()            = 2;
  static def example() {
     assert Callsome.closure() == 1;
     assert Callsome.method()  == 2;
  } 
}
</pre>
However, adding a static method [mis]named <b>closure</b> makes
<b>Callsome.closure()</b> 
refer to the method, rather than the closure
<pre>
  static def closure () = 3;
  static def example() {
     assert Callsome.closure() == 3;
     assert (Callsome.closure)() == 1;
  }
</pre>


<div class="p"><!----></div>
The application form <b>e(f,g)</b>, when <b>e</b> evaluates to an object or
struct, invokes the application <b>operator</b>, 
defined in the form 
<pre>
public operator this(f:F, g:G) = "value";
</pre>

<div class="p"><!----></div>
Method selection rules are given in &#167;.

<div class="p"><!----></div>
Guard satisfaction depends on the <b>STATIC_CHECKS</b> compiler flag. 
With the flag on,
it is a static error if a method's <em>Guard</em> is not statically
satisfied by the 
caller.  
With <b>STATIC_CHECKS</b> off, the guard will be checked at runtime if
necessary. 

<div class="p"><!----></div>
In this example, a <b>DivideBy</b> object provides the service of dividing
numbers by <b>denom</b> - so long as <b>denom</b> is not zero. 
X10's strictness of checking this is under control of the <b>STATIC_CHECKS</b>
compiler option (&#167;).  

<div class="p"><!----></div>
With <b>STATIC_CHECKS</b> turned on,  the <b>example</b> method will not
compile.  The call <b>this.div(100)</b>  is not allowed; there is no
guarantee that <b>denom != 0</b>.  Casting <b>this</b> to a type 
whose constraint implies <b>denom != 0</b> permits the method call.

<div class="p"><!----></div>
With <b>STATIC_CHECKS</b> turned off, the call will compile.
X10 will insert a dynamic check that the denominator is non-zero, and will
fail at runtime if it is zero.

<div class="p"><!----></div>
<pre>
class DivideBy(denom:Int) {
  def div(numer:Int){denom != 0} = numer / denom;
  def example() {
     val thisCast = (this as DivideBy{self.denom != 0});
     thisCast.div(100);
     //ERROR (with STATIC_CHECKS): this.div(100);  
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;<tt>super</tt> calls</h3>



<div class="p"><!----></div>
The expression <b>super.f(e1...en)</b> may appear in an instance method
definition.   This causes the method invocation to be a <b>super</b>
invocation, as described in &#167;.  

<div class="p"><!----></div>
Informally, suppose the invocation appears in class <b>Cl</b>, which extends
class <b>Sup</b>. An invocation <b>this.f()</b> will call a nullary method named
<b>f</b> that appears in class <b>Cl</b> itself, if there is one.  An invocation
<b>super.f()</b> will call the nullary  <b>f</b> method in <b>Sup</b> or an
ancestor thereof, but not one in <b>Cl</b>.  Note that <b>super.f()</b> may be
used to invoke an <b>f</b> method in <b>Sup</b> which has been overridden by one
appearing in <b>Cl</b>.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Assignment</h2><a name="AssignmentStatement">
</a>

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">Assignment ::= LeftHandSide AsstOp AsstExp </td></tr>
<tr><td align="right">&#124; ExpName  <b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> AsstOp AsstExp </td></tr>
<tr><td align="right">&#124; Primary  <b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> AsstOp AsstExp </td></tr>
<tr><td align="right">LeftHandSide ::= ExpName </td></tr>
<tr><td align="right">&#124; FieldAccess </td></tr>
<tr><td align="right">AsstOp ::= <b>=</b> </td></tr>
<tr><td align="right">&#124; <b>*=</b> </td></tr>
<tr><td align="right">&#124; <b>/=</b> </td></tr>
<tr><td align="right">&#124; <b>%=</b> </td></tr>
<tr><td align="right">&#124; <b>+=</b> </td></tr>
<tr><td align="right">&#124; <b>-=</b> </td></tr>
<tr><td align="right">&#124; <b>&lt;&lt;=</b> </td></tr>
<tr><td align="right">&#124; <b>&#62;&#62;=</b> </td></tr>
<tr><td align="right">&#124; <b>&#62;&#62;&#62;=</b> </td></tr>
<tr><td align="right">&#124; <b>&amp;=</b> </td></tr>
<tr><td align="right">&#124; <b>^=</b> </td></tr>
<tr><td align="right">&#124; <b></td><td align="center">&#124;=</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The assignment expression <b>x = e</b> assigns a value given by
expression <b>e</b>
to a variable <b>x</b>.  
Most often, <b>x</b> is mutable, a <b>var</b> variable.  The same syntax is
used for delayed initialization of a <b>val</b>, but <b>val</b>s can only be
initialized once.
<pre>
  var x : Int;
  val y : Int;
  x = 1;
  y = 2; // Correct; initializes y
  x = 3; 
  // ERROR: y = 4;
</pre>

<div class="p"><!----></div>
There are three syntactic forms of
assignment: 

<ol type="1">
<li> <b>x = e;</b>, assigning to a local variable, formal parameter, field of
      <b>this</b>, etc.
<div class="p"><!----></div>
</li>

<li> <b>x.f = e;</b>, assigning to a field of an object.
<div class="p"><!----></div>
</li>

<li> `a(i<sub>1</sub>,&#8230;,i<sub>n</sub>) = v;`, where n  &#8805; 0, assigning to
      an element of an array or some other such structure. This is an operator
      call (&#167;).  For well-behaved classes it works like
      array assignment, mutatis mutandis, but there is no actual guarantee,
      and the compiler makes no assumptions about how this works for arbitrary <b>a</b>.
      Naturally, it is a static error if no suitable assignment operator
      for <b>a</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
For a binary operator &#9674;, the &#9674;-assignment expression
"x &#9674;= e" combines the current value of <b>x</b> with the value
of <b>e</b> by &#9674;, and stores the result back into <b>x</b>.  
<b>i += 2</b>, for example, adds 2 to <b>i</b>. For variables and fields, 
<pre>
x &#9674;= e 
</pre>
behaves just like 
<pre>
x = x &#9674; e.
</pre>

<div class="p"><!----></div>
The subscripting forms of &#228;(i) &#9674;= b" are slightly subtle.
Subexpressions of <b>a</b> and <b>i</b> are only evaluated once.  However,
<b>a(i)</b> and <b>a(i)=c</b> are each executed once-in particular, there is
one call to the application operator, and one to the assignment operator.
If subscripting is implemented strangely for
the class of <b>a</b>, the behavior is <em>not</em> necessarily updating a single
storage location. Specifically, <b>A()(I()) += B()</b> is tantamount to: 
<pre>
{
  val aa = A();  // Evaluate A() once
  val ii = I();  // Evaluate I() once
  val bb = B();  // Evaluate B() once
  val tmp = aa(ii) + bb; // read aa(ii)
  aa(ii) = tmp;  // write sum back to aa(ii)
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Increment and decrement</h2>





<div class="p"><!----></div>
The operators <b>++</b> and <b>--</b> increment and decrement
a variable, respectively.  
<b>x++</b> and <b>++x</b> both increment <b>x</b>, just as the statement 
<b>x += (1 as T)</b> would (where <b>x:T</b>), and similarly for <b>-</b>.  

<div class="p"><!----></div>
The difference between the two is the return value.  
<b>++x</b> and <b>-x</b> return the <em>new</em> value of <b>x</b>, after
incrementing or decrementing.
<b>x++</b> and <b>x-</b> return the <em>old</em> value of <b>x</b>, before
incrementing or decrementing.

<div class="p"><!----></div>
These operators work for any <b>x</b> for which <b>1 as T</b> is defined, where
<b>T</b> is the type of <b>x</b>.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Numeric Operations</h2>
<a name="XtenPromotions">
</a>





<div class="p"><!----></div>
Numeric types (<b>Byte</b>, <b>Short</b>, <b>Int</b>, <b>Long</b>, <b>Float</b>,
<b>Double</b>, <b>Complex</b>, and unsigned variants of fixed-point types) are normal X10
structs, though most of their methods are implemented via native code. They
obey the same general rules as other X10 structs. For example, numeric
operations, coercions, and conversions are defined by <b>operator</b> definitions, the same way you could
for any struct.

<div class="p"><!----></div>
Promoting a numeric value to a longer numeric type preserves the sign of the
value.  For example, <b>(255 as UByte) as UInt</b> is 255. 

<div class="p"><!----></div>
Most of these operations can be defined on user-defined types as well.  While
it is good practice to keep such operations consistent with the numeric
operations whenever possible, the compiler neither enforces nor assumes any
particular semantics of user-defined operations. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Conversions and coercions</h3>

<div class="p"><!----></div>
Specifically, each numeric type can be converted or coerced into each other
numeric type, perhaps with loss of accuracy.

<pre>
val n : Byte = 123 as Byte; // explicit 
val f : (Int)=&#62;Boolean = (Int) =&#62; true; 
val ok = f(n); // implicit
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;Unary plus and unary minus</h3>

<div class="p"><!----></div>
The unary <b>+</b> operation on numbers is an identity function.
The unary <b>-</b> operation on numbers is a negation function.
On unsigned numbers, these are two's-complement.  For example, 
<b>-(0x0F as UByte)</b> is 
<b>(0xF1 as UByte)</b>.


<div class="p"><!----></div>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Bitwise complement</h2>

<div class="p"><!----></div>
The unary <b>&#126;</b> operator, only defined on integral types, complements each
bit in its operand.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Binary arithmetic operations</h2> 

<div class="p"><!----></div>
The binary arithmetic operators perform the familiar binary arithmetic
operations: <b>+</b> adds, <b>-</b> subtracts, <b>*</b> multiplies, 
<b>/</b> divides, and <b>%</b>
computes remainder.

<div class="p"><!----></div>
On integers, the operands are coerced to the longer of their two types, and
then operated upon.  
Floating point operations are determined by the IEEE 754
standard. 
The integer <b>/</b> and <b>%</b> throw an exception 
if the right operand is zero.

<div class="p"><!----></div>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Binary shift operations</h2>

<div class="p"><!----></div>
When operands of the binary shift operations are of integral type, the
expression performs bitwise shifts. 
The type of the result is the type of the left operand.
The right operand, describing a number of bits, must be unsigned: 
<b>x &lt;&lt; 1U</b>.  

<div class="p"><!----></div>
If the promoted type of the left operand is <b>Int</b>,
the right operand is masked with <b>0x1f</b> using the bitwise
AND (<b>&amp;</b>) operator, giving a number at most the number of bits in an
<b>Int</b>. 
If the promoted type of the left operand is <b>Long</b>,
the right operand is masked with <b>0x3f</b> using the bitwise
AND (<b>&amp;</b>) operator, giving a number at most the number of bits in a
<b>Long</b>. 

<div class="p"><!----></div>
The <b>&lt;&lt;</b> operator left-shifts the left operand by the number of
bits given by the right operand.
The <b>&#62;&#62;</b> operator right-shifts the left operand by the number of
bits given by the right operand.  The result is sign extended;
that is, if the right operand is k,
the most significant k bits of the result are set to the most
significant bit of the operand.

<div class="p"><!----></div>
The <b>&#62;&#62;&#62;</b> operator right-shifts the left operand by the number of
bits given by the right operand.  The result is not sign extended;
that is, if the right operand is k,
the most significant k bits of the result are set to <b>0</b>.
This operation is deprecated, and may be removed in a later version of the
language. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;Binary bitwise operations</h2>

<div class="p"><!----></div>
The binary bitwise operations operate on integral types, which are promoted to
the longer of the two types.
The <b>&amp;</b> operator  performs the bitwise AND of the promoted operands.
The <b>&#124;</b> operator  performs the bitwise inclusive OR of the promoted operands.
The <b>^</b> operator  performs the bitwise exclusive OR of the promoted operands.

<div class="p"><!----></div>
 <h2><a name="tth_sEc14">
14</a>&nbsp;&nbsp;String concatenation</h2>


<div class="p"><!----></div>
The <b>+</b>  operator is used for string concatenation 
 as well as addition.
If either operand is of static type <b>x10.lang.String</b>,
 the other operand is converted to a <b>String</b> , if needed,
  and  the two strings  are concatenated.
 String conversion of a non-<b>null</b> value is  performed by invoking the
 <b>toString()</b> method of the value.
  If the value is <b>null</b>, the value is converted to 
  '"null''.

<div class="p"><!----></div>
The type of the result is <b>String</b>.

<div class="p"><!----></div>
 For example, 
      <b>&#246;ne " + 2 + here</b> 
      evaluates to  <b>one 2(Place 0)</b>.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc15">
15</a>&nbsp;&nbsp;Logical negation</h2>

<div class="p"><!----></div>
The  unary <b>!</b> operator 
applied to type <b>x10.lang.Boolean</b> 
performs logical negation.
The type of the result is <b>Boolean</b>.
If the value of the operand is <b>true</b>, the result is <b>false</b>; if
if the value of the operand  is <b>false</b>, the result is <b>true</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc16">
16</a>&nbsp;&nbsp;Boolean logical operations</h2>

<div class="p"><!----></div>
The binary  operations <b>&amp;</b> and <b>&#124;</b> 
at type <b>Boolean</b>
perform Boolean logical operations.

<div class="p"><!----></div>
The <b>&amp;</b> operator  evaluates to <b>true</b> if both of its
operands evaluate to <b>true</b>; otherwise, the operator
evaluates to <b>false</b>.

<div class="p"><!----></div>
The <b>&#124;</b> operator  evaluates to <b>false</b> if both of its
operands evaluate to <b>false</b>; otherwise, the operator
evaluates to <b>true</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc17">
17</a>&nbsp;&nbsp;Boolean conditional operations</h2>


<div class="p"><!----></div>
The binary <b>&amp;&amp;</b> and <b>&#124;&#124;</b> operations, on 
<b>Boolean</b> values, give conditional or short-circuiting Boolean operations.  

<div class="p"><!----></div>
The <b>&amp;&amp;</b> operator  evaluates to <b>true</b> if both of its
operands evaluate to <b>true</b>; otherwise, the operator
evaluates to <b>false</b>.
Unlike the logical operator <b>&amp;</b>,
if the first operand is <b>false</b>,
the second operand is not evaluated.

<div class="p"><!----></div>
The <b>&#124;&#124;</b> operator  evaluates to <b>false</b> if both of its
operands evaluate to <b>false</b>; otherwise, the operator
evaluates to <b>true</b>.
Unlike the logical operator <b>&#124;&#124;</b>,
if the first operand is <b>true</b>,
the second operand is not evaluated.

<div class="p"><!----></div>
 <h2><a name="tth_sEc18">
18</a>&nbsp;&nbsp;Relational operations</h2> 

<div class="p"><!----></div>
The relational operations on numeric types compare numbers, producing
<b>Boolean</b> results.

<div class="p"><!----></div>
The <b>&lt;</b> operator evaluates to <b>true</b> if the left operand is
less than the right.
The <b>&lt;=</b> operator evaluates to <b>true</b> if the left operand is
less than or equal to the right.
The <b>&#62;</b> operator evaluates to <b>true</b> if the left operand is
greater than the right.
The <b>&#62;=</b> operator evaluates to <b>true</b> if the left operand is
greater than or equal to the right.

<div class="p"><!----></div>
Floating point comparison is determined by the IEEE 754
standard.  Thus,
if either operand is NaN, the result is <b>false</b>.
Negative zero and positive zero are considered to be equal.
All finite values are less than positive infinity and greater
than negative infinity.

<div class="p"><!----></div>
 <h2><a name="tth_sEc19">
19</a>&nbsp;&nbsp;Conditional expressions</h2>



<a name="Conditional">
</a>

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">ConditionalExp ::= ConditionalOrExp </td></tr>
<tr><td align="right">&#124; ClosureExp </td></tr>
<tr><td align="right">&#124; AtExp </td></tr>
<tr><td align="right">&#124; FinishExp </td></tr>
<tr><td align="right">&#124; ConditionalOrExp <b>?</b> Exp <b>:</b> ConditionalExp </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A conditional expression evaluates its first subexpression (the
condition); if <b>true</b>
the second subexpression (the consequent) is evaluated; otherwise,
the third subexpression (the alternative) is evaluated.

<div class="p"><!----></div>
The type of the condition must be <b>Boolean</b>.
The type of the conditional expression is some common 
ancestor (as constrained by &#167;) of the types of the consequent and the
alternative. 

<div class="p"><!----></div>
<b>a == b ? 1 : 2</b>
evaluates to <b>1</b> if <b>a</b> and <b>b</b> are the same, and <b>2</b> if they
are different.   As the type of <b>1</b> is <b>Int{self==1}</b> and of <b>2</b>
is <b>Int{self==2}</b>, the type of the conditional expression has the form
<b>Int{c}</b>, where <b>self==1</b> and <b>self==2</b> both imply <b>c</b>.  For
example, it might be <b>Int{true}</b> - or perhaps it might be a more accurate
type, like <b>Int{self != 8}</b>. Note that this term has no most accurate type
in the X10 type system.


<div class="p"><!----></div>
The subexpression not selected is not evaluated.

<div class="p"><!----></div>
The following use of the conditional expression prevents division by zero.  If
<b>den==0</b>, the division is not performed at all.
<pre>
(den == 0) ? 0 : num/den
</pre>

<div class="p"><!----></div>
Similarly, the following code performs a method call if <b>op</b> is non-null,
and avoids the null pointer error if it is null.  Defensive coding like this
is quite common when working with possibly-null objects.
<pre>
(ob == null) ? null : ob.toString();
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc20">
20</a>&nbsp;&nbsp;Stable equality</h2>
<a name="StableEquality">
</a>



<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">EqualityExp    ::= RelationalExp =</td></tr>
<tr><td align="right">&#124; EqualityExp <b>==</b> RelationalExp</td></tr>
<tr><td align="right">&#124; EqualityExp <b>!=</b> RelationalExp</td></tr>
<tr><td align="right">&#124; Type  <b>==</b> Type </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The <b>==</b> and <b>!=</b> operators provide a fundamental, though
non-abstract, notion of equality.  <b>a==b</b> is true if the values of <b>a</b>
and <b>b</b> are extremely identical.

<div class="p"><!----></div>

<ul>
<li> If <b>a</b> and <b>b</b> are values of object type, then <b>a==b</b> holds
      if <b>a</b> and <b>b</b> are the same object.
<div class="p"><!----></div>
</li>

<li> If one operand is <b>null</b>, then <b>a==b</b> holds iff the other is
      also <b>null</b>.
<div class="p"><!----></div>
</li>

<li> If the operands both have struct type and are not in <b>x10.lang</b>, then they must be structurally equal;
that is, they must be instances of the same struct
and all their fields or components must be <b>==</b>.
<div class="p"><!----></div>
</li>

<li> The definition of equality for function types is specified in
      &#167;.
<div class="p"><!----></div>
</li>

<li> No implicit coercions are performed by <b>==</b>.
<div class="p"><!----></div>
</li>

<li> It is a static error to have an expression <b>a == b</b> if the types of
      <b>a</b> and <b>b</b> are disjoint.
<div class="p"><!----></div>
</li>

<li> The structs in <b>x10.lang</b> have unsurprising concepts of <b>==</b>: 
     
<ul>
<li> In <b>Boolean</b>, <b>true == true</b> and <b>false == false</b>.
<div class="p"><!----></div>
</li>

<li> In <b>Char</b>, <b>c == d</b> iff <b>c.ord() == d.ord()</b>.
<div class="p"><!----></div>
</li>

<li> Equality in <b>Double</b> and <b>Float</b> is IEEE floating-point
           equality.
<div class="p"><!----></div>
</li>

<li> Two <b>GlobalRef</b>s are <b>==</b> if they refer to the same object.
<div class="p"><!----></div>
</li>

<li> The integral types, <b>Byte</b>, <b>Short</b>, <b>Int</b>, <b>Long</b>,
           and their unsigned versions, use binary equality.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<b>a != b</b>
is true iff <b>a==b</b> is false.

<div class="p"><!----></div>
The predicates <b>==</b> and <b>!=</b> may not be overridden by the programmer.

<div class="p"><!----></div>
<b>==</b> provides a <em>stable</em> notion of equality.  If two values are
<b>==</b> at any time, they remain <b>==</b> forevermore, regardless of what
happens to the mutable state of the program. 

<div class="p"><!----></div>
Regardless of the values and types of <b>a</b> and <b>b</b>, 
or the behavior of <b>any_code_at_all</b> (which may, indeed, be
any code at all-not just a method call), the value of 
<b>a==b</b> does not change: 
<pre>
val a = something();
val b = something_else();
val eq1 = (a == b);
any_code_at_all();
val eq2 = (a == b);
assert eq1 == eq2;
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc20.1">
20.1</a>&nbsp;&nbsp;No Implicit Coercions for == </h3>
<a name="sect:eqeq-no-coerce">
</a>

<div class="p"><!----></div>
<b>==</b> is a primitive operation in X10 - one of very few. Most operations,
like <b>+</b> and <b>&lt;=</b>, are defined as <b>operator</b>s. <b>==</b> and
<b>!=</b> are not. As non-<b>operator</b>s, they need not and do not follow the
general method resolution procedure of &#167;. In
particular, while <b>operator</b>s perform implicit conversions on their
arguments, <b>==</b> and <b>!=</b> do not.

<div class="p"><!----></div>
The advantage of this restriction is that <b>==</b>'s behavior is as simple and
efficient as possible.  It never runs user-defined code, and the compiler can
analyze and understand it in detail - and guarantee that it is efficient.

<div class="p"><!----></div>
The disadvantage is that certain straightforward-looking idioms do not work.
One may not test that a <b>Long</b> variable is <b>==</b> to an integer like
<b>0</b>: 
<pre>
//ERROR: for(var i : Long = 0; i != 100; i++)  {}
</pre>

<div class="p"><!----></div>
A <b>Long</b> like <b>i</b> can never <b>==</b> an <b>Int</b> like <b>100</b>.

<div class="p"><!----></div>
We can write <b>i = i + 1;</b>, adding an <b>Int</b> to <b>i</b>. This works 
because the expression uses <b>+</b>,  an ordinary <b>operator</b>.
There is an implicit coercion from <b>Int</b> to <b>Long</b>, so the
<b>1</b> can be converted to <b>1L</b>, which can be added to <b>i</b>.  

<div class="p"><!----></div>
However, <b>==</b> does not permit implicit coercions, and so the <b>100</b>
stays an <b>Int</b>.  The loop must be written with a comparison of two
<b>Long</b>s: 
<pre>
for(var i : Long = 0; i != 100L; i++) {}
</pre>

<div class="p"><!----></div>
Incidentally, it could also be written 
<pre>
for(var i : Long = 0; i &lt;= 100; i++) {}
</pre>

<div class="p"><!----></div>
<pre>

<div class="p"><!----></div>
</pre>
The operation <b>&lt;=</b> is a regular operator, and thus uses coercions in its
arguments, so <b>100</b> gets coerced to <b>100L</b>.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc20.2">
20.2</a>&nbsp;&nbsp;Non-Disjointness Requirement</h3>

<div class="p"><!----></div>
It is a static error to have an expression <b>a==b</b> where <b>a</b> and
<b>b</b> could not possibly be equal, based on their types.  This is a
practical codicil to &#167;<a href="#sect:eqeq-no-coerce">20.1</a>.  Consider the illegal code 
<pre>
// NOT ALLOWED
for(var i : Long = 0; i != 100; i++) 
</pre>

<div class="p"><!----></div>
<b>100</b> and <b>100L</b> are different values; they are not <b>==</b>. A
coercion could make them equal, but <b>==</b> does not allow coercions. So, if
<b>100 == 100L</b> were going to return anything, it would have to return
<b>false</b>. This would have the unfortunate effect of making the <b>for</b>
loop run forever.

<div class="p"><!----></div>
Since this and related idioms are so common, and since so many programmers are
used to languages which are less precise about their numeric types, X10 avoids
the mistake by declaring it a static error in most cases.  Specifically,
<b>a==b</b> is not allowed if, by inspection of the types, <b>a</b> and <b>b</b>
could not possibly be equal.

<div class="p"><!----></div>
Nonetheless, it is possible to wind up comparing values of different numeric
types.   Even though, say, <b>0</b> and <b>0L</b> represent the same number,
they are different values and of different types, and hence, <b>0 != 0L</b>.  
The expression <b>0 == 0L</b> does not compile.  However, if you hide type
information from X10, you can get a similar expression to compile: 

<div class="p"><!----></div>
<pre>
   val a : Any = 0;
   val b : Any = 0L;
   assert a != b;
</pre>

<div class="p"><!----></div>

<ul>
<li> Numbers of different base types cannot be equal, and thus cannot compared for equality.  
<b>100==100L</b> is a static error.  To compare numbers, explicitly cast them
to the same type: <b>100 as Long == 100L</b>.
<div class="p"><!----></div>
</li>

<li> Indeed, structs of different types cannot be equal, and so they cannot be
compared for equality.
<div class="p"><!----></div>
</li>

<li> For objects, the story is different. Unconstrained object types can
      always be compared for equality. Given objects of unrelated classes
      <b>a:Person</b> and 
      <b>b:Theory</b>, <b>a==b</b> could be true if <b>a==null</b> and
      <b>b==null</b>.
<div class="p"><!----></div>
</li>

<li> Constrained object types may or may not be comparable.  For example,  
      if <b>Person</b> and <b>Theory</b> are both direct subclasses of
      <b>Object</b>, and <b>a:Person</b> and <b>b:Theory{self!=null}</b>, then
      <b>a==b</b> is not allowed, since the two could not possibly be equal.
<div class="p"><!----></div>
</li>

<li> Explicit casts erase type information.  If you wanted
      to have a comparison <b>a==b</b> for <b>a:Person{self!=null}</b> and
      <b>b:Theory</b>, you could write it as <b>a as Object == b as Object</b>.
      It would, of course, return <b>false</b>, but it would not be a compiler
      error.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>
      A struct and an object may both be cast to <b>Any</b> and compared for
      equality, though they, too, will always be different.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
 <h2><a name="tth_sEc21">
21</a>&nbsp;&nbsp;Allocation</h2>
<a name="ClassCreation">
</a>








<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">ClassInstCreationExp ::= <b>new</b> TypeName TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; Primary <b>.</b> <b>new</b> Id TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; AmbiguousName <b>.</b> <b>new</b> Id TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
An allocation expression creates a new instance of a class and
invokes a constructor of the class.
The expression designates the class name and passes
type and value arguments to the constructor.

<div class="p"><!----></div>
The allocation expression may have an optional class body.
In this case, an anonymous subclass of the given class is
allocated.   An anonymous class allocation may also specify a
single super-interface rather than a superclass; the superclass
of the anonymous class is <b>x10.lang.Object</b>.

<div class="p"><!----></div>
If the class is anonymous-that is, if a class body is
provided-then the constructor is selected from the superclass.
The constructor to invoke is selected using the same rules as
for method invocation (&#167;<a href="#MethodInvocation">6</a>).

<div class="p"><!----></div>
The type of an allocation expression
is the return type of the constructor invoked, with appropriate
substitutions  of actual arguments for formal parameters, as
specified in &#167;<a href="#MethodInvocationSubstitution">6</a>.

<div class="p"><!----></div>
&#167; describes allocation expressions for inner classes. 

<div class="p"><!----></div>
It is illegal to allocate an instance of an <b>abstract</b> class.
The usual visibility rules apply to allocations: 
it is illegal to allocate an instance of a class or to invoke a
constructor that is not visible at
the allocation expression.

<div class="p"><!----></div>
Note that instantiating a struct type can use function application syntax; 
<b>new</b> is optional.  As structs do not have subclassing, there is no need or
possibility of a <em>ClassBody</em>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc22">
22</a>&nbsp;&nbsp;Casts and Conversions</h2><a name="ClassCast">
</a>


<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">CastExp ::= Primary </td></tr>
<tr><td align="right">&#124; ExpName </td></tr>
<tr><td align="right">&#124; CastExp <b>as</b> Type </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The cast and conversion  operation <b>e as T</b> may be used to force an
expression into a given type <b>T</b>, 
if is permissible at run time, and either a compile-time error or a runtime
exception 
(<b>x10.lang.TypeCastException</b>) if it is not.  

<div class="p"><!----></div>
The <b>e as T</b> operation comes in two forms.  Which form applies depends on
both the source type (the type of <b>e</b>) and the target type <b>T</b>.

<ul>
<li> <b>Cast:</b> A cast makes a value have a different type, without changing
      the value's identity.  For example, <b>&#228; String" as Object</b> simply
      reconsiders the <b>String</b> object as an <b>Object</b>.  
      This cast does not need to do any 
      run-time computation, since every <b>String</b> is an <b>Object</b>; a
      cast in the reverse direction, from <b>Object</b> to <b>String</b>, would
      need a run-time check that the <b>Object</b>
      was in fact a <b>String</b>.
      Casts are all system-defined, following from the
      X10 type system.
<div class="p"><!----></div>
</li>

<li> <b>Conversions:</b> A conversion takes a value of one type and produces
      one of a different type which, conceptually, means the same thing.  
      For example, <b>1 as Float</b> is a conversion.  It performs some
      computation on <b>1</b>  to come up with a <b>Float</b> value.
      Conversions are all library- or user-defined.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc22.1">
22.1</a>&nbsp;&nbsp;Casts</h3>

<div class="p"><!----></div>
A cast <b>v as T2</b> re-imagines a value <b>v</b> of one type <b>T1</b> as being
a value of another 
type <b>T2</b>.  The
value itself does not change, nor is a new value computed.  The only
run-time computation that happens is to check that <b>v</b> is indeed a value
of type <b>T2</b> (which, in many cases, is unnecessary), and auto-boxing (&#167;).

<div class="p"><!----></div>
There are two forms of casts.  <em>Upcasts</em> happen when <b>T1 &lt;: T2</b>, that
is, when a value is being cast to a more general type.  Upcasts often don't require
any runtime computation at all, since, if <b>T1 &lt;: T2 &lt;: Object</b>, every value of type
<b>T1</b> is automatically one of type <b>T2</b>.   For example, 
<b>&#196; String" as Object</b> is an upcast: every <b>String</b> is already an
<b>Object</b>, and no work need be done to make it one.  Other upcasts may
require auto-boxing, such as <b>1 as Any</b>.  

<div class="p"><!----></div>
<em>Downcasts</em> are casts which are not upcasts.  Often they are recasting
something from a more general to a more specific type, 
though casts that cross the type hierarchy laterally are also called
downcasts.   
<pre>
   val ob : Object = &#228; String" as Object; // upcast
   val st : String = ob as String;         // downcast
   assert st == ob;
</pre>

<div class="p"><!----></div>
In
the following example, <b>Snack</b> and <b>Crunchy</b> are unrelated interfaces:
neither inherits from the other.  Some objects are both; some are one but not
the other.  Casting from a <b>Crunchy</b> to a <b>Snack</b> requires confirming
that the value being cast is indeed a <b>Snack</b>.  
<pre>
interface Snack {}
interface Crunchy {} 
class Pretzel implements Snack, Crunchy{}
class Apricot implements Snack{}
class Gravel  implements Crunchy{}
class Example{
  def example(crunchy : Crunchy) { 
    if (crunchy instanceof Snack) { 
       val snack = crunchy as Snack; 
    } } } 
</pre>

<div class="p"><!----></div>
An upcast <b>v as T2</b> requires no computation.  
A downcast <b>v as T2</b> requires testing that <b>v</b> really is a value of
type <b>T2</b>.  In either case, the cast returns the value <b>v</b>; casts do
not change value identity.

<div class="p"><!----></div>
When evaluating <b>E as T{c}</b>, first the value of <b>E</b> is converted to
type <b>T</b> (which may fail), and then the constraint <b>{c}</b> is checked
(which may also fail). 

<div class="p"><!----></div>

<ul>
<li> If <b>T</b> is a class, then the first half of the cast succeeds if the
      run-time value of <b>E</b> is an instance of class <b>T</b>, or of a
      subclass.
<div class="p"><!----></div>
</li>

<li> If <b>T</b> is an interface, then the first half of the cast succeeds if
      the run-time value of <b>E</b> is an instance of a class or struct
      implementing 
      <b>T</b>.
<div class="p"><!----></div>
</li>

<li> If <b>T</b> is a struct type, then the first half of the cast succeeds if
      the run-time value of <b>E</b> is an instance of <b>T</b>.
<div class="p"><!----></div>
</li>

<li> If <b>T</b> is a function type, then the first half of the cast succeeds
      if the run-time value of <b>X</b> is a function of that type, or an
      object or struct which implements it.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
If the first half of the cast succeeds, the second half - the constraint
<b>{c}</b> - must be checked.  In general this will be done at runtime, though
in special cases it can be checked at compile time.   For example, 
<b>n as Int{self != w}</b> succeeds if <b>n != w</b> - even if <b>w</b> is a value
read from input, and thus not determined at compile time.

<div class="p"><!----></div>
The compiler may forbid casts that it knows cannot possibly work. If there is
no way for the value of <b>E</b> to be of type <b>T{c}</b>, then 
<b>E as T{c}</b> can result in a static error, rather than a runtime error.  
For example, <b>1 as Int{self==2}</b> may fail to compile, because the compiler
knows that <b>1</b>, which has type <b>Int{self==1}</b>, cannot possibly be of
type <b>Int{self==2}</b>. 

<div class="p"><!----></div>
If, for some reason, you need to write one of these forbidden casts, cast to
<b>Any</b> first.  <b>(1 as Any) as Int{self==2}</b> always returns false, but 

<div class="p"><!----></div>
     <h3><a name="tth_sEc22.2">
22.2</a>&nbsp;&nbsp;Explicit Conversions</h3>

<div class="p"><!----></div>
Explicit conversions are written with the same syntax as casts: <b>v as T2</b>.  
Explicit conversions transform a value of one type <b>T1</b> to an unrelated
type <b>T2</b>.  Unlike casts, conversions <em>do</em> execute code, and <em>may</em>
(and generally do) return new values.  

<div class="p"><!----></div>
Explicit conversions do not arise spontaneously, as casts do. They may be
programmed directly, using the <b>operator</b> syntax of &#167;.  
Implicit coercions can also be called explicitly as conversions.  (The reverse
is not true - explicit conversions cannot be used as implicit conversions.) 

<div class="p"><!----></div>
The numeric types in <b>x10.lang</b> have explicit conversions, as described in
&#167;.  These conversions enable 
<b>1 as Float</b> and the like.  

<div class="p"><!----></div>
<b>Knot</b>s have an explicit conversion operator to <b>String</b>, and an
implicit coercion to <b>Int</b>.  Note that the implicit coercion can be used
explicitly, with <b>k as Int</b>, as well as implicitly in <b>Math.abs(k)</b>. 
<pre>
class Knot(s:String) { 
  // explicit conversion
  public static operator (x:Knot) as String = x.s + "!";
  // implicit coercion
  public static operator (x:Knot) : Int = x.s.length();
  public static def example() {
     val k = new Knot("frayed");
     assert "frayed!".equals(k as String);
     assert (k as Int) == 6;
     assert Math.abs(k) == 6; 
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc22.3">
22.3</a>&nbsp;&nbsp;Resolving Ambiguity</h3>
<a name="sect:ambig-cast">
</a>

<div class="p"><!----></div>
If <b>v as T</b> could either be a cast or an explicit coercion, X10 treats its
as a cast.  

<div class="p"><!----></div>
The <b>Thing</b> class provides an explicit conversion to <b>Object</b>.
However, since <b>Thing</b> is a subclass of <b>Object</b>, 
using the <b>as</b> operator invokes the upcast, rather than the explicit
conversion.  
<pre>
class Thing {
  public static operator (x:Thing) as Object = "different";
  public static def example() {
    val t = new Thing();
    val o = t as Object;
    assert o instanceof Thing;
  }
}
</pre>
The definition of an explicit conversion in this case is of little value,
since any use of it in the <b>t as Object</b> syntax will invoke the upcast.  


<div class="p"><!----></div>
 <h2><a name="tth_sEc23">
23</a>&nbsp;&nbsp;<b>instanceof</b></h2>
<a name="instanceOf">
</a>



<div class="p"><!----></div>
X10 permits types to be used in an in instanceof expression
to determine whether an object is an instance of the given type:

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">RelationalExp ::= ShiftExp </td></tr>
<tr><td align="right">&#124; HasZeroConstraint </td></tr>
<tr><td align="right">&#124; SubtypeConstraint </td></tr>
<tr><td align="right">&#124; RelationalExp <b>&lt;</b> ShiftExp </td></tr>
<tr><td align="right">&#124; RelationalExp <b>&#62;</b> ShiftExp </td></tr>
<tr><td align="right">&#124; RelationalExp <b>&lt;=</b> ShiftExp </td></tr>
<tr><td align="right">&#124; RelationalExp <b>&#62;=</b> ShiftExp </td></tr>
<tr><td align="right">&#124; RelationalExp <b>instanceof</b> Type </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
In the above expression, <em>Type</em> is any type. At run time, the
result of <b>e instanceof T</b>
is <b>true</b> if the
value of <b>e</b> is an instance of type <b>T</b>.
Otherwise the result is <b>false</b>. This determination may involve checking
that the constraint, if any, associated with the type is true for the given
expression.

<div class="p"><!----></div>
For example, <b>3 instanceof Int{self==x}</b> is an overly-complicated way of
saying <b>3==x</b>.

<div class="p"><!----></div>
However, it is a static error if <b>e</b> cannot possibly be an instance of
<b>C{c}</b>; the compiler will reject <b>1 instanceof Int{self == 2}</b> because
<b>1</b> can never satisfy <b>Int{self == 2}</b>. Similarly, <b>1 instanceof
String</b> is a static error, rather than an expression always returning false. 

<div class="p"><!----></div>
<b>Limitation: </b>
X10 does not currently handle <b>instanceof</b> of generics in the way you
might expect.  For example, <b>r instanceof Array[Int{self != 0}]</b> does
not test that every element of <b>r</b> is non-zero; instead, the compiler
rejects it.

<div class="p"><!----></div>
 <h2><a name="tth_sEc24">
24</a>&nbsp;&nbsp;Subtyping expressions</h2>




<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">SubtypeConstraint ::= Type  <b>&lt;:</b> Type  </td></tr>
<tr><td align="right">&#124; Type  <b>:&#62;</b> Type  </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The subtyping expression  evaluates to <b>true</b> if
"T<sub>1</sub>" is a subtype of "T<sub>2</sub>".

<div class="p"><!----></div>
The expression  evaluates to <b>true</b> if
"T<sub>2</sub>" is a subtype of "T<sub>1</sub>".

<div class="p"><!----></div>
The expression "T<sub>1</sub> == T<sub>2</sub>"
evaluates to  <b>true</b> if 
"T<sub>1</sub>" is a subtype of "T<sub>2</sub>" and
if "T<sub>2</sub>" is a subtype of "T<sub>1</sub>".

<div class="p"><!----></div>
Subtyping expressions are particularly useful in giving constraints on generic
types.  <b>x10.util.Ordered[T]</b> is an interface whose values can be compared
with values of type <b>T</b>. 
In particular, <b>T &lt;: x10.util.Ordered[T]</b> is
true if values of type <b>T</b> can be compared to other values of type
<b>T</b>.  So, if we wish to define a generic class <b>OrderedList[T]</b>, of
lists whose elements are kept in the right order, we need the elements to be
ordered.  This is phrased as a constraint on <b>T</b>: 
<pre>
class OrderedList[T]{T &lt;: x10.util.Ordered[T]} {
  // ...
}
</pre>


<div class="p"><!----></div>
<pre>
</pre>
<pre>
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc25">
25</a>&nbsp;&nbsp;Array Constructors</h2>
<a name="sect:ArrayCtors">
</a>



<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Primary ::= 
                    <b>[</b> ArgumentList<sup>?</sup>&nbsp;<b>]</b> 
</td></tr></table>
</em>

<div class="p"><!----></div>
X10 includes short syntactic forms for constructing one-dimensional arrays.
Enclose some expressions in brackets to put them in an array: 
<pre>
val ints &lt;: Array[Int](1) = [1,3,7,21];
</pre>

<div class="p"><!----></div>
The expression "[e<sub>1</sub>, &#8230;, e<sub>n</sub>]" produces an <b>n</b>-element
<b>Array[T](1)</b>, where <b>T</b> is the computed common supertype (&#167;) of the <b>
base types</b> of the expressions  &#235;<sub>i</sub>". 

<div class="p"><!----></div>
The type of
<b>[0,1,2]</b> is <b>Array[Int](1)</b>.    
More importantly, the type of 
<b>[0]</b> is also <b>Array[Int](1)</b>.  It is <em>not</em> 
<b>Array[Int{self==0}](1)</b>, even though all the elements are all 
of type <b>Int{self==0}</b>.  This is subtle but important. There are many
functions that take <b>Array[Int](1)</b>s, such as conversions to <b>Point</b>.
These functions do <em>not</em> take
<b>Array[Int{self==0}]</b>'s.

<div class="p"><!----></div>
(Suppose that the function took <b>a:Array[Int](1)</b> and 
performed 
the operation <b>a(i)=100</b>.   This operation is fine for
an <b>Array[Int](1)</b>, which is all the compiler knows about <b>a</b>.  
However, it is wrong for an <b>Array[Int{self==0}](1)</b>, because it assigns
a non-zero value to an element of the array, violating the type constraint
which says that all the elements are zero.  So, <b>Array[Int{self==0}](1)</b>
is not and must not be a subtype of <b>Array[Int](1)</b> - the two types are simply unrelated.
<b>Array[Int](1)</b> is far more useful than 
<b>Array[Int{self==0}](1)</b>, and so the compiler produces the former.)


<div class="p"><!----></div>
Occasionally one does actually need <b>Array[Int{self==0}](1)</b>, 
or, say, <b>Array[Eel{self != null}](1)</b>, an array of non-null <b>Eel</b>s.  
For these cases, cast one or more of the elements of the array to the desired type,
and the array constructor will do the right thing.  
<pre>
val zero &lt;: Array[Int{self == 0}](1) 
          = [0];
val non1 &lt;: Array[Int{self != 1}](1) 
          = [0 as Int{self != 1}];
val eels &lt;: Array[Eel{self != null}](1) 
          = [new Eel() as Eel{self != null}, 
             new Eel(), new Eel()];
</pre>


<div class="p"><!----></div>
 <h2><a name="tth_sEc26">
26</a>&nbsp;&nbsp;Coercions and conversions</h2>
<a name="XtenConversions">
</a>
<a name="User-definedCoercions">
</a>



<div class="p"><!----></div>
A <em>coercion</em> does not change object identity; a coerced object may
be explicitly coerced back to its original type through a cast. A <em>
  conversion</em> may change object identity if the type being converted
to is not the same as the type converted from. X10 permits both 
user-defined coercions and conversions (&#167;).

<div class="p"><!----></div>
     <h3><a name="tth_sEc26.1">
26.1</a>&nbsp;&nbsp;Coercions</h3>

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">CastExp ::= Primary </td></tr>
<tr><td align="right">&#124; ExpName </td></tr>
<tr><td align="right">&#124; CastExp <b>as</b> Type </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>

<b>Subsumption coercion.&nbsp;&nbsp;</b>
A value of a subtype may be implicitly coerced to any supertype.  


<div class="p"><!----></div>
If <b>Child &lt;: Person</b> and <b>val rhys:Child</b>, then <b>rhys</b> may be used
in any context that expects a <b>Person</b>.  For example, 
<pre>
class Example {
  def greet(Person) = "Hi!";
  def example(rhys: Child) {
     greet(rhys);
  }
}
</pre>

<div class="p"><!----></div>
Similarly, <b>2</b> (whose innate type is <b>Int{self==2}</b>)
is usable in a context requiring a non-zero integer
(<b>Int{self != 0}</b>).  


<div class="p"><!----></div>

<b>Explicit Coercion (Casting with <b>as</b>)&nbsp;&nbsp;</b>

<div class="p"><!----></div>
All classes and interfaces allow the use of the <b>as</b> operator for explicit
type coercion.  
Any class or
interface may be cast to any interface.  
Any interface may be cast to
any class.  Also, any interface can be cast to a struct that implements
(directly or indirectly) that interface.

<div class="p"><!----></div>
In the following code, a <b>Person</b> is cast to <b>Childlike</b>.  There is
nothing in the class definition of <b>Person</b> that suggests that a
<b>Person</b> can be <b>Childlike</b>.  However, the <b>Person</b> in question,
<b>p</b>, is actually a <b>HappyChild</b> - a subclass of <b>Person</b> - and
is, in fact, <b>Childlike</b>.  

<div class="p"><!----></div>
Similarly, the <b>Childlike</b> value <b>cl</b> is cast to <b>Happy</b>.  Though
these two interfaces are unrelated, the value of <b>cl</b> is, in fact,
<b>Happy</b>.  And the <b>Happy</b> value <b>hc</b> is cast to the class
<b>Child</b>, though there is no relationship between the two, but the actual
value is a <b>HappyChild</b>, and thus the cast is correct at runtime.

<div class="p"><!----></div>
<b>Cyborg</b> is a struct rather than a class.  So, it cannot have substructs,
and all the interfaces of all <b>Cyborg</b>s are known: a <b>Cyborg</b> is
<b>Personable</b>, but not <b>Childlike</b> or <b>Happy</b>.  So, it is correct
and meaningful to cast <b>r</b> to <b>Personable</b>.  There is no way that a
cast to <b>Childlike</b> could succeed, so <b>r as Childlike</b> is a static error.

<div class="p"><!----></div>
<pre>
interface Personable {}
class Person implements Personable {}
interface Childlike extends Personable {}
class Child extends Person implements Childlike {}
struct Cyborg implements Personable {}
interface Happy {}
class HappyChild extends Child implements Happy {}
class Example {
  static def example() {
    var p : Person = new HappyChild();
    // class -&#62; interface
    val cl : Childlike = p as Childlike; 
    // interface -&#62; interface
    val hc : Happy = cl as Happy; 
    // interface -&#62; class
    val ch : Child = hc as Child; 
    var r : Cyborg = Cyborg();
    val rl : Personable = r as Personable; 
    // ERROR: val no = r as Childlike;
  }
}
</pre>

<div class="p"><!----></div>
If the value coerced is not an instance of the target type,
and no coercion operators that can convert it to that type are defined, 
a <b>ClassCastException</b> is thrown.  Casting to a constrained
type may require a run-time check that the constraint is
satisfied.




<div class="p"><!----></div>
<b><b>Limitation: </b></b> It is currently a static error, rather than a 
<b>ClassCastException</b>, when the cast is statically determinable to be
impossible.

<div class="p"><!----></div>

<b>Effects of explicit numeric coercion&nbsp;&nbsp;</b>
<a name="sec:effects-of-explicit-numeric-coercions">
</a>

<div class="p"><!----></div>
Coercing a number of one type to another type gives the best approximation of
the number in the result type, or a suitable disaster value if no
approximation is good enough.  

<div class="p"><!----></div>

<ul>
<li> Casting a number to a <em>wider</em> numeric type is safe and effective,
      and can be done by an implicit conversion as well as an explicit
      coercion.  For example, <b>4 as Long</b> produces the <b>Long</b> value of
      4.
<div class="p"><!----></div>
</li>

<li> Casting a floating-point value to an integer value truncates the digits
      after the decimal point, thereby rounding the number towards zero.  
      <b>54.321 as Int</b> is <b>54</b>, and 
      <b>-54.321 as Int</b> is <b>-54</b>.
      If the floating-point value is too large to represent as that kind of
      integer, the coercion returns the largest or smallest value of that type
      instead: <b>1e110 as Int</b> is 
      <b>Int.MAX_VALUE</b>, <em>viz</em> <b>2147483647</b>.
<div class="p"><!----></div>
</li>

<li> Casting a <b>Double</b> to a <b>Float</b> normally truncates binary digits: <br />
      <b>0.12345678901234567890 as Float</b> is approximately <b>0.12345679f</b>.  This can
      turn a nonzero <b>Double</b> into <b>0.0f</b>, the zero of type
      <b>Float</b>: 
      <b>1e-100 as Float</b> is <b>0.0f</b>.  Since 
      <b>Double</b>s can be as large as about <b>1.79E308</b> and <b>Float</b>s
      can only be as large as about <b>3.4E38f</b>, a large <b>Double</b> will
      be converted to the special <b>Float</b> value of <b>Infinity</b>: 
      <b>1e100 as Float</b> is <b>Infinity</b>.
<div class="p"><!----></div>
</li>

<li> Integers are coerced to smaller integer types by truncating the
      high-order bits. If the value of the large integer fits into the smaller
      integer's range, this gives the same number in the smaller type: 
      <b>12 as Byte</b> is the <b>Byte</b>-sized 12, 
      <b>-12 as Byte</b> is -12. 
      However, if the larger integer <em>doesn't</em> fit in the smaller type,
      the numeric value and even the sign can change: <b>254 as Byte</b> is
      the <b>Byte</b>sized <b>-2y</b>.
<div class="p"><!----></div>
</li>

<li> Casting an unsigned integer type to a signed integer type of the same
      size (<em>e.g.</em>, <b>UInt</b> to <b>Int</b>) preserves 2's-complement bit pattern
      (<em>e.g.</em>,  <br />
      <b>UInt.MAX_VALUE as Int == -1</b>.   Casting an unsigned integer type to
      a signed integer type of a different size is equivalent to first casting
      to an unsigned integer type of the target size, and then casting to a
      signed integer type.
<div class="p"><!----></div>
</li>

<li> Casting a signed integer type to an unsigned one is similar.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
      <h4><a name="tth_sEc26.1.1">
26.1.1</a>&nbsp;&nbsp;User-defined Coercions</h4>


<div class="p"><!----></div>
Users may define coercions from arbitrary types into the container type
<b>B</b>, and coercions from <b>B</b> to arbitrary types, by providing
<b>static operator</b> definitions for the <b>as</b> operator in the definition of
<b>B</b>.  

<div class="p"><!----></div>
<pre>
class Bee {
  public static operator (x:Bee) as Int = 1;
  public static operator (x:Int) as Bee = new Bee();
  def example() {
    val b:Bee = 2 as Bee; 
    assert (b as Int) == 1;
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc26.2">
26.2</a>&nbsp;&nbsp;Conversions</h3>



<div class="p"><!----></div>

<b>Widening numeric conversion.&nbsp;&nbsp;</b>
<a name="WideningConversions">
</a>
A numeric type may be implicitly converted to a wider numeric type. In
particular, an implicit conversion may be performed between a numeric
type and a type to its right, below:

<div class="p"><!----></div>
<pre>
Byte &lt; Short &lt; Int &lt; Long &lt; Float &lt; Double
UByte &lt; UShort &lt; UInt &lt; ULong
</pre>

<div class="p"><!----></div>
Furthermore, an unsigned integer type may be implicitly coerced a signed type
large 
enough to hold any value of the type: <b>UByte</b> to <b>Short</b>, <b>UShort</b>
to <b>Int</b>, <b>UInt</b> to <b>Long</b>.  There are no implicit conversions
from signed to unsigned numbers, since they cannot treat negatives properly.

<div class="p"><!----></div>
There are no implicit conversions in cases when overflow is possible.  For
example, there is no implicit conversion between <b>Int</b> and <b>UInt</b>.  If
it is necessary to convert between these types, use <b>n as Int</b> or 
<b>n as UInt</b>, generally with a test to ensure that the value will fit and
code to handle the case in which it does not.  

<div class="p"><!----></div>

<b>String conversion.&nbsp;&nbsp;</b>
Any value that is an operand of the binary
<b>+</b> operator may
be converted to <b>String</b> if the other operand is a <b>String</b>.
A conversion to <b>String</b> is performed by invoking the <b>toString()</b>
method.

<div class="p"><!----></div>

<b>User defined conversions.&nbsp;&nbsp;</b><a name="sec:user-defined-conversions">
</a>


<div class="p"><!----></div>
The user may define implicit conversion operators from type <b>A</b> <em>to</em> a
container type <b>B</b> by specifying an operator in <b>B</b>'s definition of the form:

<div class="p"><!----></div>
<pre>
  public static operator (r: A): T = ... 
</pre>

<div class="p"><!----></div>
The return type <b>T</b> should be a subtype of <b>B</b>. The return
type need not be specified explicitly; it will be computed in the
usual fashion if it is not. However, it is good practice for the
programmer to specify the return type for such operators explicitly.
The return type can be more specific than simply <b>B</b>, for cases when there
is more information available.

<div class="p"><!----></div>
The code for <b>x10.lang.Point</b> contains a conversion from 
one-dimensional <b>Array</b>s of integers to <b>Point</b>s of the same length: 
<pre>
  public operator (r: Array[Int](1)): Point(r.length) 
         = make(r);
</pre>
This conversion is used whenever an array of integers appears in a 
context that requires a <b>Point</b>, such as subscripting. Note 
that <b>a</b> requires a <b>Point</b> of rank 2 as a subscript, and that 
a two-element <b>Array</b> (like <b>[2,4]</b>) is converted to a 
<b>Point(2)</b>.
<pre>
val a = new Array[String]((2..3) * (4..5), "hi!");
a([2,4]) = "converted!";
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc27">
27</a>&nbsp;&nbsp;Parenthesized Expressions</h2>

<div class="p"><!----></div>
If <b>E</b> is any expression, <b>(E)</b> is an expression which, when
evaluated, produces the same result as <b>E</b>.   

<div class="p"><!----></div>
The main use of parentheses is to write complex expressions for which the 
standard precedence order of operations is not appropriate: <b>1+2*3</b> is 7,
but <b>(1+2)*3</b> is 9.  

<div class="p"><!----></div>
Similarly, but perhaps less familiarly, 
parentheses can disambiguate other expressions.  In the following code, 
<b>funny.f</b> is a field-selection expression, and so <b>(funny.f)()</b> means
&#223;elect the <b>f</b> field from <b>funny</b>, and evaluate it".  However, 
<b>funny.f()</b> means &#235;valuate the <b>f</b> method on object <b>funny</b>." 
<pre>
class Funny {
  def f () = 1;
  val f = () =&#62; 2;
  static def example() {
    val funny = new Funny();
    assert funny.f() == 1;
    assert (funny.f)() == 2;
  }
}
</pre>

<div class="p"><!----></div>
Note that this does <em>
not</em> mean that <b>E</b> and <b>(E)</b> are identical in all respects; for
example, if <b>i</b> is an <b>Int</b> variable, <b>i++</b> increments <b>i</b>,
but <b>(i)++</b> is not allowed.    <b>++</b> is an assignment; it operates on
variables, not merely values, and <b>(i)</b> is simply an expression whose <em>
value</em> is the same as that of <b>i</b>. 
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Code generators often find this trick to be useful.
<br /><br />
</html>
