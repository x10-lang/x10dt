<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>Names and packages</title>
<a href="#tth_chAp1">Names and packages</a> <br/>
<ul>
<li><a href="#tth_sEc1">Names</a> <br/>
<li><a href="#tth_sEc2">Access Control</a> <br/>
<li><a href="#tth_sEc3">Packages</a> <br/>
<li><a href="#tth_sEc4">import</a> <br/>
<li><a href="#tth_sEc5">Conventions on Type Names</a> <br/>
</ul>

<div class="p"><!----></div>
 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 6 </a><br />Names and packages</h1>
<a name="packages">
</a> 

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Names</h2>

<div class="p"><!----></div>
An X10 program consists largely of giving names to entities, and then
manipulating the entities by their names. The entities involved may be
compile-time constructs, like packages, types and classes, or run-time
constructs, like numbers and strings and objects.  

<div class="p"><!----></div>
X10 names can be <em>simple names</em>, which look like identifiers: <b>vj</b>,
<b>x10</b>, <b>AndSoOn</b>. Or, they can be <em>qualified names</em>, which are
sequences of two or more identifiers separated by dots: <b>x10.lang.String</b>, 
<b>somePack.someType</b>, <b>a.b.c.d.e.f</b>.   Some entities have only simple
names; some have both simple and qualified names.

<div class="p"><!----></div>
Every declaration that introduces a name has a <em>scope</em>: the region of the
program in which the named entity can be referred to by a simple name.  
In some cases, entities may be referred to by qualified names outside of their
scope.  <em>E.g.</em>, a <b>public</b> class <b>C</b> defined in package <b>p</b> can be
referred to by the simple name <b>C</b> inside of <b>p</b>, or by the qualified
name <b>p.C</b> from anywhere.  

<div class="p"><!----></div>
Many sorts of entities have <em>members</em>.  Packages have classes, structs,
and interfaces as members.  Those, in turn, have fields, methods, types, and
so forth as members.  The member <b>x</b> of an entity named <b>E</b> (as a
simple or qualified name) has the name <b>E.x</b>; it may also have other
names.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Shadowing</h3>



<div class="p"><!----></div>
One declaration d may <em>shadow</em> another declaration d&#8242; in part of the
scope of d&#8242;, if d and d&#8242; declare variables with the same simple name n.
When d shadows d&#8242;, a use of n might refer to d's n (unless some
d" in turn shadows d), but will never refer to d&#8242;'s n.

<div class="p"><!----></div>
X10 has four namespaces:

<ul>
<li> <b>Types:</b> for classes, interfaces, structs, and defined types.
<div class="p"><!----></div>
</li>

<li> <b>Values:</b> for <b>val</b>- and <b>var</b>-bound variables; fields;
      and formal parameters of all sorts.
<div class="p"><!----></div>
</li>

<li> <b>Methods:</b> for methods of classes, interfaces, and structs.
<div class="p"><!----></div>
</li>

<li> <b>Packages:</b> for packages.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
A declaration d in one namespace, binding a name n to an entity e,
shadows all other declarations of that name n in scope at the point where
d is declared. This shadowing is in effect for the entire scope of d.  
Declarations in different namespaces do not shadow each other.
Thus, a local variable declaration may shadow a field declaration, but not a
class declaration.

<div class="p"><!----></div>
Declarations which only introduce qualified names - in X10, this is only
package declarations - cannot shadow anything.

<div class="p"><!----></div>
The rules for shadowing of imported names are given in &#167;.

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Hiding</h3>

<a name="sect:Hiding">
</a>

<div class="p"><!----></div>
Shadowing is ubiquituous in X10. Another, and considerably rarer, way that one
definition of a given simple name can render another definition of the same
name unavailable is <em>hiding</em>. If a class <b>Super</b> defines a field named
<b>x</b>, and a subclass <b>Sub</b> of <b>Super</b> also defines a field named
<b>x</b>, and <b>b:Sub</b>, then <b>b.x</b> is <b>Sub</b>'s <b>x</b> field, not
<b>Super</b>'s.  
In this case, <b>Super</b>'s <b>x</b> is said
to be <em>hidden</em>.

<div class="p"><!----></div>
Hiding is technically different from shadowing, because hiding applies in more
circumstances: a use of class <b>Sub</b>, such as <b>sub.x</b>, may involve
hiding of name <b>x</b>, though it could not involve shadowing of <b>x</b>
because <b>x</b> need not be declared as a name at that point.

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.3">
1.3</a>&nbsp;&nbsp;Obscuring</h3>

<a name="sect:Obscuring">
</a>

<div class="p"><!----></div>
The third way in which a definition of a simple name may become unavailable is
<em>obscuring</em>. This well-named concept says that, if <b>n</b> can be
interpreted as two or more of: a variable, a type, and a package, then it will
be interpreted as a variable if that is possible, or a type if it cannot be
interpreted as a variable. In this case, the unavailable interpretations are
<em>obscured</em>. 

<div class="p"><!----></div>
In the <b>example</b> method of the following code, both a struct and a local
variable are named <b>eg</b>.  Following the obscuring rules, the call
<b>eg.ow()</b> in the first <b>assert</b> uses the variable rather than the struct.  
As the second <b>assert</b> demonstrates, the struct can be accessed through
its fully-qualified name.   Note that none of this would have happened if the
coder had followed the convention that structs have capitalized names,
<b>Eg</b>, and variables have lower-case ones, <b>eg</b>. 

<div class="p"><!----></div>
<pre>
package obscuring;
struct eg {
   static def ow()= 1;
   static struct Bite {
      def ow() = 2;
   }
   def example() {
       val eg = Bite();
       assert eg.ow() == 2;
       assert obscuring.eg.ow() == 1;
     }
}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Due to obscuring, it may be impossible to refer to a type or a package via a
simple name in some circumstances.  Obscuring does not block qualified names.

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.4">
1.4</a>&nbsp;&nbsp;Ambiguity and Disambiguation</h3>

<div class="p"><!----></div>
Neither simple nor qualified names are necessarily unique.  There can be, in
general, many entities that have the same name.  This is perfectly ordinary,
and, when done well, considered good programming practice.   Various forms of
<em>disambiguation</em> are used to tell which entity is meant by a given name;
<em>e.g.</em>, methods with the same name may be disambiguated by the types of their
arguments (&#167;).

<div class="p"><!----></div>
In the following example, there are three static methods with 
qualified name <b>DisambEx.Example.m</b>; they can be disambiguated by their
different arguments.   Inside the body of the third, the simple name <b>i</b>
refers to both the <b>Int</b> formal of <b>m</b>, and to the static method 
<b>DisambEx.Example.i</b>.  
<pre>
package DisambEx; 
class Example {
  static def m() = 1;
  static def m(Boolean) = 2;
  static def i() = 3;
  static def m(i:Int) {
    if (i &#62; 10) {
      return i() + 1;
    }
    return i;
  }
  static def example() {
    assert m() == 1;
    assert m(true) == 2;
    assert m(3) == 3;
    assert m(20) == 4;
  }
}
</pre>


<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Access Control</h2>


<div class="p"><!----></div>
X10 allows programmers <em>access control</em>, that is, the ability to determine
statically where identifiers of most sorts are visible.  In particular, X10
allows <em>information hiding</em>, wherein certain data can be accessed from
only limited parts of the program. 

<div class="p"><!----></div>
There are four access control modes: 
<b>public</b> , <b>protected</b>, <b>private</b>
and uninflected package-specific scopes, much like those of Java. 
Most things can be public or private; a few things (<em>e.g.</em>, class members) can
also be protected or package-scoped.  

<div class="p"><!----></div>
Accessibility of one X10 entity (package, container, member, etc.) from within
a package or container is defined as follows: 

<ul>
<li> Packages are always accessible.
<div class="p"><!----></div>
</li>

<li> If a container <b>C</b> is public, and, if it is inside of another
      container <b>D</b>,
      container <b>D</b> is accessible, then <b>C</b> is accessible.
<div class="p"><!----></div>
</li>

<li> A member <b>m</b> of a container <b>C</b> is accessible from within
      another container  <b>E</b>
      if <b>C</b> is
      accessible, and: 
      
<ul>
<li> <b>m</b> is declared <b>public</b>; or
<div class="p"><!----></div>
</li>

<li> <b>C</b> is an interface; or
<div class="p"><!----></div>
</li>

<li> <b>m</b> is declared <b>protected</b>, and either the access is from
            within the same package that <b>C</b> is defined in, or from within
            the body of a subclass of <b>C</b> (but see
            &#167; for some fine points); or
<div class="p"><!----></div>
</li>

<li> <b>m</b> is declared <b>private</b>, and the access is from within
            the top-level class which contains the definition of <b>C</b> -
            which may be <b>C</b> itself, or, if <b>C</b> is a nested container, an
            outer class around <b>C</b>; or
<div class="p"><!----></div>
</li>

<li> <b>m</b> has no explicit class declaration (hence using the
            implicit "package"-level access control), and the access occurs
            from the same package that <b>C</b> is declared in.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Details of <b>protected</b></h3>
<a name="sect:protected-details">
</a>

<div class="p"><!----></div>
<b>protected</b> access has a few fine points. 
Within the body of a subclass <b>D</b> of the class <b>C</b> containing
the definition of a protected member <b>m</b>, 

<div class="p"><!----></div>

<ul>
<li> An access <b>e.fld</b> to a field, or <b>e.m(...)</b> to a method, is
      permitted precisely when the type of <b>e</b> is either <b>D</b> or a
      subtype of <b>D</b>.  
For example, the access to <b>that.f</b> in the following code is acceptable, but
the access to <b>xhax.f</b> is not.  
<pre>
class C {
  protected var f : Int = 0;
}
class X extends C {}
class D extends C {
  def usef(that:D, xhax:X) {
     this.f += that.f; 
     // ERROR: this.f += xhax.f;
  }
}
</pre>

<div class="p"><!----></div>
<b><b>Limitation: </b></b> The X10 compiler improperly allows access to <tt>xhax</tt> - as,
indeed, some Java compilers do, despite Java having the analogous rule.
The compiler allows you to do everything the spec says and a bit more.
<div class="p"><!----></div>
</li>

<li> An access through a qualified name <b>Q.N</b> is permitted precisely when
      the type of <b>Q</b> is <b>D</b> or a subtype of <b>D</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Qualified access to a protected constructor is subtle.  Let <b>C</b> be a class
with a <b>protected</b> constructor c, and let <b>S</b> be the innermost
class containing a use u of c.  There are three cases for u: 

<div class="p"><!----></div>

<ul>
<li> Superclass construction invocations, <b>super(...)</b> or
      <b>E.super(...)</b>, are permitted.
<div class="p"><!----></div>
</li>

<li> Anonymous class instance creations, of the forms  <b>new C(...){...}</b>
      and <b>E.new C(...){...}</b>, are
      permitted.
<div class="p"><!----></div>
</li>

<li> No other accesses are permitted.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Packages</h2>

<div class="p"><!----></div>
A package is a named collection of top-level type declarations, <em>viz</em>, class,
interface, and struct declarations. Package names are sequences of
identifiers, like <b>x10.lang</b> and <b>com.ibm.museum</b>. The multiple names
are simply a convenience, though there is a tenuous relationship between
packages <b>a</b>, <b>a.b</b>, and <b>a.c</b>.   Packages can be accessed by
name from anywhere: a package may contain private elements, but may not itself
be private. 

<div class="p"><!----></div>
Packages and protection modifiers determine which top-level names can be used
where. Only the <b>public</b> members of package <b>pack.age</b> can be accessed
outside of <b>pack.age</b> itself.  
<pre>
package pack.age;
class Deal {
  public def make() {}
}
public class Stimulus {
  private def taxCut() = true;
  protected def benefits() = true;
  public def jobCreation() = true;
  /*package*/ def jumpstart() = true;
}
</pre>

<div class="p"><!----></div>
The class <b>Stimulus</b> can be referred to from anywhere outside of
<b>pack.age</b> by its full name of <b>pack.age.Stimulus</b>, or can be imported
and referred to simply as <b>Stimulus</b>.  The public <b>jobCreation()</b>
method of a <b>Stimulus</b> can be referred to from anywhere as well; the other
methods have smaller visibility.  The non-<b>public</b> class <b>Deal</b> cannot
be used from outside of <b>pack.age</b>.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Name Collisions</h3>

<div class="p"><!----></div>
It is a static error for a package to have two members with the same name. For
example, package <b>pack.age</b> cannot define two classes both named
<b>Crash</b>, nor a class and an interface with that name.

<div class="p"><!----></div>
Furthermore, <b>pack.age</b> cannot define a member <b>Crash</b> if there is
another package named <b>pack.age.Crash</b>, nor vice-versa. (This prohibition
is the only actual relationship between the two packages.)  This prevents the
ambiguity of whether <b>pack.age.Crash</b> refers to the class or the package.  
Note that the naming convention that package names are lower-case and package
members are capitalized prevents such collisions.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;<tt>import</tt> Declarations</h2>
<a name="sect:ImportDecl">
</a>


<div class="p"><!----></div>
Any public member of a package can be referred to from anywhere through a
fully-qualified name: <b>pack.age.Stimulus</b>.    

<div class="p"><!----></div>
Often, this is too awkward.  X10 has two ways to allow code outside of a class
to refer to the class by its short name (<b>Stimulus</b>): single-type imports
and on-demand imports.   

<div class="p"><!----></div>
Imports of either kind appear at the start of the file, immediately after the
<b>package</b> directive if there is one; their scope is the whole file.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Single-Type Import</h3>

<div class="p"><!----></div>
The declaration <b>import </b> <em>TypeName</em> <b>;</b> imports a single type
into the current namespace.  The type it imports must be a fully-qualified
name of an extant type, and it must either be in the same package (in which
case the <b>import</b> is redundant) or be declared <b>public</b>.  

<div class="p"><!----></div>
Furthermore, when importing <b>pack.age.T</b>, there must not be another type
named <b>T</b> at that point: neither a  <b>T</b> declared in <b>pack.age</b>,
nor a <b>inst.ant.T</b> imported from some other package.

<div class="p"><!----></div>
The declaration <b>import E.n;</b>, appearing in file f of a package named
<b>P</b>, shadows the following types named <b>n</b> when they appear in f: 

<ul>
<li> Top-level types named <b>n</b> appearing in other files of <b>P</b>, and
<div class="p"><!----></div>
</li>

<li> Types named <b>n</b> imported by automatic imports
      (&#167;) in f.
<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Automatic Import</h3>
<a name="sect:AutomaticImport">
</a>

<div class="p"><!----></div>
The automatic import <b>import pack.age.*;</b>, loosely, imports all the public
members of <b>pack.age</b>.  In fact, it does so somewhat carefully, avoiding
certain errors that could occur if it were done naively.  Types defined in the
current package, and those imported by single-type imports, shadow those
imported by automatic imports.   
If two automatic imports provide the same short name <b>n</b>, it is an error
to use <b>n</b> - but it is not an error if no conflicting name is ever used. 
Names automatically imported never shadow any
other names.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Implicit Imports</h3>

<div class="p"><!----></div>
The packages <b>x10.lang</b>, <b>x10.array</b> are automatically imported in all
files without need for further specification.
Furthermore, the public static members of the class named <b>_</b> in
<b>x10.lang</b> are imported everywhere as well. This provides a number of
aliases, such as <b>Console</b> and <b>int</b> for <b>x10.io.Console</b> and
<b>Int</b>. 

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Conventions on Type Names</h2>

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">TypeName ::= Id </td></tr>
<tr><td align="right">&#124; TypeName <b>.</b> Id </td></tr>
<tr><td align="right">PackageName ::= Id </td></tr>
<tr><td align="right">&#124; PackageName <b>.</b> Id </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
While not enforced by the compiler, classes and interfaces
in the X10 library follow the following naming conventions.
Names of types-including classes,
type parameters, and types specified by type definitions-are in
CamelCase and begin with an uppercase letter.  (Type variables are often
single capital letters, such as <b>T</b>.)
For backward
compatibility with languages such as C and Java, type
definitions are provided to allow primitive types
such as <b>int</b> and <b>boolean</b> to be written in lowercase.
Names of methods, fields, value properties, and packages are in camelCase and
begin with a lowercase letter. 
Names of <b>static val</b> fields are in all uppercase with words
separated by <b>_</b>'s.

<br /><br /><hr />
</html>
