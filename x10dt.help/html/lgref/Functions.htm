<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>`</title>

<div class="p"><!----></div>
`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
    




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />Functions</h1>
<a name="Functions">
</a>
<a name="functions">
</a>



<a name="Closures">
</a>

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Overview</h2>
Functions, the last of the three kinds of values in X10, encapsulate pieces of
code which can be applied to a vector of arguments to produce a value.
Functions, when applied, can do nearly anything that any other code could do:
fail to terminate, throw an exception, modify variables, spawn activities,
execute in several places, and so on. X10 functions are not mathematical
functions: the <b>f(1)</b> may return <b>true</b> on one call and <b>false</b> on
an immediately following call.

<div class="p"><!----></div>
It is a limitation of X10 v2.1 that functions do not support
type arguments. This limitation may be removed in future versions of
the language.

<div class="p"><!----></div>
A <em>function literal</em> <b>(x1:T1,..,xn:Tn){c}:T=&#62;e</b> creates a function of
type<br /><b>(x1:T1,...,xn:Tn){c}=&#62;T</b> (&#167;).  For example, 
<b>(x:Int) =&#62; x*x</b> is a function literal describing the squaring function on
integers.   
<b>null</b> is also a function value.

<div class="p"><!----></div>
<em>Limitation</em> Function literals do not currently support guards. 

<div class="p"><!----></div>
Function application is written <b>f(a,b,c)</b>, following common mathematical
usage. 


<div class="p"><!----></div>
The function body may be a block.  To compute integer squares by repeated
addition (inefficiently), one may write: 
<pre>
val sq: (Int) =&#62; Int 
      = (n:Int) =&#62; {
           var s : Int = 0;
           val abs_n = n &lt; 0 ? -n : n;
           for ([i] in 1..abs_n) s += abs_n;
           s
        };
</pre>

<div class="p"><!----></div>
A function literal evaluates to a function entity &#981;. When &#981; is
applied to a suitable list of actual parameters <b>a1</b>-<b>an</b>, it
evaluates <b>e</b> with the formal parameters bound to the actual parameters.
So, the following are equivalent, where <b>e</b> is an expression involving
<b>x1</b> and <b>x2</b><a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>

<div class="p"><!----></div>
<pre>
{
  val f = (x1:T1,x2:T2){true}:T =&#62; e;
  val a1 : T1 = arg1();
  val a2 : T2 = arg2();
  result = f(a1,a2);
}
</pre>
and 
<pre>
{
  val a1 : T1 = arg1();
  val a2 : T2 = arg2();
  {
     val x1 : T1 = a1;
     val x2 : T2 = a2;
     result = e;
  }  
}
</pre>

This doesn't quite work if the body is a statement rather than an expression.
A few language features are forbidden (<b>break</b> or <b>continue</b> of a loop
that surrounds the function literal) or mean something different (<b>return</b>
inside a function returns from the function). 

<div class="p"><!----></div>
The <em>method selector expression</em> <b>e.m.(x1:T1,...,xn:Tn)</b> (&#167;)
permits the specification of the function underlying
the method <b>m</b>, which takes arguments of type <b>(x1:T1,..., xn:Tn)</b>.
Within this function, <b>this</b> is bound to the result of evaluating {e}.

<div class="p"><!----></div>
Function types may be used in <b>implements</b> clauses of class
definitions. Instances of such classes may be used as functions of the
given type.  Indeed, an object may behave like any (fixed) number of
functions, since the class it is an instance of may implement any
(fixed) number of function types.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Function Literals</h2>

<a name="FunctionLiteral">
</a>

<div class="p"><!----></div>
X10 provides first-class, typed functions, including
<em>closures</em>, <em>operator functions</em>, and <em>method
  selectors</em>.

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">ClosureExp    ::= FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;<b>=&#62;</b> ClosureBody </td></tr>
<tr><td align="right">
 FormalParams    ::= <b>(</b> FormalParamList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">
 WhereClause    ::= DepParams </td></tr>
<tr><td align="right">
 DepParams    ::= <b>{</b> ExistentialList<sup>?</sup>&nbsp;Conjunction<sup>?</sup>&nbsp;<b>}</b> </td></tr>
<tr><td align="right">
 ExistentialList    ::= FormalParam </td></tr>
<tr><td align="right">
    &#124; ExistentialList <b>;</b> FormalParam</td></tr>
<tr><td align="right">HasResultType    ::= <b>:</b> Type </td></tr>
<tr><td align="right">
    &#124; <b>&lt;:</b> Type</td></tr>
<tr><td align="right">ClosureBody    ::= ConditionalExp </td></tr>
<tr><td align="right">
    &#124; Annotations<sup>?</sup>&nbsp;<b>{</b> BlockStatements<sup>?</sup>&nbsp;LastExp <b>}</b></td></tr>
<tr><td align="right">&#124; Annotations<sup>?</sup>&nbsp;Block</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Functions have zero or more formal parameters and an optional return type.
The body has the 
same syntax as a method body; it may be either an expression, a block
of statements, or a block terminated by an expression to return. In
particular, a value may be returned from the body of the function
using a return statement (&#167;). 

<div class="p"><!----></div>
The type of a function is a function type as described in &#167;.  In some
cases the 
return type <b>T</b> is also optional and defaults to the type of the
body. If a formal <b>xi</b> does not occur in any
<b>Tj</b>, {c}, <b>T</b> or {e}, the declaration <b>xi:Ti</b> may
be replaced by just <b>Ti</b>: <b>(Int)=&#62;7</b> is the integer function returning
7 for all inputs.

<div class="p"><!----></div>
<a name="ClosureGuard">
</a>As with methods, a function may declare a guard to
constrain the actual parameters with which it may be invoked.
The guard may refer to the type parameters, formal parameters,
and any <b>val</b>s in scope at the function expression.

<div class="p"><!----></div>
The body of the function is evaluated when the function is
invoked by a call expression (&#167;), not at the function's
place in the program text.

<div class="p"><!----></div>
As with methods, a function with return type <b>void</b> cannot
have a terminating expression. 
If the return type is omitted, it is inferred, as described in
&#167;.
It is a static error if the return type cannot be inferred.  <em>E.g.</em>,
<b>(Int)=&#62;null</b> is not well-defined; X10 does not know which type of
<b>null</b> is intended.  
But <b>(Int):Array[Double](1) =&#62; null</b> is legal.

<div class="p"><!----></div>
The following method takes a function parameter and uses it to
test each element of the list, returning the first matching
element.  It returns <b>absent</b> if no element matches.

<div class="p"><!----></div>
<pre>

<div class="p"><!----></div>
def find[T](f: (T) =&#62; Boolean, xs: List[T], absent:T): T = {
  for (x: T in xs)
    if (f(x)) return x;
  absent
  }
</pre>

<div class="p"><!----></div>
The method may be invoked thus:
<pre>
xs: List[Int] = new ArrayList[Int]();
x: Int = find((x: Int) =&#62; x&#62;0, xs, 0);
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Outer variable access</h3>


<div class="p"><!----></div>
In a function
"(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} =&#62; { s }"
the types , the guard <b>c</b> and the body <b>s</b>
may access many, though not all, sorts of variables from outer scopes.  
Specifically, they can access: 

<ul>
<li> All fields of the enclosing object and class;
<div class="p"><!----></div>
</li>

<li> All type parameters;
<div class="p"><!----></div>
</li>

<li> All <b>val</b> variables;
<div class="p"><!----></div>
</li>
</ul>

<b>var</b> variables cannot be accessed.

<div class="p"><!----></div>
The function body may refer to instances of enclosing classes using
the syntax <b>C.this</b>, where <b>C</b> is the name of the
enclosing class.  <b>this</b> refers to the instance of the immediately
enclosing class, as usual.

<div class="p"><!----></div>
For example, the following is legal.  
However, the commented-out line would not be legal.
Note that <b>a</b> is not a local <b>var</b> variable. It is a field of
<b>this</b>. A reference to <b>a</b> is simply short for <b>this.a</b>, which is
a use of a <b>val</b> variable (<b>this</b>).  
<pre>
class Lambda {
   var a : Int = 0;
   val b = 0;
   def m(var c : Int, val d : Int) {
      var e : Int = 0;
      val f : Int = 0;
      val closure = (var i: Int, val j: Int) =&#62; {
    	  return a + b + d + f + j + this.a + Lambda.this.a;
          // ILLEGAL: return c + e + i;
      };
      return closure;
   }
}
</pre>

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Method selectors</h2>
<a name="MethodSelectors">
</a>



<div class="p"><!----></div>
A method selector expression allows a method to be used as a
first-class function, without writing a function expression for it.
For example, consider a class <b>Span</b> defining ranges of integers.  

<div class="p"><!----></div>
<pre>
class Span(low:Int, high:Int) {
  def this(low:Int, high:Int) {property(low,high);}
  def between(n:Int) = low &lt;= n &amp;&amp; n &lt;= high;
  def example() {
    val digit = new Span(0,9);
    val isDigit : (Int) =&#62; Boolean = digit.between.(Int);
    if (isDigit(8)) Console.OUT.println("8 is!");
  }
}
</pre>


<div class="p"><!----></div>
In <b>example()</b>, 
<b>digit.between.(Int)</b> 
is a unary function testing whether its argument is between zero
and nine.  It could also be written 
<b>(n:Int) =&#62; digit.between(n)</b>.

<div class="p"><!----></div>
<em>
<table>
<tr><td align="right">MethodSelection    ::= Primary <b>.</b> Id <b>.</b> <b>(</b> FormalParamList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">
    &#124; ClassName <b>.</b> <b>super</b>  <b>.</b> Id <b>.</b> <b>(</b> FormalParamList<sup>?</sup>&nbsp;<b>)</b></td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The <em>method selector expression</em> <b>e.m.(T1,...,Tn)</b> is type
correct only if  the static type of {e} is a
class or struct or interface <b>V</b> with a method
<b>m(x1:T1,...xn:Tn){c}:T</b> defined on it (for some
<b>x1,...,xn,c,T)</b>. At runtime the evaluation of this expression
evaluates {e} to a value {v} and creates a function <b>f</b>
which, when applied to an argument list <b>(a1,...,an)</b> (of the right
type) yields the value obtained by evaluating <b>v.m(a1,...,an)</b>.

<div class="p"><!----></div>
Thus, the method selector

<div class="p"><!----></div>
<pre>
e.m.(T<sub>1</sub>, ..., T<sub>n</sub>)
</pre>
 behaves as if it were the function
<pre>
((v:V)=&#62;
  (x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} 
  =&#62; v.m(x<sub>1</sub>, ..., x<sub>n</sub>))
(e)
</pre>

<div class="p"><!----></div>
Because of overloading, a method name is not sufficient to
uniquely identify a function for a given class.
One needs the argument type information as well.
The selector syntax (dot) is used to distinguish <b>e.m()</b> (a
method invocation on <b>e</b> of method named <b>m</b> with no arguments)
from <b>e.m.()</b>
(the function bound to the method). 

<div class="p"><!----></div>
A static method provides a binding from a name to a function that is
independent of any instance of a class; rather it is associated with the
class itself. The static function selector
"T.m.(T<sub>1</sub>, ..., T<sub>n</sub>)" denotes the
function bound to the static method named <b>m</b>, with argument types
 for the type <b>T</b>. The return type
of the function is specified by the declaration of <b>T.m</b>.

<div class="p"><!----></div>
There is no difference between using a function defined directly 
directly using the function syntax, or obtained via static or
instance function selectors.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Operator functions</h2>
<a name="OperatorFunction">
</a>

Every binary operator (e.g.,
<b>+</b>,
<b>-</b>,
<b>*</b>,
<b>/</b>,
...) has a family of functions, one for
each type on which the operator is defined. The function can be
selected using the "<b>.</b>" syntax:

<div class="p"><!----></div>
<pre>
String.+              &#8801;  (x: String, y: String): String =&#62; x + y
Long.-                &#8801;  (x: Long, y: Long): Long =&#62; x - y
Float.-               &#8801;  (x: Float, y: Float): Float =&#62; x - y
Boolean.&amp;             &#8801;  (x: Boolean, y: Boolean): Boolean =&#62; x &amp; y
Int.&lt;                 &#8801;  (x: Int, y: Int): Boolean =&#62; x &lt; y
</pre>

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
Unary and binary promotion (&#167;) is not performed
when invoking these
operations; instead, the operands are coerced individually via implicit
coercions (&#167;), as appropriate.

<div class="p"><!----></div>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Functions as objects of type <b>Any</b></h2>
<a name="FunctionAnyMethods">
</a>

<div class="p"><!----></div>
<a name="FunctionEquality">
</a>  Two functions <b>f</b> and
<b>g</b> are equal if both were obtained by the same evaluation of a function
literal.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a> Further, it is guaranteed that if two
functions are equal then they refer to the same locations in the environment
and represent the same code, so their executions in an identical situation are
indistinguishable. (Specifically, if <b>f == g</b>, then <b>f(1)</b> can be
substituted for <b>g(1)</b> and the result will be identical. However, there is
no guarantee that <b>f(1)==g(1)</b> will evaluate to true. Indeed, there is no
guarantee that <b>f(1)==f(1)</b> will evaluate to true either, as <b>f</b> might
be a function which returns n on its n<sup>th</sup> invocation. However,
<b>f(1)==f(1)</b> and <b>f(1)==g(1)</b> are interchangeable.)


<div class="p"><!----></div>
Every function type implements all the methods of <b>Any</b>.
<b>f.equals(g)</b> is equivalent to <b>f==g</b>.  <b>f.hashCode()</b>, 
<b>f.toString()</b>, and <b>f.typeName()</b> are implementation-dependent, but
respect <b>equals</b> and the basic contracts of <b>Any</b>. 

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Strictly, there are a few other requirements;
  <em>e.g.</em>, <b>result</b> must be a <b>var</b> of type <b>T</b> defined outside the
  outer block, the variables <b>a1</b> and <b>a2</b> had better not appear in
  <b>e</b>, and everything in sight had better typecheck properly.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>A literal may occur in program text within a loop, and hence
  may be evaluated multiple times.
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.89.<br />On 16 Oct 2010, 13:23.</small>
</html>
