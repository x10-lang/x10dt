<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>`</title>

<div class="p"><!----></div>
`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
    




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />Classes</h1>
<a name="XtenClasses">
</a>
<a name="ReferenceClasses">
</a>

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Principles of X10 Objects</h2><a name="XtenObjects">
</a>


<div class="p"><!----></div>
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Basic Design</h3>

<div class="p"><!----></div>
Objects are instances of classes: the most common and most powerful sort of
value in X10.  The other kinds of values, structs and functions, are more
specialized, better in some circumstances but not in all.
<b>x10.lang.Object</b> is the most general class; all other classes inherit
from it, directly or indirectly. 

<div class="p"><!----></div>
Classes are structured in a single-inheritance code
hierarchy, may implement multiple interfaces, may have static and
instance fields, may have static and instance methods, may have
constructors, 
may have static and instance nested classes and interfaces. X10 does not
permit mutable static state.

<div class="p"><!----></div>
X10 objects do not have locks associated with them.
Programmers should use atomic blocks (&#167;) for mutual
exclusion and clocks (&#167;) for sequencing multiple parallel
operations.

<div class="p"><!----></div>
An object exists in a single location: the place that it was created.  One
place cannot directly refer to an object in a different place.   A
special type, <b>GlobalRef[T]</b>, allows explicit cross-place references. 

<div class="p"><!----></div>
The basic operations on objects are:

<ul>
<li> Field access (&#167;). 
The static and instance fields of an object can be retrieved; <b>var</b> fields
can be set.  

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>

<li> Method invocation (&#167;).  
Static and instance methods of an object can be invoked.

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>

<li> Casting (&#167;) and instance testing with <b>instanceof</b>
(&#167;) Objects can be cast or type-tested.
<div class="p"><!----></div>
</li>

<li> The equality operators <b>==</b> and <b>!=</b>
Objects can be compared for equality with the <b>==</b> operation.  This checks
object <em>identity</em>: two objects are <b>==</b> iff they are the same object.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
        <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Class Declaration Syntax</h3>

<div class="p"><!----></div>
The <em>class declaration</em> has a list of type parameters, properties, a
constraint (the <em>class invariant</em>), a single superclass, zero or more
interfaces, and a class body containing the the definition of fields,
properties, methods, and member types. Each such declaration introduces a
class type (&#167;).

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">NormalClassDecl    ::= Mods<sup>?</sup>&nbsp;<b>class</b> Id TypeParamsWithVariance<sup>?</sup>&nbsp;Properties<sup>?</sup>&nbsp;WhereClause<sup>?</sup>&nbsp;Super<sup>?</sup>&nbsp;Interfaces<sup>?</sup>&nbsp;ClassBody </td></tr>
<tr><td align="right">
 TypeParamsWithVariance    ::= <b>[</b> TypeParamWithVarianceList <b>]</b> </td></tr>
<tr><td align="right">
 TypeParamWithVarianceList    ::= TypeParamWithVariance </td></tr>
<tr><td align="right">
    &#124; TypeParamWithVarianceList <b>,</b> TypeParamWithVariance</td></tr>
<tr><td align="right">TypeParamWithVariance    ::= Id </td></tr>
<tr><td align="right">
    &#124; <b>+</b> Id</td></tr>
<tr><td align="right">&#124; <b>-</b> Id</td></tr>
<tr><td align="right">Properties    ::= <b>(</b> PropertyList <b>)</b> </td></tr>
<tr><td align="right">
 PropertyList    ::= Property </td></tr>
<tr><td align="right">
    &#124; PropertyList <b>,</b> Property</td></tr>
<tr><td align="right">Property    ::= Annotations<sup>?</sup>&nbsp;Id ResultType </td></tr>
<tr><td align="right">
 WhereClause    ::= DepParams </td></tr>
<tr><td align="right">
 DepParams    ::= <b>{</b> ExistentialList<sup>?</sup>&nbsp;Conjunction<sup>?</sup>&nbsp;<b>}</b> </td></tr>
<tr><td align="right">
 Super    ::= <b>extends</b> ClassType </td></tr>
<tr><td align="right">
 Interfaces    ::= <b>implements</b> InterfaceTypeList </td></tr>
<tr><td align="right">
 InterfaceTypeList    ::= Type </td></tr>
<tr><td align="right">
    &#124; InterfaceTypeList <b>,</b> Type</td></tr>
<tr><td align="right">ClassBody    ::= <b>{</b> ClassBodyDecls<sup>?</sup>&nbsp;<b>}</b> </td></tr>
<tr><td align="right">
 ClassBodyDecls    ::= ClassBodyDecl </td></tr>
<tr><td align="right">
    &#124; ClassBodyDecls ClassBodyDecl</td></tr>
<tr><td align="right">ClassBodyDecl    ::= ClassMemberDecl </td></tr>
<tr><td align="right">
    &#124; CtorDecl</td></tr>
<tr><td align="right">ClassMemberDecl    ::= FieldDecl </td></tr>
<tr><td align="right">
    &#124; MethodDecl</td></tr>
<tr><td align="right">&#124; PropertyMethodDecl</td></tr>
<tr><td align="right">&#124; TypeDefDecl</td></tr>
<tr><td align="right">&#124; ClassDecl</td></tr>
<tr><td align="right">&#124; InterfaceDecl</td></tr>
<tr><td align="right">&#124; <b>;</b></td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Fields</h2>
<a name="FieldDefinitions">
</a>



<div class="p"><!----></div>
Objects may have <em>instance fields</em>, or simply <em>fields</em>: places to
store data that is pertinent to the object. Fields, like variables, may be
mutable (<b>var</b>) or immutable (<b>val</b>)
.

<div class="p"><!----></div>
Class may have <em>static fields</em>, which store data pertinent to the
entire class of objects.  
See &#167; for more information.

<div class="p"><!----></div>
No two fields of the same class may have the same name.

<div class="p"><!----></div>
To avoid an ambiguity, it is a static error to invoke  a field with a function
type (&#167;) that has 
the same name and signature  as a method of the same class.  
(Consider the class 
<pre>
class Crash {
  val f : (Int) =&#62; Boolean = (Int)=&#62;true;
  def f(Int) = false;
}
</pre>

Then <b>crash.f(3)</b> might either mean "call the function <b>crash.f</b> on
argument <b>3</b>", or &#239;nvoke the method <b>f</b> on argument <b>3</b>".)

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Field Initialization</h3>



<div class="p"><!----></div>
Fields may be given values via <em>field initialization expressions</em>:
<b>val f1 = E;</b> and <b>var f2 : Int = F;</b>. Other fields of <b>this</b> may
be referenced, but only those that <em>precede</em> the field being initialized.
For example, the following is correct, but would not be if the fields were
reversed:

<div class="p"><!----></div>
<pre>
class Fld{
  val a = 1;
  val b = 2+a;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Field hiding</h3>

<div class="p"><!----></div>
A subclass that defines a field <b>f</b> hides any field <b>f</b>
declared in a superclass, regardless of their types.  The
superclass field <b>f</b> may be accessed within the body of
the subclass via the reference <b>super.f</b>.

<div class="p"><!----></div>
<pre>
class Super{ 
  val f = 1; 
}
class Sub extends Super {
  val f = true;
  def superf() : Int = super.f; // 1
}
</pre>

<div class="p"><!----></div>
With inner classes, it is occasionally necessary to 
write <b>Cls.super.f</b> to get at a hidden field <b>f</b> of an outer class
<b>Cls</b>, as in 
<pre>
class A {
   val f = 3;
}
class B extends A {
   val f = 4;
   class C extends B {
      // C is both a subclass and inner class of B
      val f = 5;
      def foo()
         = f          // 5
         + super.f    // 4
         + B.this.f   // 4 (the "f" of the outer instance)
         + B.super.f; // 3 (the &#223;uper.f" of the outer instance)
    }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Field qualifiers</h3>
<a name="FieldQualifier">
</a>


<div class="p"><!----></div>
The behavior of a field may be changed by a field qualifier, such as
<b>static</b> or <b>transient</b>.  

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.3.1">
2.3.1</a>&nbsp;&nbsp;<b>static</b> qualifier</h4>


<div class="p"><!----></div>
A <b>val</b> field may be declared to be <em>static</em>, as described in
&#167;<a href="#FieldDefinitions">2</a>. 

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.3.2">
2.3.2</a>&nbsp;&nbsp;<b>transient</b> Qualifier</h4>
<a name="TransientFields">
</a>



<div class="p"><!----></div>
A field may be declared to be <em>transient</em>.  Transient fields are excluded
from the deep copying that happens when information is sent from place to
place in an <b>at</b> statement.    The value of a transient field of a copied
object is the default value of its type, regardless of the value of the field
in the original.  If the type of a field has no
default value, it cannot be marked <b>transient</b>.
<pre>
class Trans { 
   val copied = "copied";
   transient var transy : String = &#228; very long string";
   def example() {
      at (here) { // causes copying
         assert(this.copied.equals("copied"));
         assert(this.transy == null);
      }
   }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Properties</h2>
<a name="PropertiesInClasses">
</a>


<div class="p"><!----></div>
The properties of an object (or struct) are  public <b>val</b> fields
usable at compile time in constraints.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a> 
For example,  every array has a <b>rank</b> telling
how many subscripts it takes.  User-defined classes can have whatever
properties are desired. 

<div class="p"><!----></div>
Properties are defined in parentheses, after the name of the class.  They are
given values by the <b>property</b> command in constructors.
<pre>
class Proper(t:Int) {
  def this(t:Int) {property(t);}
}
</pre>

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
It is a compile-time error for a class
defining a property <b>x: T</b> to have an ancestor class that defines
a property with the name <b>x</b>.  


<div class="p"><!----></div>
A property <b>x:T</b> induces a field with the same name and type, 
as if defined with: 
<pre>
public val x : T;
</pre>
 It also defines a nullary getter method, 
<pre>
public final def x()=x;
</pre>

<div class="p"><!----></div>
 (As noted in &#167;, interfaces can define
properties too. They define the same nullary getter methods, though they do
not require fields.)

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
It is a compile-time error for a class or
interface defining a property <b>x :T</b> to have an existing method with
the signature <b>x(): T</b>.


<div class="p"><!----></div>
Properties are initialized by the invocation of a special <b>property</b>
statement, which must be performed by each constructor of the class:
<pre>
property(e1,..., en);
</pre>
The number and types of arguments to the <b>property</b> statement must match
the number and types of the properties in the class declaration.  
Every constructor of a class with properties must invoke <b>property(...)</b>
precisely once; it is a static error if X10 cannot prove that this holds.

<div class="p"><!----></div>
The requirement to use the <b>property</b> statement means that all properties
must be given values at the same time.  

<div class="p"><!----></div>
By construction, the graph whose nodes are values and whose edges are
properties is acyclic.  <em>E.g.</em>, there cannot be values <b>a</b> and <b>b</b> with
properties <b>c</b> and <b>d</b> such that <b>a.c == b</b> and <b>b.d == a</b>.

<div class="p"><!----></div>
<a name="PropertyCall">
</a> <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Methods</h2>





<div class="p"><!----></div>
As is common in object-oriented languages, objects can have <em>methods</em>, of
two sorts.  <em>Static methods</em> are functions, conceptually associated with a
class and defined in its namespace.  <em>Instance methods</em> are parameterized
code bodies associated with an instance of the class, which execute with
convenient access to that instance's fields. 

<div class="p"><!----></div>
Each method has a <em>signature</em>, telling what arguments it accepts, what
type it returns, what precondition it requires. Method definitions may be
overridden by subclasses; the overriding definition may have a declared return
type that is a subtype of the return type of the definition being overridden.
Multiple methods with the same name but different signatures may be provided
on a class (called "overloading" or "ad hoc polymorphism"). Methods may be
declared <b>public</b>, <b>private</b>, <b>protected</b>, or given default package-level access
rights.

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">MethMods    ::= Mods<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">
    &#124; MethMods <b>property</b> </td></tr>
<tr><td align="right">&#124; MethMods Mod</td></tr>
<tr><td align="right">MethodDecl    ::= MethMods <b>def</b> Id TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">
 TypeParams    ::= <b>[</b> TypeParamList <b>]</b> </td></tr>
<tr><td align="right">
 FormalParams    ::= <b>(</b> FormalParamList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">
 FormalParamList    ::= FormalParam </td></tr>
<tr><td align="right">
    &#124; FormalParamList <b>,</b> FormalParam</td></tr>
<tr><td align="right">HasResultType    ::= <b>:</b> Type </td></tr>
<tr><td align="right">
    &#124; <b>&lt;:</b> Type</td></tr>
<tr><td align="right">MethodBody    ::= <b>=</b> LastExp <b>;</b> </td></tr>
<tr><td align="right">
    &#124; <b>=</b> Annotations<sup>?</sup>&nbsp;<b>{</b> BlockStatements<sup>?</sup>&nbsp;LastExp <b>}</b></td></tr>
<tr><td align="right">&#124; <b>=</b> Annotations<sup>?</sup>&nbsp;Block</td></tr>
<tr><td align="right">&#124; Annotations<sup>?</sup>&nbsp;Block</td></tr>
<tr><td align="right">&#124; <b>;</b></td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A formal parameter may have a <b>val</b> or <b>var</b>
modifier; <b>val</b> is the default.
The body of the method is executed in an environment in which 
each formal parameter corresponds to a local variable (<b>var</b> iff the
formal parameter is <b>var</b>)
and is initialized with the value of the actual parameter.
<pre>
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Method Guards</h3>
<a name="MethodGuard">
</a>



<div class="p"><!----></div>
Often, a method will only make sense to invoke under certain
statically-determinable conditions.  For example, <b>example(x)</b> is only
well-defined when <b>x != null</b>, as <b>null.toString()</b> throws a null
pointer exception: 
<pre>
class Example {
   var f : String = "";
   def example(x:Object){x != null} = {
      this.f = x.toString();
   }
}
</pre>

(We could have used a constrained type <b>Object{self!=null}</b> instead; in
most cases it is a matter of personal preference or convenience of expression
which one to use.) 

<div class="p"><!----></div>
The requirement of having a method guard is that callers must demonstrate to
the X10
compiler that the guard is satisfied.  (As usual with static constraint
checking, there is no runtime cost.  Indeed, this code can be more efficient
than usual, as it is statically provable that <b>x != null</b>.)
This may require a cast: 
<pre>
  def exam(e:Example, x:Object) {
    if (x != null) 
       e.example(x as Object{x != null});
    // WRONG: if (x != null) e.example(x);
  }
</pre>

<div class="p"><!----></div>
The guard <b>{c}</b> 
in a guarded method 
<b>def m(){c} = E;</b>
specifies a constraint <b>c</b> on the
properties of the class <b>C</b> on which the method is being defined. The
method exists only for those instances of <b>C</b> which satisfy <b>c</b>.  It is
illegal for code to invoke the method on objects whose static type is
not a subtype of <b>C{c}</b>.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
The compiler checks that every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    is type correct. Each argument
    &#235;<sub>i</sub>" must have a
    static type "S<sub>i</sub>" that is a subtype of the declared type
    "T<sub>i</sub>" for the ith
    argument of the method, and the conjunction of the constraints on the
    static types 
    of the arguments must entail the guard in the parameter list
    of the method.

<div class="p"><!----></div>
    The compiler checks that in every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    the static type of <b>o</b>, <b>S</b>, is a subtype of <b>C{c}</b>, where the method
    is defined in class <b>C</b> and the guard for <b>m</b> is equivalent to
    <b>c</b>.

<div class="p"><!----></div>
    Finally, if the declared return type of the method is
    <b>D{d}</b>, the
    return type computed for the call is
    "D{a: S; x<sub>1</sub>: S<sub>1</sub>; ...; x<sub>n</sub>: S<sub>n</sub>; d[a/this]}",
    where <b>a</b> is a new
    variable that does not occur in
    "d, S, S<sub>1</sub>, ..., S<sub>n</sub>", and
    "x<sub>1</sub>, ..., x<sub>n</sub>" are the formal
    parameters of the method.


<div class="p"><!----></div>
<em><em>Limitation</em> 
Using a reference to an outer class, <b>Outer.this</b>, in a constraint, is not supported.
</em>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Property methods</h3>



<div class="p"><!----></div>
Property methods are methods that can be evaluated in constraints.  
For example, the <b>eq()</b> method below tells if the <b>x</b> and <b>y</b>
properties are equal; the <b>is(z)</b> method tells if they are both equal to
<b>z</b>.  These can be used in constraints, as illustrated in the
<b>example()</b> method.
<pre>
class Example(x:Int, y:Int) {
   def this(x:Int, y:Int) { property(x,y); }
   property eq() = (x==y);
   property is(z:Int) = x==z &amp;&amp; y==z;
   def example( a : Example{eq()}, b : Example{is(3)} ) {}
}
</pre>

<div class="p"><!----></div>
A method declared with the modifier <b>property</b> may be used
in constraints.  A property method declared in a class must have
a body and must not be <b>void</b>.  The body of the method must
consist of only a single <b>return</b> statement or a single
expression.  It is a static error if the expression cannot be
represented in the constraint system. 

<div class="p"><!----></div>
The expression may contain invocations of other property methods. It is the
responsibility of the programmer to ensure that the evaluation of a property
terminates at compile-time, otherwise the type-checker will not terminate and
the program will fail to compile in a potentially most unfortunate way.

<div class="p"><!----></div>
Property methods in classes are implicitly <b>final</b>; they cannot be
overridden.

<div class="p"><!----></div>
A nullary property method definition may omit the formal parameters and
the <b>def</b> keyword.  That is, the following are equivalent:

<div class="p"><!----></div>
<pre>
property def rail(): Boolean = rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
</pre>
and
<pre>
property rail: Boolean = rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
</pre>

<div class="p"><!----></div>
Similarly, nullary property methods can be inspected in constraints without
<b>()</b>.  
<b>w.rail</b>, with either definition above, 
is equivalent to 
<b>w.rail()</b>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Method overloading, overriding, hiding, shadowing and obscuring</h3>
<a name="MethodOverload">
</a>


<div class="p"><!----></div>
The definitions of method overloading, overriding, hiding, shadowing
and obscuring in X10 are the same as in Java, modulo the following
considerations motivated by type parameters and dependent types.

<div class="p"><!----></div>
Two or more methods of a class or interface may have the same
name if they have a different number of type parameters, or
they have formal parameters of different types.  <em>E.g.</em>, the following is legal: 

<div class="p"><!----></div>
<pre>
class Mful{
   def m() = 1;
   def m[T]() = 2;
   def m(x:Int) = 3;
   def m[T](x:Int) = 4;
}
</pre>

<div class="p"><!----></div>
X10 v2.1 does not permit overloading based on constraints. That is, the
following is <em>not</em> legal, although either method definition individually
is legal:
<pre>
   def n(x:Int){x==1} = &#246;ne";
   def n(x:Int){x!=1} = "not";
</pre>

<div class="p"><!----></div>
The definition of a method declaration "m<sub>1</sub>" "having the same signature
as" a method declaration "m<sub>2</sub>" involves identity of types. 

<div class="p"><!----></div>
The <em>constraint erasure</em> of a type "T" is defined as follows.
The constraint erasure of  (a)&#227; class, interface or struct type "T" is 
"T"; (b)&#227; type "T{c}" is the constraint erasure of 
"T"; (b)&#227; type "T[S<sub>1</sub>,&#8230;,S<sub>n</sub>]" 
is "T'[S<sub>1</sub>',&#8230;,S<sub>n</sub>']" where each primed type is the erasure of 
the corresponding unprimed type.
 Two methods are said to have <em>the
  same signature</em> if (a) they have the same number of type parameters,
(b) they have the same number of formal (value) parameters, and (c)
for each formal parameter the constraint erasure of its types are equivalent. It is a
compile-time error for there to be two methods with the same name and
same signature in a class (either defined in that class or in a
superclass).

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
A class <b>C</b> may not have two declarations for a method named <b>m</b>-either
  defined at <b>C</b> or inherited:
<pre>
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: T<sub>1</sub>, ..., v<sub>n</sub>: T<sub>n</sub>){tc}: T {...}
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: S<sub>1</sub>, ..., v<sub>n</sub>: S<sub>n</sub>){sc}: S {...}
</pre>

if it is the case that the constraint erasures of the types "T<sub>1</sub>",
..., "T<sub>n</sub>" are
equivalent to the constraint erasures of the types "S<sub>1</sub>, ..., T<sub>n</sub>"
respectively.


<div class="p"><!----></div>
In addition, the guard of a overriding method must be 
no stronger than the guard of the overridden method.   This
ensures that any virtual call to the method
satisfies the guard of the callee.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
If a class <b>C</b> overrides a method of a class or interface
  <b>B</b>, the guard of the method in <b>B</b> must entail
  the guard of the method in <b>C</b>.


<div class="p"><!----></div>
A class <b>C</b> inherits from its direct superclass and superinterfaces all
their methods visible according to the access modifiers
of the superclass/superinterfaces that are not hidden or overridden. A method "M<sub>1</sub>" in a class
<b>C</b> overrides
a method  in a superclass <b>D</b> if
"M<sub>1</sub>" and "M<sub>2</sub>" have the same signature with constraints erased.
Methods are overriden on a signature-by-signature basis.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Static initialization</h2>
<a name="StaticInitialization">
</a>

The X10 runtime implements the following procedure to ensure
reliable initialization of the static state of classes.

<div class="p"><!----></div>
Execution commences with a single thread executing the
<em>initialization</em> phase of an X10 computation at place <b>0</b>. This
phase must complete successfully before the body of the <b>main</b> method is
executed.

<div class="p"><!----></div>
The initialization phase must be thought of as if it is implemented in
the following fashion: (The implementation may do something more
efficient as long as it is faithful to this semantics.)

<div class="p"><!----></div>
<pre>
Within the scope of a new finish
for every static field f of every class C 
   (with type T and initializer e):
async {
  val l = e; 
  ateach (Dist.makeUnique()) {
     assign l to the static f field of 
         the local C class object;
     mark the f field of the local C 
         class object as initialized;
  }
}
</pre>

<div class="p"><!----></div>
During this phase, any read of a static field <b>C.f</b> (where <b>f</b> is of type <b>T</b>)
is replaced by a call to the method <b>C.read_f():T</b> defined on class <b>C</b>
as follows

<div class="p"><!----></div>
<pre>
def read_f():T {
   await (initialized(C.f));
   return C.f;
}
</pre>

<div class="p"><!----></div>
If all these activities terminate normally, all static fields have values of
their declared types, 
and the <b>finish</b> terminates normally. If
any activity throws an exception, the <b>finish</b> throws an
exception. Since no user code is executing which can catch exceptions
thrown by the finish, such exceptions are printed on the console, and
computation aborts.

<div class="p"><!----></div>
If the activities deadlock, the implementation deadlocks.

<div class="p"><!----></div>
In all cases, the main method is executed only once all static fields
have been initialized correctly.

<div class="p"><!----></div>
Since static state is immutable and is replicated to all places via 
the initialization phase as described above, it can be accessed from
any place.

<div class="p"><!----></div>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;User-Defined Operators</h2>



<div class="p"><!----></div>
It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a <b>Poly</b> class of
polynomials - for the sake of illustration, single-variable polynomials with
<b>Int</b> coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: <b>+</b> to add, <b>*</b> to multiply,
<b>-</b> to subtract, and <b>p(x)</b> to compute the value of the polynomial at
argument <b>x</b>.  We would like to write code thus: 

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static def main(Array[String](1)):void {
     val X = new Poly([0,1]);
     val t &lt;: Poly = 7 * X + 6 * X * X * X; 
     val u &lt;: Poly = 3 + 5*X - 7*X*X;
     val v &lt;: Poly = t * u - 1;
     for( [i] in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Writing the same code with method calls, while possible, is far less elegant: 

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t &lt;: UglyPoly = X.mult(7).plus(X.mult(X).mult(X).mult(6));  
     val u &lt;: UglyPoly = const(3).plus(X.mult(5)).minus(X.mult(X).mult(7));
     val v &lt;: UglyPoly = t.mult(u).minus(1);
     for( [i] in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
</pre>

<div class="p"><!----></div>
The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as <b>1+X</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Binary Operators</h3>

<div class="p"><!----></div>
Defining the sum <b>P+Q</b> of two polynomials looks much like a method
definition.  It uses the <b>operator</b> keyword instead of <b>def</b>, and
<b>this</b> appears in the definition in the place that a <b>Poly</b> would
appear in a use of the operator.  So, 
<b>operator this + (p:Poly)</b> explains how to add <b>this</b> to a
<b>Poly</b> value.
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public def degree() = coeff.size()-1;
  public def  a(i:Int) = (i&lt;0 </td><td width="150">
&#124;</td><td width="150">
&#124; i&#62;this.degree()) ? 0 : coeff(i);

<div class="p"><!----></div>
  public operator this + (p:Poly) =  new Poly(
     new Array[Int](
        Math.max(this.coeff.size(), p.coeff.size()),
        (i:Int) =&#62; this.a(i) + p.a(i)
     )); 
  // ... 
</pre>

<div class="p"><!----></div>
The sum of a polynomial and an integer, <b>P+3</b>, looks like
an overloaded method definition.  
<pre>
   public operator this + (n : Int) = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
However, we want to allow the sum of an integer and a polynomial as well:
<b>3+P</b>.  It would be quite inconvenient to have to define this as a method
on <b>Int</b>; changing <b>Int</b> is far outside of normal coding.  So, we
allow it as a method on <b>Poly</b> as well.

<div class="p"><!----></div>
<pre>
   public operator (n : Int) + this = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
<b>Poly</b>s could have been written:
<pre>
  public static operator (p:Poly) + (q:Poly) =  new Poly(
     new Array[Int](
        Math.max(q.coeff.size(), p.coeff.size()),
        (i:Int) =&#62; q.a(i) + p.a(i)
     ));
</pre>

<div class="p"><!----></div>
This requires the following grammar: <br />
<em>  
<table>

<tr><td align="right">MethodDecl    ::= MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> BinOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>this</b> BinOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> BinOp <b>this</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>this</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams <b>=</b> <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> <b>as</b> Type WhereClause<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> <b>as</b> <b>?</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody</td></tr>
<tr><td align="right"></td></tr></table>
</em>
When X10 attempts to typecheck a binary operator expression like <b>P+Q</b>, it
first typechecks <b>P</b> and <b>Q</b>. Then, it looks for operator declarations
for <b>+</b> in the types of <b>P</b> and <b>Q</b>. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a <em>best-matching</em> operation, <em>viz</em> one which does
not require the operands to be converted to another type. For example,
<b>operator this + (n:Long)</b> and <b>operator this + (n:Int)</b> both apply to
<b>p+1</b>, because <b>1</b> can be converted from an <b>Int</b> to a <b>Long</b>.
However, the <b>Int</b> version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.

<div class="p"><!----></div>
The main difference between expressing a binary operation as an instance
method (with a <b>this</b> in the definition) and a static one (no <b>this</b>)
is that instance methods don't apply any conversions, while static methods
attempt to convert both arguments. 


<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Unary Operators</h3>

<div class="p"><!----></div>
Unary operators are defined in a similar way, with <b>this</b> appearing in the
<b>operator</b> definition where an actual value would occur in a unary
expression.  The operator to negate a polynomial is: 

<div class="p"><!----></div>
<pre>
  public operator - this = new Poly(
    new Array[Int](coeff.size(), (i:Int) =&#62; -coeff(i))
    );
</pre>

<div class="p"><!----></div>
The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Type Conversions</h3>


<div class="p"><!----></div>
Explicit type conversions, <b>e as T{c}</b>, can be defined as operators on
class <b>T</b>.

<div class="p"><!----></div>
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public static operator (a:Int) as Poly = new Poly([a]);
  public static def main(Array[String](1)):void {
     val three : Poly = 3 as Poly;
  }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;Implicit Type Coercions</h3>


<div class="p"><!----></div>
You may also define <em>implicit</em> type coercions to <b>T{c}</b> as static
operators in class <b>T</b>.  The syntax for this is
<b>static operator (x:U) : T{c} = e</b>.
Implicit coercions are used automatically by the compiler.  


<div class="p"><!----></div>
For example, we can define an implicit coercion from <b>Int</b> to <b>Poly</b>,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define <b>+</b> on
two polynomials (using a <b>static</b> operator, so that implicit coercions
will be used - they would not be for an instance method operator).  The
calculation <b>1+x</b> coerces <b>1</b> to a polynomial and uses polynomial
addition to add it to <b>x</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static operator (c : Int) : Poly = new Poly([c]);

<div class="p"><!----></div>
  public static operator (p:Poly) + (q:Poly) = new Poly(
      new Array[Int](
        Math.max(p.coeff.size(), q.coeff.size()),
        (i:Int) =&#62; p.a(i) + q.a(i)
     ));

<div class="p"><!----></div>
  public static def main(Array[String](1)):void {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;<b>set</b> and <b>apply</b></h3>




<a name="set-and-apply">
</a>
X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The <b>Array</b>-like classes take advantage
of both of these in <b>a(i) = a(i) + 1</b>.  Unlike unary and binary operators,
subscripting and indexed assignment are done by methods, <b>apply</b> and
<b>set</b> respectively.

<div class="p"><!----></div>
<b>a(b,c,d)</b> is short for the method call <b>a.apply(b,c,d)</b>.  Since it is
possible to overload methods, the application syntax can be overloaded.  For
example, an ordered dictionary structure could allow subscripting by numbers
with <b>def apply(i:Int)</b>, and by string-valued keys with 
<b>def apply(s:String)</b>.  

<div class="p"><!----></div>
<b>a(i)=b</b> is short for the method call <b>a.set(b,i)</b>, with one or more
indices <b>i</b>. (This has a
possibly surprising consequence for the order of evaluation: in <b>a(i)=b</b>,
as in <b>a.set(b,i)</b>, <b>a</b> is evaluated first, then <b>b</b>, and finally
<b>i</b>.)  Again, it is possible to overload <b>set</b> to provide a variety of
subscripting operations.  Each <b>set</b> method must have a corresponding
<b>apply</b> method; that is, <b>a(i,j)=b</b> is only defined when <b>a(i,j)</b>
is defined, despite the fact that <b>a(i,j)=b</b> does not evaluate <b>a(i,j)</b>.

<div class="p"><!----></div>
The <b>Oddvec</b> class of somewhat peculiar vectors illustrates this.
<b>a()</b> returns a string representation of the oddvec, which probably should
be done by <b>toString()</b> instead.  <b>a(i)</b> picks out one of the three
coordinates of <b>a</b>, which is sensible.  <b>a(i)=b</b> assigns to one of the
coordinates.  <b>a(i,j)=b</b> assigns different values to <b>a(i)</b> and
<b>a(j)</b>, purely for the sake of the example.

<div class="p"><!----></div>
<pre>
class Oddvec {
  var v : Array[Int](1) = new Array[Int](3, (Int)=&#62;0);
  public def apply() = "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public def apply(i:Int) = v(i);
  public def apply(i:Int, j:Int) = [v(i),v(j)];
  public def set(newval:Int, i:Int) = {v(i) = newval;}
  public def set(newval:Int, i:Int, j:Int) = {
       v(i) = newval; v(j) = newval+1;} 
  // ... 
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Class Guards and Invariants</h2><a name="DepType:ClassGuard">
</a>






<div class="p"><!----></div>
Classes (and structs and interfaces) may specify a <em>class guard</em>, a
constraint which must hold on all values of the class.    In the following
example, a <b>Line</b> is defined by two distinct <b>Pt</b>s<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>
<pre>
class Pt(x:Int, y:Int){}
class Line(a:Pt, b:Pt){a != b} {}
</pre>

<div class="p"><!----></div>
In most cases the class guard could be phrased as a type constraint on a property of
the class instead, if preferred.  Arguably, a symmetric constraint like two
points being different is better expressed as a class guard, rather than
asymmetrically as a constraint on one type: 
<pre>
class Line(a:Pt, b:Pt{a != b}) {}
</pre>

<div class="p"><!----></div>
<a name="DepType:TypeInvariant">
</a><a name="DepType:ClassGuardDef">
</a>With every defined class, struct,  or interface <b>T</b> we associate a <em>type
invariant</em> <i>inv</i>(<b>T</b>), which describes the guarantees on the
properties of values of type <b>T</b>.  

<div class="p"><!----></div>
Every value of <b>T</b> satisfies <i>inv</i>(<b>T</b>) at all times.  This
is somewhat stronger than the concept of type invariant in most languages
(which only requires that the invariant holds when no method calls are
active).  X10 invariants only concern properties, which are immutable; thus,
once established, they cannot be falsified.

<div class="p"><!----></div>
The type
invariant associated with <b>x10.lang.Any</b>
is 
<b>true</b>.

<div class="p"><!----></div>
The type invariant associated with any interface or struct <b>I</b> that extends
interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>" and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is given by:

<div class="p"><!----></div>
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) 
    &amp;&amp; self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
    &amp;&amp; c  
</pre>

<div class="p"><!----></div>
Similarly the type invariant associated with any class <b>C</b> that
implements interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>",
extends class <b>D</b> and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is
given by the same thing with the invariant of the superclass <b>D</b> conjoined:
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) 
    &amp;&amp; self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
    &amp;&amp; c  
    &amp;&amp; {inv}(D)
</pre>

<div class="p"><!----></div>
Note that the type invariant associated with a class entails the type
invariants of each interface that it implements (directly or indirectly), and
the type invariant of each ancestor class.
It is guaranteed that for any variable <b>v</b> of
type <b>T{c}</b> (where <b>T</b> is an interface name or a class name) the only
objects <b>o</b> that may be stored in <b>v</b> are such that <b>o</b> satisfies
<i>inv</i>(T[o/this])&#8743;c[o/self].

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Invariants for <b>implements</b> and <b>extends</b> clauses</h3><a name="DepType:Implements">
</a>
<a name="DepType:Extends">
</a>




Consider a class definition
<pre>
ClassModifiers<sup>?</sup>
class C(x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>) extends D{d}
   implements I<sub>1</sub>{c<sub>1</sub>}, ..., I<sub>k</sub>{c<sub>k</sub>}
ClassBody
</pre>

<div class="p"><!----></div>
Each of the following static semantics rules must be satisfied:

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Int-implements):
The type invariant  of <b>C</b> must entail
"c<sub>i</sub>[this/self]" for each i in {{1, ..., k}}


<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Super-extends):
The return type <b>c</b> of each constructor in a class <b>C</b>
must entail the invariant "<i>inv</i>(C)".


<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Invariants and constructor definitions</h3>



<div class="p"><!----></div>
A constructor for a class <b>C</b> is guaranteed to return an object of the
class on successful termination. This object must satisfy  "<i>inv</i>(C)", the
class invariant associated with <b>C</b> (&#167;<a href="#DepType:TypeInvariant">7</a>).
However,
often the objects returned by a constructor may satisfy <em>stronger</em>
properties than the class invariant. X10's dependent type system
permits these extra properties to be asserted with the constructor in
the form of a constrained type (the "return type" of the constructor):

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">CtorDecl    ::= Mods<sup>?</sup>&nbsp;<b>def</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;CtorBody </td></tr>
<tr><td align="right">
</td></tr></table>
</em>

<div class="p"><!----></div>
<a name="ConstructorGuard">
</a>The parameter list for the constructor
may specify a <em>guard</em> that is to be satisfied by the parameters
to the list.

<div class="p"><!----></div>
Here is another example, constructed as a simplified 
version of <b>x10.lang.Region</b>.  The <b>mockUnion</b> method 
has the type that a true <b>union</b> method would have.

<div class="p"><!----></div>
<pre>
class MyRegion(rank:Int) {
  static type MyRegion(n:Int)=MyRegion{rank==n};
  def this(r:Int):MyRegion(r) {
    property(r);
  }
  def this(diag:Array[Int](1)):MyRegion(diag.size){ 
    property(diag.size);
  }
  def mockUnion(r:MyRegion(rank)):MyRegion(rank) = this;
  def example() {
    val R1 : MyRegion(3) = new MyRegion([4,4,4]); 
    val R2 : MyRegion(3) = new MyRegion([5,4,1]); 
    val R3 = R1.mockUnion(R2); // inferred type MyRegion(3)
  }
}
</pre>
The first constructor returns the empty region of rank <b>r</b>.  The
second constructor takes a <b>Array[Int](1)</b> of arbitrary length
<b>n</b> and returns a <b>MyRegion(n)</b> (intended to represent the set
of points in the rectangular parallelopiped between the origin and the
<b>diag</b>.)

<div class="p"><!----></div>
The code in <b>example</b> typechecks, and <b>R3</b>'s type is inferred as
<b>MyRegion(3)</b>.  

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Super-invoke):
   Let <b>C</b> be a class with properties
   , invariant <b>c</b>
   extending the constrained type <b>D{d}</b> (where <b>D</b> is the name of a class).

<div class="p"><!----></div>
   For every constructor in <b>C</b> the compiler checks that the call to
   super invokes a constructor for <b>D</b> whose return type is strong enough
   to entail <b>d</b>. Specifically, if the call to super is of the form 
     &#223;uper(e<sub>1</sub>, ..., e<sub>k</sub>)"
   and the static type of each expression &#235;<sub>i</sub>" is
   "S<sub>i</sub>", and the invocation
   is statically resolved to a constructor
"def this(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>k</sub>: T<sub>k</sub>){c}: D{d<sub>1</sub>}"
   then it must be the case that 
<pre>
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>i</sub>: S<sub>i</sub> &#124;&mdash; x<sub>i</sub>: T<sub>i</sub>  (for i  &#8712; {1, ..., k})
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> &#124;&mdash; c  
d<sub>1</sub>[a/self], x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> &#124;&mdash; d[a/self]      
</pre>
 where <b>a</b> is a constant that does not appear in 
"x<sub>1</sub>: S<sub>1</sub> &#8743; ... &#8743; x<sub>k</sub>: S<sub>k</sub>".


<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Constructor return):
   The compiler checks that every constructor for <b>C</b> ensures that
   the properties "p<sub>1</sub>,..., p<sub>n</sub>" are initialized with values which satisfy
   , and its own return type <b>c'</b> as follows.  In each constructor, the
   compiler checks that the static types "T<sub>i</sub>" of the expressions &#235;<sub>i</sub>"
   assigned to "p<sub>i</sub>" are such that the following is
   true:
<pre>
p<sub>1</sub>: T<sub>1</sub>, ..., p<sub>n</sub>: T<sub>n</sub> &#124;&mdash; t(C) &#8743; c'     
</pre>

(Note that for the assignment of &#235;<sub>i</sub>" to "p<sub>i</sub>"
to be type-correct it must be the
    case that "p<sub>i</sub>: T<sub>i</sub> &#8743; p<sub>i</sub>: P<sub>i</sub>".) 

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Constructor invocation):
The compiler must check that every invocation "C(e<sub>1</sub>, ..., e<sub>n</sub>)" to a
constructor is type correct: each argument &#235;<sub>i</sub>" must have a static type
that is a subtype of the declared type "T<sub>i</sub>" for the ith
argument of the
constructor, and the conjunction of static types of the argument must
entail the constraint in the parameter list of the constructor.


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
    




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Object Initialization</h3>





<div class="p"><!----></div>
X10 does object initialization safely.  It avoids a few classes of bad things: 

<ol type="1">
<li> Use of a field before the field has been initialized.
<div class="p"><!----></div>
</li>

<li> <b>this</b> escaping from a constructor;
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
It should be unsurprising that fields must not be used before they are
initialized. At best, it is uncertain what value will be in them, as in
<b>x</b> below. Worse, the value might not even be an allowable value; <b>y</b>,
declared to be nonzero in the following example, might be zero before it is
initialized. 
<pre>
// Not correct X10
class ThisIsWrong {
  val x : Int;
  val y : Int{y != 0};
  def this() {
    x10.io.Console.OUT.println("x=" + x + "; y=" + y);
    x = 1; y = 2;
  }
}
</pre>

<div class="p"><!----></div>
One particularly insidious way to read uninitialized fields is to allow
<b>this</b> to escape from a constructor. For example, the constructor could
put <b>this</b> into a data structure before initializing it, and another
activity could read it from the data structure and look at its fields: 
<pre>
class Wrong {
  val shouldBe8 : Int;
  static Cell[Wrong] wrongCell = new Cell[Wrong]();
  static def doItWrong() {
     finish { 
       async { new Wrong(); } // (A)
       assert( wrongCell().shouldBe8 == 8); // (B)
     }
  }
  def this() {
     wrongCell.set(this); // (C) - ILLEGAL 
     this.shouldBe8 = 8; // (D)
  }
}
</pre>

In this example, the underconstructed <b>Wrong</b> object is leaked into a
storage cell at line <b>(C)</b>, and then initialized.  The <b>doItWrong</b>
method constructs a new <b>Wrong</b> object, and looks at the <b>Wrong</b>
object in the storage cell to check on its <b>shouldBe8</b> field.  One
possible order of events is the following: 

<ol type="1">
<li> <b>doItWrong()</b> is called.
<div class="p"><!----></div>
</li>

<li> <b>(A)</b> is started.  Space for a new <b>Wrong</b> object is allocated.
      Its <b>shouldBe8</b> field, not yet initialized, contains some garbage
      value.
<div class="p"><!----></div>
</li>

<li> <b>(C)</b> is executed, as part of the process of constructing a new
      <b>Wrong</b> object.  The new, uninitialized object is stored in
      <b>wrongCell</b>.
<div class="p"><!----></div>
</li>

<li> Now, the initialization activity is paused, and execution of the main activity 
      proceeds from <b>(B)</b>.
<div class="p"><!----></div>
</li>

<li> The value in <b>wrongCell</b> is retrieved, and is <b>shouldBe8</b> field
      is read.  This field contains garbage, and the assertion fails.
<div class="p"><!----></div>
</li>

<li> Now let the initialization activity proceed with <b>(D)</b>,
      initializing <b>shouldBe8</b> - too late.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
X10 must protect against such possibilities.  The rules explaining how
constructors can be written are somewhat intricate; they are designed to allow
as much programming as possible without leading to potential problems.
Ultimately, they simply are elaborations of the fundamental principles that
uninitialized fields must never be read, and <b>this</b> must never be leaked.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Constructors and NonEscaping Methods</h3>

<div class="p"><!----></div>
In general, constructors must not be allowed to call methods with<b>this</b> as
an argument or receiver. Such calls could leak references to <b>this</b>,
either directly from a call to <b>cell.set(this)</b>, or indirectly because
<b>toString</b> leaks <b>this</b>, and the concatenation 
`&#203;scaper = "+this` calls <b>toString</b>.<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>
<pre>
class Escaper {
  static val Cell[Escaper] cell = new Cell[Escaper]();
  def toString() {
    cell.set(this);
    return &#203;vil!";
  }
  def this() {
    cell.set(this);
    x10.io.Console.OUT.println(&#203;scaper = " + this);
  }
}
</pre>

<div class="p"><!----></div>
However, it is convenient to be able to call methods from constructors; <em>
e.g.</em>, a class might have eleven constructors whose common behavior is best
described by three methods.  
Under certain stringent conditions, it <em>is</em>
safe to call a method: the method called must not leak references to
<b>this</b>, and must not read <b>val</b>s or <b>var</b>s which might not have
been assigned.   

<div class="p"><!----></div>
So, X10 performs a static dataflow analysis, sufficient to guarantee that
method calls in constructors are safe.  This analysis requires having access
to or guarantees about all the code that could possibly be called.  This can
be accomplished in two ways: 

<ol type="1">
<li> Ensuring that only code from the class itself can be called, by 
      forbidding overriding of
      methods called from the constructor: they can be marked <b>final</b> or
      <b>private</b>, or the whole class can be <b>final</b>.
<div class="p"><!----></div>
</li>

<li> Marking the methods called from the constructor by
      <b>@NonEscaping</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.4.1">
7.4.1</a>&nbsp;&nbsp;Non-Escaping Methods</h4>








<div class="p"><!----></div>
A method may be annotated with <b>@NonEscaping</b>.  This
imposes several restrictions on the method body, and on all methods overriding
it.  However, it is the only way that a method can be called from
constructors.  The
<b>@NonEscaping</b> annotation makes explicit all the X10 compiler's needs for
constructor-safety.  

<div class="p"><!----></div>
A method can, however, be safe to call from constructors without being marked
<b>@NonEscaping</b>. We call such methods <em>implicitly non-escaping</em>.
Implicitly non-escaping methods need to obey the same constraints on
<b>this</b>, <b>super</b>, and variable usage as <b>@NonEscaping</b> methods. An
implicitly non-escaping method <em>could</em> be marked as
<b>@NonEscaping</b> for some list of variables; the compiler, in
effect, infers the annotation. In addition, implicitly non-escaping methods
must be <b>private</b> or <b>final</b> or members of a <b>final</b> class; this
corresponds to the hereditary nature of <b>@NonEscaping</b> (by forbidding
inheritance of implicitly non-escaping methods).

<div class="p"><!----></div>
We say that a method is <em>non-escaping</em> if it is either implicitly
non-escaping, or annotated <b>@NonEscaping</b>.

<div class="p"><!----></div>
The first requirement on non-escaping methods is that they do not allow
<b>this</b> to escape. Inside of their bodies, <b>this</b> and <b>super</b> may
only be used for field access and assignment, and as the receiver of
non-escaping methods.

<div class="p"><!----></div>
Finally, if a method <b>m</b> in class <b>C</b> is marked
<b>@NonEscaping</b>, then every method which overrides <b>m</b> in any
subclass of <b>C</b> must be annotated with precisely the same annotation,
<b>@NonEscaping</b>, as well.  

<div class="p"><!----></div>
The following example uses most of the possible variations (leaving out
<b>final</b> class).  <b>aplomb()</b> explicitly forbids reading any field but
<b>a</b>. <b>boric()</b> is called after <b>a</b> and <b>b</b> are set, but
{c} is not. 
The <b>@NonEscaping</b> annotation on <b>boric()</b> is optional, but the
compiler will print a warning if it is left out.
<b>cajoled()</b> is only called after all fields are set, so it
can read anything; its annotation, too, is not required.   <b>SeeAlso</b> is able to override <b>aplomb()</b>, because
<b>aplomb()</b> is <b>@NonEscaping(&#228;")</b>; it cannot override the final method
<b>boric()</b> or the private one <b>cajoled()</b>.  Even for overriding
<b>aplomb()</b>, it is crucial that <b>SeeAlso.aplomb()</b> be 
declared <b>@NonEscaping(&#228;")</b>, just like <b>C2.aplomb()</b>.
<pre>
import x10.compiler.*;

<div class="p"><!----></div>
final class C2 {
  protected val a:Int, b:Int, c:Int;
  protected var x:Int, y:Int, z:Int;
  def this() {
    a = 1;
    this.aplomb();
    b = 2;
    this.boric();
    c = 3;
    this.cajoled();
  }
  @NonEscaping def aplomb() {
    x = a;
    // this.boric(); // not allowed; boric reads b.
    // z = b; // not allowed - only 'a' can be read here
  }
  @NonEscaping final def boric() {
    y = b;
    this.aplomb(); // allowed; a is definitely set before boric is called
    // z = c; // not allowed; c is not definitely written 
  }
  @NonEscaping private def cajoled() {
    z = c;
  }  
}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;Fine Structure of Constructors</h3>
<a name="SFineStructCtors">
</a>

<div class="p"><!----></div>
The code of a constructor consists of four segments, three of them optional
and one of them implicit.

<ol type="1">
<li> The first segment is an optional call to <b>this(...)</b> or
      <b>super(...)</b>.  If this is supplied, it must be the first statement
      of the constructor.  If it is not supplied, the compiler treats it as a
      nullary super-call <b>super()</b>;
<div class="p"><!----></div>
</li>

<li> If the class or struct has properties, there must be a single
      <b>property(...)</b> command in the constructor.  Every execution path
      through the constructor must go through this <b>property(...)</b> command
      precisely once.   The second segment of the constructor is the code
      following the first segment, up to and including the <b>property()</b>
      statement.  

<div class="p"><!----></div>
      If the class or struct has no properties, the <b>property()</b> call must
      be omitted. If it is present, the second segment is defined as before.  If
      it is absent, the second segment is empty.
<div class="p"><!----></div>
</li>

<li> The third segment is automatically generated.  Fields with initializers
      are initialized immediately after the <b>property</b> statement.  
      In the following example, <b>b</b> is initialized to <b>y*9000</b> in
      segment three.  The initialization makes sense and does the right
      thing; <b>b</b> will be <b>y*9000</b> for every <b>Overdone</b> object. 
      (This would not be possible if field initializers were processed
      earlier, before properties were set.)
<div class="p"><!----></div>
</li>

<li> The fourth segment is the remainder of the constructor body.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The segments in the following code are shown in the comments.
<pre>
class Overlord(x:Int) {
  def this(x:Int) { property(x); }
}//Overlord
class Overdone(y:Int) extends Overlord  {
  val a : Int;
  val b =  y * 9000;
  def this(r:Int) {
    super(r);                      // (1)
    x10.io.Console.OUT.println(r); // (2)
    property(r+1);                 // (2)
    // field initializations here  // (3)
    a = r + 2;                     // (4)
  }
}//Overdone
</pre>

<div class="p"><!----></div>
The rules of what is allowed in the three segments are different, though
unsurprising.  For example, properties of the current class can only be read
in segment 3 or 4-naturally, because they are set at the end of segment 2.  

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.5.1">
7.5.1</a>&nbsp;&nbsp;Initialization and Inner Classses</h4>


<div class="p"><!----></div>
Constructors of inner classes are tantamount to method calls on <b>this</b>.  
For example, the constructor for Inner <b>is</b> acceptable.  It does not leak
<b>this</b>.  It leaks <b>Outer.this</b>, which is an utterly different object.  
So, the call to <b>this.new Inner()</b> in the <b>Outer</b> constructor <em>
is</em> illegal.  It would leak <b>this</b>.  There is no special rule in effect
preventing this; a constructor call of an inner class is no 
different from a method as far as leaking is concerned.
<pre>
class Outer {
  static val leak : Cell[Outer] = new Cell[Outer](null);
  class Inner {
     def this() {Outer.leak.set(Outer.this);}
  }
  def /*Outer*/this() {
     //ILLEGAL: val inner = this.new Inner(); 
  }
}
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.5.2">
7.5.2</a>&nbsp;&nbsp;Initialization and Closures</h4>


<div class="p"><!----></div>
Closures in constructors are valid if they were invoked (or inlined) at the
place of creation. For example, <b>closure</b> below is acceptable because it
only refers to fields defined at the point it was written.  <b>badClosure</b>
would not be acceptable, because it refers to fields that were not defined at
that point, although they were defined later.
<pre>
class C {
  val a = 3;
  val closure = () =&#62; a*10; // This is OK
  //val badClosure = () =&#62; b*10; 
  val b = 4;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.6">
7.6</a>&nbsp;&nbsp;Definite Initialization in Constructors</h3>

<div class="p"><!----></div>
An instance field <b>var x:T</b>, when <b>T</b> has a default value, need not be
explicitly initialized.  In this case, <b>x</b> will be initialized to the
default value of type <b>T</b>.  For example, a <b>Score</b> object will have
its <b>currently</b> field initialized to zero, below:
<pre>
class Score {
  public var currently : Int;
}
</pre>

<div class="p"><!----></div>
All other sorts of instance fields do need to be initialized before they can
be used.  <b>val</b> fields must be initialized, even if their type has a
default value.  It would be silly to have a field <b>val z : Int</b> that was
always given default value of <b>0</b> and, since it is <b>val</b>, can never be
changed.  <b>var</b> fields whose type has no default value must be initialized
as well, such as <b>var y : Int{y != 0}</b>, since it cannot be assigned a
sensible initial value. 

<div class="p"><!----></div>
The fundamental principles are: 

<ol type="1">
<li> <b>val</b> fields must be assigned precisely once in each constructor on every
possible execution path.
<div class="p"><!----></div>
</li>

<li> <b>var</b> fields of defaultless type must be
assigned at least once on every possible execution path, but may be assigned
more than once.
<div class="p"><!----></div>
</li>

<li> No variable may be read before it is guaranteed to have been
assigned.
<div class="p"><!----></div>
</li>

<li> Initialization may be by field initialization expressions (<b>val x :
      Int = y+z</b>), or by uninitialized fields <b>val x : Int;</b> plus
an initializing assignment <b>x = y+z</b>.  Recall that field initialization
expressions are performed after the <b>property</b> statement, in segment 3 in
the terminology of &#167;<a href="#SFineStructCtors">7.5</a>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.7">
7.7</a>&nbsp;&nbsp;Summary of Restrictions on Classes and Constructors</h3>

<div class="p"><!----></div>
The following table tells whether a given feature is (yes), is not (no) or is
with some conditions (note) allowed in a given context.   For example, a
property method is allowed with the type of another property, as long as it
only mentions the preceding properties. The first column of the table gives
examples, by line of the following code body.

<div class="p"><!----></div>

<table border=1>
<tr><td align="left">&nbsp;</td>
  <td><b>Example</b></td>
  <td><b>Prop.</b></td>
  <td><b><tt><font size="-1">self==this</font></tt>(1)</b></td>
  <td><b>Prop.Meth.</b></td>
  <td><b><tt>this</tt></b></td>
  <td><b>fields</b></td>
</td></tr>
<tr><td align="left">Type of property</td> 
  <td>(A)</td> 
  
  <td>yes (2)</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Class Invariant</td>
  <td>(B)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Supertype (3)</td>
  <td>(C), (D)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Property Method Body</td>
  <td>(E)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Static field (4)</td>
  <td>(F) (G)</td> 
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Instance field (5)</td>
  <td>(H), (I)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">Constructor arg. type</td>
  <td>(J)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor guard</td>
  <td>(K)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor ret. type</td>
  <td>(L)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 1</td> 
  <td>(M)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 2</td>
  <td>(N)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 4</td>
  <td>(O)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">Methods</td>
  <td>(P)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<!--
<tr><td align="left">place</td>
  <td>(pos)</td> 
  
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
</td></tr>
-->
</table>


<div class="p"><!----></div>
Details:

<div class="p"><!----></div>

<ul>
<li> (1) Top-level <tt>self</tt> only.
<div class="p"><!----></div>
</li>

<li> (2) The type of the i<sup>th</sup> property may only mention
                 properties 1 through i.
<div class="p"><!----></div>
</li>

<li> (3) Super-interfaces follow the same rules as supertypes.
<div class="p"><!----></div>
</li>

<li> (4) The same rules apply to types and initializers.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The example indices refer to the following code: 
<pre>
class Example (
   prop : Int,
   proq : Int{prop != proq},                    // (A)
   pror : Int
   )
   {prop != 0}                                  // (B)
   extends Supertype[Int{self != prop}]         // (C)
   implements SuperInterface[Int{self != prop}] // (D)
{
   property def propmeth() = (prop == pror);    // (E)
   static staticField 
      : Cell[Int{self != 0}]                    // (F)
      = new Cell[Int{self != 0}](1);            // (G)
   var instanceField                            
      : Int {self != prop}                      // (H)
      = (prop + 1) as Int{self != prop};        // (I)
   def this(
      a : Int{a != 0},
      b : Int{b != a}                           // (J)
      )
      {a != b}                                  // (K)
      : Example{self.prop == a &amp;&amp; self.proq==b} // (L)
   {
      super();                                  // (M)
      property(a,b,a);                          // (N)
      // fields initialized here
      instanceField = b as Int{self != prop};   // (O)
   }

<div class="p"><!----></div>
   def someMethod() = 
        prop + staticField + instanceField;     // (P)
}
</pre>


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
    




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Method Resolution</h2>


<a name="sect:MethodResolution">
</a>

<div class="p"><!----></div>
Method resolution is the problem of determining, statically, which method (or
constructor or operator)
should be invoked, when there are several choices that could be invoked.  For
example, the following class has two overloaded <b>zap</b> methods, one taking
an <b>Object</b>, and the other a <b>Resolve</b>.  Method resolution will figure
out that the call <b>zap(1..4)</b> should call <b>zap(Object)</b>, and
<b>zap(new Resolve())</b> should call <b>zap(Resolve)</b>.  

<div class="p"><!----></div>
<pre>
class Resolve {
  static def zap(Object) = &#214;bject";
  static def zap(Resolve) = "Resolve";
  public static def main(argv:Array[String](1)) {
    Console.OUT.println(zap(1..4));
    Console.OUT.println(zap(new Resolve()));
  }
}
</pre>

<div class="p"><!----></div>
The basic concept of method resolution is quite straightforward: 

<ol type="1">
<li> List all the methods that could possibly be used;
<div class="p"><!----></div>
</li>

<li> Pick the most specific one;
<div class="p"><!----></div>
</li>

<li> Fail if there is not a unique most specific one.
<div class="p"><!----></div>
</li>
</ol>

In the presence of X10's highly-detailed type system, some subtleties arise. 
One point, at least, is <em>not</em> subtle. The same procedure is used, <em>
mutatis mutandis</em> for method, constructor, and operator resolution.  

<div class="p"><!----></div>
Generics introduce several subtleties, especially with the inference of
generic types. 

<div class="p"><!----></div>
For the purposes of method resolution, all that matters about a method,
constructor, or operator <b>M</b> - we use the word method" to include all
three choices for this section - is its signature, plus which method it is.
So, a typical <b>M</b> might look like 
"def m[G<sub>1</sub>,&#8230;, G<sub>g</sub>](x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>){c} =...".  The code body <b>...</b> is irrelevant for the purpose of whether a
given method call means <b>M</b> or not, so we ignore it for this section.

<div class="p"><!----></div>

<ol type="1">
<li> The method name <b>m</b>;
<div class="p"><!----></div>
</li>

<li> The generic type parameters of the method <b>M</b>,  "G<sub>1</sub>,&#8230;, G<sub>g</sub>".  If there
      are no generic type parameters, g=0.
<div class="p"><!----></div>
</li>

<li> The types "x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>" of the formal parameters.  If
      there are no formal parameters, f=0. In the case of an instance
      method, the receiver will be the first formal parameter.<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>
<div class="p"><!----></div>
</li>

<li> The constraint <b>c</b> of the method <b>M</b>. If no constraint is specified, <b>c</b> is
      <b>true</b>.
<div class="p"><!----></div>
</li>

<li> A <em>unique identifier</em> <b>id</b>, sufficient to tell the compiler
      which method body is intended.  A file name and position in that file
      would suffice.  The details of the identifier are not relevant.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
For the purposes of understanding method resolution, we assume that all the
actual parameters of an invocation are simply variables: <b>x1.meth(x2,x3)</b>.
This is done routinely by the compiler in any case; the code 
<b>tbl(i).meth(true, a+1)</b> would be treated roughly as 
<pre>
val x1 = tbl(i);
val x2 = true;
val x3 = a+1;
x1.meth(x2,x3);
</pre>

<div class="p"><!----></div>
All that matters about an invocation <b>I</b> is: 

<ol type="1">
<li> The method name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> The generic type parameters "G&#8242;<sub>1</sub>,&#8230;, G&#8242;<sub>g</sub>".  If there
      are no generic type parameters, x=0.
<div class="p"><!----></div>
</li>

<li> The names and types "x<sub>1</sub>:T&#8242;<sub>1</sub>,&#8230;, x<sub>f</sub>:T&#8242;<sub>f</sub>" of the actual parameters.  If
      there are no actual parameters, f=0. In the case of an instance
      method, the receiver is the first actual parameter.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The signature of the method resolution procedure is: 
<b>resolve(invo : Invocation, context: Set[Method]) : MethodID</b>.  
Given a particular invocation and the set <b>context</b> of all methods
which could be called at that point of code, method resolution either returns
the unique identifier of the method that should be called, or (conceptually)
throws an exception if the call cannot be resolved.

<div class="p"><!----></div>
The procedure for computing <b>resolve(invo, context)</b> is: 

<ol type="1">
<li> Eliminate from <b>context</b> those methods which are not <em>
      acceptable</em>; <em>viz</em>, those whose name, type parameters, formal parameters,
      and constraint do not suitably match <b>invo</b>.  In more detail:
      
<ul>
<li> The method name <b>m</b> must simply equal the invocation name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> X10 infers type parameters, by an algorithm given in &#167;.
<div class="p"><!----></div>
</li>

<li> The method's type parameters are bound to the invocation's for the
            remainder of the acceptability test.
<div class="p"><!----></div>
</li>

<li> The actual parameter types must be subtypes of the formal
            parameter types:  "T&#8242;<sub>i</sub> &lt;: Ti<sub>i</sub>" for each <em>i</em>.
<div class="p"><!----></div>
</li>

<li> The formal constraint <b>c</b> must be satisfied in the invoking
            context.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Eliminate from <b>context</b> those methods which are not <em>
      available</em>; <em>viz</em>, those which cannot be called due to visibility
      constraints, such as methods from other classes marked <b>private</b>.
      The remaining methods are both acceptable and available; they might be
      the one that is intended.
<div class="p"><!----></div>
</li>

<li> From the remaining methods, find the unique <b>ms</b> which is more specific than all the
      others, <em>viz</em>, for which <b>specific(ms,mo) = true</b> for all other
      methods <b>mo</b>.
      The specificity test <b>specific</b> is given next.
      
<ul>
<li> If there is a unique such <b>ms</b>, then
            <b>resolve(invo,context)</b> returns the <b>id</b> of <b>ms</b>.
<div class="p"><!----></div>
</li>

<li> If there is not a unique such <b>ms</b>, then <b>resolve</b> reports
            an error.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The subsidiary procedure <b>specific(m1, m2)</b> determines whether method
<b>m1</b> is equally or more specific than <b>m2</b>.  <b>specific</b> is not a
total order: is is possible for each one to be considered more specific than
the other, or either to be more specific.  <b>specific</b> is computed as: 

<ol type="1">
<li> Construct an invocation <b>invo1</b> based on <b>m1</b>: 
      
<ul>
<li> <b>invo1</b>'s method name is <b>m1</b>'s method name;
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s generic parameters are those of <b>m1</b>- simply
            some type variables.
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s parameters are those of <b>m1</b>.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> If <b>m2</b> is acceptable for the invocation <b>invo1</b>,
      <b>specific(m1,m2)</b> returns true; otherwise, it returns false.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
    




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Static Nested Classes</h2>
<a name="StaticNestedClasses">
</a>




<div class="p"><!----></div>
One class (or struct or interface) may be nested within another.  The simplest
way to do this is as a <b>static</b> nested class. 
For most purposes, a static nested class behaves like a top-level class.
However, a static inner class has access to private static
fields and methods of its containing class.  

<div class="p"><!----></div>
Nested interfaces and static structs are permitted as well.

<div class="p"><!----></div>
<pre>
class Outer {
  private static val priv = 1;
  private static def special(n:Int) = n*n;
  public static class StaticNested {
     static def reveal(n:Int) = special(n) + priv;
  }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Inner Classes</h2>
<a name="InnerClasses">
</a>



<div class="p"><!----></div>
Non-static nested classes are called <em>inner classes</em>. An inner class
instance can be thought of as a very elaborate member of an object - one
with a full class structure of its own.   The crucial characteristic of an
inner class instance is that it has an implicit reference to an instance of
its containing class.  

<div class="p"><!----></div>
This feature is particularly useful when an instance of the inner class makes
no sense without reference to an instance of the outer, and is closely tied to
it.  For example, consider a range class, describing a span of integers m
to n, and an iterator over the range.  The iterator might as well have
access to the range object, and there is little point to discussing
iterators-over-ranges without discussing ranges as well.
In the following example, the inner class <b>RangeIter</b> iterates over the
enclosing <b>Range</b>.  

<div class="p"><!----></div>
It has its own private cursor field <b>n</b>, telling
where it is in the iteration; different iterations over the same <b>Range</b>
can exist, and will each have their own cursor.
It is perhaps unwise to use the name <b>n</b> for a field of the inner class,
since it is also a field of the outer class, but it is legal.  (It can happen
by accident as well - <em>e.g.</em>, if a programmer were to add a field <b>n</b> to a
superclass of the  outer class, the inner class would still work.)
It does not even
interfere with the inner class's ability to refer to the outer class's <b>n</b>
field: the cursor initialization 
refers to the <b>Range</b>'s lower bound through a fully qualified name
<b>Range.this.n</b>.
Its <b>hasNext()</b> method refers to the outer class's <b>m</b> field, which is
not shadowed.

<div class="p"><!----></div>
<pre>
class Range(m:Int, n:Int) implements Iterable[Int]{
  public def iterator ()  = new RangeIter();
  private class RangeIter implements Iterator[Int] {
     private var n : Int = m;
     public def hasNext() = n &lt;= Range.this.n;
     public def next() = n++;
  }
  public static def main(argv:Array[String](1)) {
    val r = new Range(3,5);
    for(i in r) Console.OUT.println(&#239;=" + i);
  }
}
</pre>

<div class="p"><!----></div>
An inner class has full access to the members of its enclosing class, both
static and instance.  In particular, it can access <b>private</b> information,
just as methods of the enclosing class can.  

<div class="p"><!----></div>
An inner class can have its own members.  
Inside instance methods of an inner class, <b>this</b> refers to the instance
of the <em>inner</em> class.  The instance of the outer class can be accessed as
<em>Outer</em><b>.this</b> (where <em>Outer</em> is the name of the outer class).
If, for some dire reason, it is necessary to have an inner class within an inner
class, the innermost class can refer to the <b>this</b> of either outer class
by using its name.

<div class="p"><!----></div>
An inner class can inherit from any class in scope,
with no special restrictions. <b>super</b> inside an inner class refers to the
inner class's superclass. If it is necessary to refer to the outer classes's
superclass, use a qualified name of the form <em>Outer</em><b>.super</b>.

<div class="p"><!----></div>
The only restriction placed on the members of inner classes is that static
fields of an inner class must be compile-time constant expressions. 

<div class="p"><!----></div>
An inner class <b>IC1</b> of some outer class <b>OC1</b> can be extended by
another class <b>IC2</b>. However, since an <b>IC1</b> only exists as a
dependent of an <b>OC1</b>, each <b>IC2</b> must be associated with an <b>OC1</b>
- or a subtype thereof - as well.   For example, one often extends an
inner class when one extends its outer class: 
<pre>
class OC1 {
   class IC1 {}
}
class OC2 extends OC1 {
   class IC2 extends IC1 {} 
}
</pre>

<div class="p"><!----></div>
The hiding of method names has one fine point.  If an inner class defines a
method named <b>doit</b>, then <em>all</em> methods named <b>doit</b> from the
outer class are hidden - even if they have different argument types than the
one defined in the inner class.
They are still accessible via
<b>Outer.this.doit()</b>, but not simply via <b>doit()</b>.  The following code
is correct, but would not be correct if the ERROR line were uncommented.

<div class="p"><!----></div>
<pre>
class Outer {
  def doit() {}
  def doit(String) {}
  class Inner { 
     def doit(Boolean, Outer) {}
     def example() {
        doit(true, Outer.this);
        Outer.this.doit();
        //ERROR: doit("fails");
     }
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;Constructors and Inner Classes</h3>


<div class="p"><!----></div>
If <b>IC</b> is an inner class of <b>OC</b>, then instance code in the body of
<b>OC</b> can create instances of <b>IC</b> simply by calling a constructor
<b>new IC(...)</b>: 
<pre>
class OC {
  class IC {}
  def method(){
    val ic = new IC();
  }
}
</pre>

<div class="p"><!----></div>
Instances of <b>IC</b> can be constructed from elsewhere as well.  Since every
instance of <b>IC</b> is associated with an instance of <b>OC</b>, an <b>OC</b>
must be supplied to the <b>IC</b> constructor.  The syntax for doing so is: 
<b>oc.new IC()</b>.  For example: 
<pre>
class OC {
  class IC {}
  static val oc1 = new OC();
  static val oc2 = new OC();
  static val ic1 = oc1.new IC();
  static val ic2 = oc2.new IC();
}
class Elsewhere{
  def method(oc : OC) {
    val ic = oc.new IC();
  }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Anonymous Classes</h2>



<div class="p"><!----></div>
It is possible to define a new class and instantiate it as part of an
expression.  The new class can extend an extant class or interface.  Its body
can include all of the usual members of a class. It can refer to any
identifiers available at that point in the expression - except for <b>var</b>
variables.  

<div class="p"><!----></div>
Anonymous classes are useful when you want to package several pieces of
behavior together (a single piece of behavior can often be expressed as a
function, which is syntactically lighter-weight), or if you want to extend and
vary an extant class without going through the trouble of actually defining a
whole new class.

<div class="p"><!----></div>
The syntax for an anonymous class is a constructor call followed immediately
by a braced class body: <b>new C(1){def foo()=2;}</b>.

<div class="p"><!----></div>
In the following minimalist example, the abstract class <b>Choice</b>
encapsulates a decision.   A <b>Choice</b> has a <b>yes()</b> and a <b>no()</b>
method.  The <b>choose(b)</b> method will invoke one of the two.  <b>Choice</b>s
also have names.

<div class="p"><!----></div>
The <b>main()</b> method creates a specific <b>Choice</b>.  <b>c</b> is not a
immediate instance of <b>Choice</b> - as an abstract class, <b>Choice</b> has
no immediate instances. <b>c</b> is an instance of an anonymous class which
inherits from <b>Choice</b>, but supplies <b>yes()</b> and <b>no()</b> methods.
These methods modify the contents of the <b>Cell[Int]</b> <b>n</b>.  (Note that,
as <b>n</b> is a local variable, it would take a few lines more coding to
extract <b>c</b>'s class, name it, and make it an inner class.)  The call to
<b>c.choose(true)</b>  will call <b>c.yes()</b>, incrementing <b>n()</b>, in a
rather roundabout manner.

<div class="p"><!----></div>
<pre>
abstract class Choice(name: String) {
  def this(name:String) {property(name);}
  def choose(b:Boolean) { if (b) this.yes(); else this.no(); }
  abstract def yes():void;
  abstract def no():void;
}

<div class="p"><!----></div>
class Example {
  static def main(Array[String]) {
    val n = new Cell[Int](0);
    val c = new Choice(&#207;nc Or Dec") {
      def yes() { n() += 1; }
      def no()  { n() -= 1; }
      };
    c.choose(true);
    Console.OUT.println("n=" + n());
  }
}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Anonymous classes have many of the features of classes in general.  A few
features are unavailable because they don't make sense.

<div class="p"><!----></div>

<ul>
<li> Anonymous classes don't have constructors.  Since they don't have names,
      there's no way a constructor could get called in the ordinary way.
      Instead, the <b>new C(...)</b> expression must match a constructor of the
      parent class <b>C</b>, which will be called to initialize the
      newly-created object of the anonymous class.
<div class="p"><!----></div>
</li>

<li> Certain modifiers don't make sense for anonymous classes: <b>public</b>,
      <b>private</b>, and <b>protected.</b>  Anonymous classes, being anonymous,
      cannot be referenced at all.
<div class="p"><!----></div>
</li>

<li> Anonymous classes cannot be <b>abstract</b>.  Since they only exist in
      combination with a constructor call, they must be constructable.  The
      parent class of the anonymous class may be abstract, or may be an
      interface; in this case, the anonymous class must provide all the
      methods that the parent demands.
<div class="p"><!----></div>
</li>

<li> Anonymous classes cannot have explicit <b>extends</b> or <b>implements</b>
      clauses; there's no place in the syntax for them. They have a single
      parent and that is that.
<div class="p"><!----></div>
</li>
</ul>

<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>In many cases, a 
<b>val</b> field can be upgraded to a <b>property</b>, which 
entails no compile-time or runtime cost.  Some cannot be, <em>e.g.</em>, in cases where
cyclic structures of <b>val</b> fields are required.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>We use <b>Pt</b>
to avoid any possible confusion with the built-in class <b>Point</b>.
<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>This is abominable behavior for 
<b>toString</b>, but nonetheless it is allowed.
<div class="p"><!----></div>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>The
      variable names are relevant because one formal can be mentioned in a
      later type, or even a constraint: <tt>def f(a:Int, b:Point{rank==a})=...</tt>.
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.89.<br />On 16 Oct 2010, 13:23.</small>
</html>
