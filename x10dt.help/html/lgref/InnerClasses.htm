<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
C:\tth\tth_exe>go3 InnerClasses.htm
<li><a href="#tth_sEc1">Static Nested Classes</a> <br/>
<li><a href="#tth_sEc2">Inner Classes</a> <br/>
<li><a href="#tth_sEc3">Local Classes</a> <br/>
<li><a href="#tth_sEc4">Anonymous Classes</a> <br/>
</ul>

<div class="p"><!----></div>
 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Static Nested Classes</h2>
<a name="StaticNestedClasses">
</a>




<div class="p"><!----></div>
One class (or struct or interface) may be nested within another.  The simplest
way to do this is as a <b>static</b> nested class, written by putting one class
definition at top level inside another, with the inner one having a
<b>static</b> modifier.  
For most purposes, a static nested class behaves like a top-level class.
However, a static nested class has access to private static
fields and methods of its containing class.  

<div class="p"><!----></div>
Nested interfaces and static structs are permitted as well.

<div class="p"><!----></div>
<pre>
class Outer {
  private static val priv = 1;
  private static def special(n:Int) = n*n;
  public static class StaticNested {
     static def reveal(n:Int) = special(n) + priv;
  }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Inner Classes</h2>
<a name="InnerClasses">
</a>



<div class="p"><!----></div>
Non-static nested classes are called <em>inner classes</em>. An inner class
instance can be thought of as a very elaborate member of an object - one
with a full class structure of its own.   The crucial characteristic of an
inner class instance is that it has an implicit reference to an instance of
its containing class.  

<div class="p"><!----></div>
This feature is particularly useful when an instance of the inner class makes
no sense without reference to an instance of the outer, and is closely tied to
it.  For example, consider a range class, describing a span of integers m
to n, and an iterator over the range.  The iterator might as well have
access to the range object, and there is little point to discussing
iterators-over-ranges without discussing ranges as well.
In the following example, the inner class <b>RangeIter</b> iterates over the
enclosing <b>Range</b>.  

<div class="p"><!----></div>
It has its own private cursor field <b>n</b>, telling
where it is in the iteration; different iterations over the same <b>Range</b>
can exist, and will each have their own cursor.
It is perhaps unwise to use the name <b>n</b> for a field of the inner class,
since it is also a field of the outer class, but it is legal.  (It can happen
by accident as well - <em>e.g.</em>, if a programmer were to add a field <b>n</b> to a
superclass of the  outer class, the inner class would still work.)
It does not even
interfere with the inner class's ability to refer to the outer class's <b>n</b>
field: the cursor initialization 
refers to the <b>Range</b>'s lower bound through a fully qualified name
<b>Range.this.n</b>.
The initialization of its <b>n</b> field refers to the outer class's <b>m</b> field, which is
not shadowed and can be referred to directly, as <b>m</b>.

<div class="p"><!----></div>
<pre>
class Range(m:Int, n:Int) implements Iterable[Int]{
  public def iterator ()  = new RangeIter();
  private class RangeIter implements Iterator[Int] {
     private var n : Int = m;
     public def hasNext() = n &lt;= Range.this.n;
     public def next() = n++;
  }
  public static def main(argv:Array[String](1)) {
    val r = new Range(3,5);
    for(i in r) Console.OUT.println(&#239;=" + i);
  }
}
</pre>


<div class="p"><!----></div>
An inner class has full access to the members of its enclosing class, both
static and instance.  In particular, it can access <b>private</b> information,
just as methods of the enclosing class can.  

<div class="p"><!----></div>
An inner class can have its own members.  
Inside instance methods of an inner class, <b>this</b> refers to the instance
of the <em>inner</em> class.  The instance of the outer class can be accessed as
<em>Outer</em><b>.this</b> (where <em>Outer</em> is the name of the outer class).
If, for some dire reason, it is necessary to have an inner class within an inner
class, the innermost class can refer to the <b>this</b> of either outer class
by using its name.

<div class="p"><!----></div>
An inner class can inherit from any class in scope,
with no special restrictions. <b>super</b> inside an inner class refers to the
inner class's superclass. If it is necessary to refer to the outer classes's
superclass, use a qualified name of the form <em>Outer</em><b>.super</b>.

<div class="p"><!----></div>
The only restriction placed on the members of inner classes is that the static
fields of an inner class must be compile-time constant expressions. 

<div class="p"><!----></div>
Consider
an inner class <b>IC1</b> of some outer class <b>OC1</b>, being extended by 
another class <b>IC2</b>. However, since an <b>IC1</b> only exists as a
dependent of an <b>OC1</b>, each <b>IC2</b> must be associated with an <b>OC1</b>
- or a subtype thereof - as well.   So, <b>IC2</b> must be an inner class
of either <b>OC1</b> or some subclass <b>OC2 &lt;: OC1</b>.

<div class="p"><!----></div>
For example, one often extends an
inner class when one extends its outer class: 
<pre>
class OC1 {
   class IC1 {}
}
class OC2 extends OC1 {
   class IC2 extends IC1 {} 
}
</pre>


<div class="p"><!----></div>
The hiding of method names has one fine point.  If an inner class defines a
method named <b>doit</b>, then <em>all</em> methods named <b>doit</b> from the
outer class are hidden - even if they have different argument types than the
one defined in the inner class.
They are still accessible via
<b>Outer.this.doit()</b>, but not simply via <b>doit()</b>.  The following code
is correct, but would not be correct if the ERROR line were uncommented.

<div class="p"><!----></div>
<pre>
class Outer {
  def doit() {}
  def doit(String) {}
  class Inner { 
     def doit(Boolean, Outer) {}
     def example() {
        doit(true, Outer.this);
        Outer.this.doit();
        //ERROR: doit("fails");
     }
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Constructors and Inner Classes</h3>
<a name="sect:InnerClassCtor">
</a>


<div class="p"><!----></div>
If <b>IC</b> is an inner class of <b>OC</b>, then instance code in the body of
<b>OC</b> can create instances of <b>IC</b> simply by calling a constructor
<b>new IC(...)</b>: 
<pre>
class OC {
  class IC {}
  def method(){
    val ic = new IC();
  }
}
</pre>

<div class="p"><!----></div>
Instances of <b>IC</b> can be constructed from elsewhere as well.  Since every
instance of <b>IC</b> is associated with an instance of <b>OC</b>, an <b>OC</b>
must be supplied to the <b>IC</b> constructor.  The syntax for doing so is: 
<b>oc.new IC()</b>.  For example: 
<pre>
class OC {
  class IC {}
  static val oc1 = new OC();
  static val oc2 = new OC();
  static val ic1 = oc1.new IC();
  static val ic2 = oc2.new IC();
}
class Elsewhere{
  def method(oc : OC) {
    val ic = oc.new IC();
  }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Local Classes</h2>
<a name="sect:LocalClasses">
</a>

<div class="p"><!----></div>
Classes can be defined and instantiated in the middle of methods and other
code blocks.
A local class in a static method is a static class; a local class in an
instance method is an inner class.
 Local classes are local to the block in which they are defined.
They have access to almost everything defined at that point in the method; the
one exception is that they cannot use <b>var</b> variables. Local classes
cannot be <b>public</b> <b>protected</b>, or <b>private</b>, because they are
only visible from within the block of declaration. They cannot be
<b>static</b>.

<div class="p"><!----></div>
The following example illustrates the use of a local class <b>Local</b>, 
defined inside the body of method <b>m()</b>. 
<pre>
class Outer {
  val a = 1;
  def m() {
    val a = -2; 
    val b = 2;
    class Local {
      val a = 3;
      def m() = 100*Outer.this.a + 10*b + a; 
    }
    val l : Local = new Local();
    assert l.m() == 123;
  }//end of m()
}
</pre>
Note that the middle <b>a</b>,
whose value is <b>-2</b>, is not accessible inside of <b>Local</b>; it is
shadowed by <b>Local</b>'s <b>a</b> field.  <b>Outer</b>'s <b>a</b> is also
shadowed, but the notation <b>Outer.this</b> gives a reference to the enclosing
<b>Outer</b> object.  There is no corresponding notation to access shadowed local
variables from the enclosing block; if you need to get them, rename the fields
of <b>Local</b>.    


<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Anonymous Classes</h2>



<div class="p"><!----></div>
It is possible to define a new class and instantiate it as part of an
expression.  The new class can extend an extant class or interface.  Its body
can include all of the usual members of a class. It can refer to any
identifiers available at that point in the expression - except for <b>var</b>
variables.  An anonymous class in a static context is a static inner class.

<div class="p"><!----></div>
Anonymous classes are useful when you want to package several pieces of
behavior together (a single piece of behavior can often be expressed as a
function, which is syntactically lighter-weight), or if you want to extend and
vary an extant class without going through the trouble of actually defining a
whole new class.

<div class="p"><!----></div>
The syntax for an anonymous class is a constructor call followed immediately
by a braced class body: <b>new C(1){def foo()=2;}</b>.

<div class="p"><!----></div>
In the following minimalist example, the abstract class <b>Choice</b>
encapsulates a decision.   A <b>Choice</b> has a <b>yes()</b> and a <b>no()</b>
method.  The <b>choose(b)</b> method will invoke one of the two.  <b>Choice</b>s
also have names.

<div class="p"><!----></div>
The <b>main()</b> method creates a specific <b>Choice</b>.  <b>c</b> is not a
immediate instance of <b>Choice</b> - as an abstract class, <b>Choice</b> has
no immediate instances. <b>c</b> is an instance of an anonymous class which
inherits from <b>Choice</b>, but supplies <b>yes()</b> and <b>no()</b> methods.
These methods modify the contents of the <b>Cell[Int]</b> <b>n</b>.  (Note that,
as <b>n</b> is a local variable, it would take a few lines more coding to
extract <b>c</b>'s class, name it, and make it an inner class.)  The call to
<b>c.choose(true)</b>  will call <b>c.yes()</b>, incrementing <b>n()</b>, in a
rather roundabout manner.

<div class="p"><!----></div>
<pre>
abstract class Choice(name: String) {
  def this(name:String) {property(name);}
  def choose(b:Boolean) { 
     if (b) this.yes(); else this.no(); }
  abstract def yes():void;
  abstract def no():void;
}

<div class="p"><!----></div>
class Example {
  static def main(Array[String]) {
    val n = new Cell[Int](0);
    val c = new Choice(&#207;nc Or Dec") {
      def yes() { n() += 1; }
      def no()  { n() -= 1; }
      };
    c.choose(true);
    Console.OUT.println("n=" + n());
  }
}

<div class="p"><!----></div>
</pre>


<div class="p"><!----></div>
Anonymous classes have many of the features of classes in general.  A few
features are unavailable because they don't make sense.

<div class="p"><!----></div>

<ul>
<li> Anonymous classes don't have constructors.  Since they don't have names,
      there's no way a constructor could get called in the ordinary way.
      Instead, the <b>new C(...)</b> expression must match a constructor of the
      parent class <b>C</b>, which will be called to initialize the
      newly-created object of the anonymous class.
<div class="p"><!----></div>
</li>

<li> The <b>public</b>,
      <b>private</b>, and <b>protected</b>  modifiers don't make sense for
      anonymous classes:  
      Anonymous classes, being anonymous,
      cannot be referenced at all, so references to them can't be public,
      private, or protected.
<div class="p"><!----></div>
</li>

<li> Anonymous classes cannot be <b>abstract</b>.  Since they only exist in
      combination with a constructor call, they must be constructable.  The
      parent class of the anonymous class may be abstract, or may be an
      interface; in this case, the anonymous class must provide all the
      methods that the parent demands.
<div class="p"><!----></div>
</li>

<li> Anonymous classes cannot have explicit <b>extends</b> or <b>implements</b>
      clauses; there's no place in the syntax for them. They have a single
      parent and that is that.
<div class="p"><!----></div>
</li>
</ul>

<br /><br />
</html>
