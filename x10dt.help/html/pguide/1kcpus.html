<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>Two CPUs Are Better Than One</title>

 <h2><a name="tth_sEc2">
3</a>&nbsp;&nbsp;A Thousand CPUs Are Better Than Two</h2>

     <h3><a name="tth_sEc2.1">
3.1</a>&nbsp;&nbsp;Distributing Work</h3>
 To get real concurrency, we have to distribute the work across multiple processors.  X10
 provides a type, <tt>Place</tt>, that represents a processor, together with some local storage.
 The physical reality is that different <tt>Place</tt>s may refer to the same physical processor and may share
 physical memory, but-and this is what counts-from the programmer's point of view two
 distinct <tt>Places</tt> have no resources in common.  If you've programmed using the MPI
 library, you'll feel comfortable with this: every MPI process has its own storage: there is no
 common storage.

<div class="p"><!----></div>
  <tt>Place.MAX_PLACES</tt> is the number of <tt>Places</tt> available to a program.  It is fixed
  as program start-up and cannot be altered thereafter.  For those familiar with MPI, 
  <tt>Place.MAX_PLACES</tt> is the same as the value left in <tt>processCount</tt> by the call
  
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MPI_Comm_size(MPI_COMM_WORLD,&nbsp;\&amp;processCount)
</pre>
  or if you've worked with UPC, it is the same as <tt>THREADS</tt>. 

<div class="p"><!----></div>
  Each <tt>Place</tt> has an integer id:
  if <tt>p</tt> is a <tt>Place</tt>, then <tt>p.id</tt> is its id.  An activity can find out at which <tt>Place</tt>
  it is executing by evaluating the expression <tt>here</tt>.  The keyword <tt>here</tt> is reserved
  for this purpose alone.  The id of the current activity's <tt>Place</tt> is <tt>here.id</tt>.  
  Again, for those familiar with MPI, this is the same as the value in <tt>id</tt> after
    
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MPI_Comm_rank(MPI_COMM_WORLD,&nbsp;\&amp;id)
</pre>
and the UPC equivalent is <tt>MYTHREAD</tt>.

<div class="p"><!----></div>
  The <tt>Place</tt> whose id  is "<tt>i</tt>" can be got by evaluating <tt>Place.places(i)</tt>.

<div class="p"><!----></div>
 The X10 runtime begins a program's execution by creating a single activity, the
 "root" activity, that calls
 the program's <tt>main()</tt>.  The root activity's home <tt>Place</tt> is called <tt>Place.FIRST_PLACE</tt>, 
 and by convention, it is the <tt>Place</tt> whose id is <tt>0</tt>.

<div class="p"><!----></div>
 So the question is: how does information at one <tt>Place</tt> get to another?  One simple way
 is to use an "<tt>at(p)</tt>"  statement:   if the identifier <tt>p</tt> names a <tt>Place</tt>, and 
 <tt>computeAnInt()</tt> is a method that computes an <tt>Int</tt>, then
 
<pre>&nbsp;&nbsp;&nbsp;val&nbsp;anInt&nbsp;=&nbsp;at(p)&nbsp;computeAnInt();&nbsp;
</pre> 
 means: "Pause this activity.  Go to the <tt>Place p</tt>, and then call <tt>computeAnInt()</tt>.  Send
 the result back here to this <tt>Place</tt>, assign the value to <tt>anInt</tt>, and then
 let this activity continue."  The requesting activity is
 blocked while the remote activity computes the needed value.

<div class="p"><!----></div>
 If you do not want to wait around yet for the value to be computed and assigned,
 things are not so simple.  You might think
 that something like the obvious
 
<pre>&nbsp;&nbsp;async&nbsp;val&nbsp;anInt&nbsp;=&nbsp;&nbsp;at(p)&nbsp;computeAnInt();&nbsp;
</pre> 
 might work, but it doesn't.   Just as with <tt>for</tt>  loops, the declaration of <tt>anInt</tt> 
 in an <tt>async</tt>'s body means that it is not available outside of it.
 Trying to shift the <tt>async</tt> around doesn't help:
 
<pre>&nbsp;val&nbsp;anInt&nbsp;=&nbsp;async&nbsp;at(p)&nbsp;&nbsp;computeAnInt();&nbsp;
</pre> 
 won't work either:  an <tt>async</tt> statement
 does not have a value that it "returns."  

<div class="p"><!----></div>
If you give up on declaring a "<tt>val</tt>" and settle for a "<tt>var</tt>", there is hope:

<pre>&nbsp;&nbsp;var&nbsp;anInt:&nbsp;Int;
&nbsp;&nbsp;async&nbsp;anInt&nbsp;=&nbsp;&nbsp;at(p)&nbsp;computeAnInt();&nbsp;
</pre> 
Natural though this might seem, it will not work.  As we have said before
(and probably will again), there are real problems with passing <em>variables</em>
into an asynchronous activity. 
What you <em>can</em> do is to use an array with one entry to capture the value:  
 
<pre>&nbsp;&nbsp;&nbsp;val&nbsp;anInt&nbsp;=&nbsp;new&nbsp;Array[Int](0..0);
&nbsp;&nbsp;&nbsp;async&nbsp;{&nbsp;anInt(0)&nbsp;=&nbsp;at(p)&nbsp;computeAnInt();&nbsp;}&nbsp;
</pre>
Here <tt>anInt</tt> names an array of <tt>Int</tt>s with a single entry at index 0.
What <tt>anInt</tt> names cannot change: that is, the address of the array.  What can change
is what is stored at that address, which is what the <tt>async</tt> does.

<div class="p"><!----></div>
Of course,  just as we did in Section <a href="#sec:esp">1.4</a> when we wanted several 
<tt>async</tt>s to share the work of picking random points,
we have to guard any <tt>async</tt> with a <tt>finish</tt> before we attempt to 
use any of side effects, like setting the value of <tt>anInt(0)</tt>, that it might cause.

<div class="p"><!----></div>
      <h3><a name="tth_sEc2.2">
3.2</a>&nbsp;&nbsp; Don't Try This On <em>Your</em> Computer</h3>
 Let's get started with our multi-processor code with some high-level pseudo-code.
 We are going to go all out and not only use several <tt>Places</tt>, but at each
 <tt>Place</tt>, we'll use several activities.  Here we go:
 
<dl compact="compact">
<a name="lbl:mpchl">
</a>
	<dd><tt>main</tt>:
      Reads command line to get the number of places to use.
      For each <tt>Place</tt>, calls the function <tt>countAtP</tt> to get
      that one <tt>Place</tt>'s contribution and adds them up.</dd>

	<dd><tt>countAtP</tt> :
      Essentially the same as the loop over the set of threads
      in <tt>MontePiAsync</tt>'s <tt>main</tt>: 
      adds up the counts from several threads at one <tt>Place</tt>, as
     returned by <tt>countPoints</tt>.  See Figure <a href="#fig:mcpm">2</a>;</dd>

	<dd><tt>countPoints</tt>:
      Called once per thread, and really <em>is</em> the same as in <tt>MontePiAsync</tt>:
      here is where we actually call the random number generator.</dd>
</dl>

<div class="p"><!----></div>
In thinking about this code, keep in mind that a really high-performance computer
can provide literally thousands of <tt>Place</tt>s, but,
for this sort of CPU-intensive activity, any given <tt>Place</tt> is likely only
to support at most a dozen or so threads, or less.  That said, we might ask ourselves whether
it makes sense to use different strategies  for accumulating 
our results in <tt>countAtP</tt>,  which we expect to have very few contributors,
versus <tt>main</tt>, which may have thousands.

<div class="p"><!----></div>
When we only have two or three integers to add together, it might make sense to
use a single <tt>var count:Long</tt> to accumulate the total count, rather than using
an array (as we did in the <tt>main</tt> for <tt>MontyPiAsync</tt>).   
A <tt>val</tt> that is an array with a single <tt>Long</tt> element will do admirable.
Here's a first cut:

<pre>&nbsp;1&nbsp;public&nbsp;static&nbsp;def&nbsp;countAtP(pId:Int,&nbsp;threads:Int,&nbsp;n:Long)&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;count:&nbsp;Array[Long](1)&nbsp;=&nbsp;new&nbsp;Array[Long](0..0);
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;j&lt;=&nbsp;threads;&nbsp;j++)&nbsp;&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;jj&nbsp;=&nbsp;j;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random(Timer.nanoTime()));
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;()&nbsp;=&#62;&nbsp;r.nextDouble();
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count(0)&nbsp;+=&nbsp;countPoints(n,&nbsp;rand);
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
10&nbsp;&nbsp;&nbsp;&nbsp;}
11&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count(0);
12&nbsp;}
</pre>
If you compare this with Figure <a href="#fig:mcpm">2</a>, the only difference is that we are using
one array element here instead of one per thread.  Sadly, this approach is just plain wrong.

<div class="p"><!----></div>
The trouble is in line 8, where <tt>count(0)</tt> is updated.  If your are a veteran of the
parallel programming wars, you will recognize this as a classic <em>race</em> condition.
For the newcomers, here is a scenario that shows what's wrong:

<blockquote>
<tt>count(0)</tt> is initially set to 0, and there are two threads, <tt>T1</tt> and <tt>T2</tt>.

<div class="p"><!----></div>
<tt>T1</tt> begins
executing first.  When it gets to line 8, it loads the value of <tt>count(0)</tt>,
which is 0, into the CPU. Just after the load completes,
 the operating system's thread manager suspends <tt>T1</tt>. 

<div class="p"><!----></div>
A few nanoseconds later, the system lets <tt>T2</tt> start, and it gets
to line 8, where it also loads the value 0 from <tt>count(0)</tt>, because <tt>T1</tt>
never completed its update. 
<tt>T2</tt> adds its value to 0, and stores it back into <tt>count(0)</tt>.  So <tt>count(0)</tt>
now is whatever <tt>T2</tt> computed.

<div class="p"><!----></div>
Once  <tt>T1</tt> is restarted, it uses the value of <tt>count(0)</tt> that
it has already loaded-it doesn't
do the load again.  But that means that it does not see the effect of
<tt>T2</tt>'s update: its loaded value is still 0. 
When <tt>T1</tt> adds its contribution and stores the result back into <tt>count(0)</tt>,
the value stored is that computed by <tt>T1</tt>, not its sum with <tt>T2</tt>'s
value:  <tt>T2</tt>'s contribution has been lost.

<div class="p"><!----></div>
Disaster!
</blockquote>
You can see why this is called a race.  It is a particularly insidious sort of bug,
because sometimes you get the right answers, and sometimes you don't.
After all, the operating system did not <em>have</em> to suspend <tt>T1</tt> at just
the wrong moment.  It just happened to.

<div class="p"><!----></div>
The cure is simple enough: X10 provides an <em>atomic</em> statement, whose
syntax is <tt>atomic S</tt>, where <tt>S</tt> is any X10 statement.   What we
need here is a new line 8:

<pre>&nbsp;8*&nbsp;atomic&nbsp;count(0)&nbsp;+=&nbsp;countPoints(n,&nbsp;rand);
</pre>
What <tt>atomic S</tt> guarantees is that once a thread enters <tt>S</tt>,
no other thread may enter it until the original thread completes <tt>S</tt>
leaves it.  In our example, if <tt>T1</tt> starts executing
line 8* and is interrupted by the system, <em><tt>T2</tt> will be blocked when it
reaches line 8*, because <tt>T1</tt> is still active there</em>.  <tt>T2</tt> will be
suspended until <tt>T1</tt> finishes the assignment.  It slows things down,
but you get the right answer.

<div class="p"><!----></div>
The problem here is that multiple activities share a resource.  Here they
share a 
piece of storage.  But it could also be an output stream,  For instance,
suppose two activities
call <tt>Console.OUT.println</tt> at the same time.  What happens?  Answer:
it depends!  Sometimes each line will print as desired, sometimes the 
two lines will be interleaved, just like shuffling a deck of cards.  Try
the following code, for example:

<pre>import&nbsp;x10.io.Console;
public&nbsp;class&nbsp;HelloAsync&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(argv:Rail[String]!)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;Console.OUT.println("Hello,&nbsp;World");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;Console.OUT.println("Hola,&nbsp;Mundo");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;Console.OUT.println("Bonjour,&nbsp;Monde");
&nbsp;&nbsp;&nbsp;}
}
</pre>
Here's our console log, compiling and running it:

<pre>\%x10c&nbsp;HelloAsync.x10
%&nbsp;x10&nbsp;HelloAsync
BHelonlo,j&nbsp;oWuorr,l&nbsp;dM
onde
Hola,&nbsp;Mundo
</pre>
The Spanish, "Hola, Mundo," got delivered in one shot, but the English
and French got a pretty well interleaved.  Who knows what might have happened on another
run!  Even more amusing: why was the <em>second</em> <tt>async</tt> the
one that wasn't interrupted?  The first, maybe-the last, not too surprising-but,
the <em>second</em>?

<div class="p"><!----></div>
Time for a confession: our line 8* really is not a good solution.
What is bad is that virtually all the time spent executing the statement is
in the very expensive call to <tt>countPoints</tt>.  There is no problem about the
two activities executing <tt>countPoints</tt> concurrently: it does not depend
on any shared resources.  The only shared resource is <tt>count(0)</tt>, which
doesn't appear in <tt>countPoints</tt> at all.  So what we really want is:

<pre>&nbsp;8**&nbsp;&nbsp;val&nbsp;ourCount&nbsp;=&nbsp;&nbsp;countPoints(n,&nbsp;rand);
&nbsp;8***&nbsp;atomic&nbsp;count(0)&nbsp;+=&nbsp;ourCount;
</pre>
 Because only one activity at a time can execute an atomic statement,
 clearly the smart thing is to keep it as small as possible.

<div class="p"><!----></div>
Putting all this to use, we get  <tt>MontePiCluster</tt>,
which is shown in Figure . 

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="tth_fIg2">
</a> <a name="fig:mpcl1">
</a><hr />

<pre>
public&nbsp;class&nbsp;MontePiCluster&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;countAtP(threads:Int,&nbsp;n:Long)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;count&nbsp;=&nbsp;new&nbsp;Array[Long](0..0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;j&lt;=&nbsp;threads;&nbsp;j++)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;jj&nbsp;=&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random(Timer.nanoTime()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;()&nbsp;=&#62;&nbsp;r.nextDouble();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;jCount&nbsp;=&nbsp;countPoints(n,&nbsp;rand);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atomic&nbsp;count(0)&nbsp;+=&nbsp;jCount;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count(0);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;countPoints(n:Long,&nbsp;rand:()=&#62;Double)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;inCircle:&nbsp;Long&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Long=1;&nbsp;j&lt;=n;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;x&nbsp;=&nbsp;rand();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;y&nbsp;=&nbsp;rand();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(x*x&nbsp;+y*y&nbsp;&lt;=&nbsp;1.0)&nbsp;inCircle++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inCircle;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;N&nbsp;=&nbsp;args.size()&#62;0&nbsp;?&nbsp;Long.parse(args(0))&nbsp;:&nbsp;1000000L;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;maxP&nbsp;=&nbsp;args.size()&#62;1&nbsp;?&nbsp;Int.parse(args(1))&nbsp;:&nbsp;4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;tPerP&nbsp;=&nbsp;args.size()&#62;2&nbsp;?&nbsp;Int.parse(args(2))&nbsp;:&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;nPerT&nbsp;=&nbsp;N/(maxP&nbsp;*&nbsp;tPerP);&nbsp;//&nbsp;points&nbsp;per&nbsp;thread
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inCircle&nbsp;=&nbsp;new&nbsp;Array[Long](1..maxP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;for(var&nbsp;k:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;k&lt;=maxP;&nbsp;k++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;kk&nbsp;=&nbsp;k;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;p&nbsp;=&nbsp;Place.places(k-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;inCircle(kk)&nbsp;=&nbsp;at(p)&nbsp;countAtP(kk,tPerP,nPerT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;total:&nbsp;Long&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var&nbsp;k:&nbsp;Int&nbsp;=1;&nbsp;k&lt;=maxP;&nbsp;k++)&nbsp;total&nbsp;+=&nbsp;inCircle(k);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pi&nbsp;=&nbsp;(4.0*total)/N;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;"&nbsp;+&nbsp;pi);
&nbsp;&nbsp;}
</pre>

<center>Figure 2: A Distributed Version of MontyPi</center> 
<hr />


<div class="p"><!----></div>
     <h3><a name="tth_sEc2.3">
3.3</a>&nbsp;&nbsp;Time For More Lipstick</h3><a name="sec.mplips">
</a> 

<div class="p"><!----></div>
First a very simple piece of clean-up:
the idiom "<tt>atomic x += y</tt>" is so common, and more generally,
the situation where there is a single variable has to be updated atomically,
that X10 provides a set of types to help you out: <tt>AtomicInteger</tt>,
<tt>AtomicLong</tt>, <tt>AtomicBoolean</tt> and <tt>AtomicReference</tt> in
the package <tt>x10.util.concurrent. atomic</tt>'.  Here's how one uses them.
Instead of "<tt>val count = Array...</tt>", we declare

<pre>val&nbsp;count&nbsp;=&nbsp;new&nbsp;AtomicInteger(0);
</pre>
Inside the loop, the assignment "<tt>atomic count(0) += jCount;</tt>" gets replaced by:

<pre>count.addAndGet(jCount);
</pre>
The atomicity of the operation is guaranteed by the method call here: you don't need
to explicitly assert it as we did in our original.

<div class="p"><!----></div>
Time now for something more substantial.  From the beginning we have been
talking about points in a circle.  But not a single point, as such, has occurred among
our data types.  It is time to remedy that, and to make a start into X10 as an
object-oriented language.

<div class="p"><!----></div>
X10 actually provides more than one way to describe structured data.  Right now,
we'll work with the one closest to what one would see in Java and C++:

<pre>&nbsp;1&nbsp;public&nbsp;class&nbsp;Point2D&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;public&nbsp;val&nbsp;x:&nbsp;Double;
&nbsp;3&nbsp;&nbsp;&nbsp;public&nbsp;val&nbsp;y:&nbsp;Double;
&nbsp;4&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(x:&nbsp;Double,&nbsp;y:&nbsp;Double)&nbsp;{
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x&nbsp;=&nbsp;x;&nbsp;&nbsp;this.y&nbsp;=&nbsp;y;
&nbsp;6&nbsp;&nbsp;&nbsp;}
&nbsp;7&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;magnitude()&nbsp;=&nbsp;x*x&nbsp;+&nbsp;y*y;
&nbsp;8&nbsp;}
</pre>
As usual, let's work our way line by line through this code.

<dl compact="compact">

	<dd>line 1:  This is how we would declare the class if we wanted it to be a top-level
class in its own file.  If we want to put the declaration in the file for <tt>MontePiCluster</tt>,
would use "<tt>public <em>static</em> class Point2D <br />...}" and include it as part of the
body of <tt>MontePiCluster</tt>.

<div class="p"><!----></div>
By the way, X10 has a class called "<tt>Point</tt>" that is fundamental and that we
shall eventually have a lot to say a lot about.  That is why we called this class
<tt>Point2D</tt>: to avoid confusion with X10's class.
	<dd>lines 2 and 3: We are declaring two instance members here, both double-precision
numbers, <tt>x</tt> and <tt>y</tt>.  What "<tt>val</tt>" means in this context is that a value will be
assigned to the identifier in the constructor, and once assigned cannot be changed.</dd>

	<dd>line 4:  This is the X10 idiom for a constructor.  The keyword <tt>def</tt>, as
noted before signals a method declaration.  When one writes

<pre>&nbsp;&nbsp;&nbsp;val&nbsp;pt&nbsp;=&nbsp;new&nbsp;Point2D(3.0,&nbsp;5.1);
</pre>
it is this method that will get called.  Because <tt>x</tt> was declared to
be <tt>public</tt>, one can use <tt>pt.x</tt> to get is value, 3.0, once the constructor returns.</dd>

	<dd>line 5: An argument like <tt>x</tt> that has the same name as member will
hide the member, so you need to say <tt>this.x</tt> in this context when what you
mean is the member.</dd>

	<dd>line 7:  Another method declaration: <tt>magnitude</tt> returns the (squared!)
magnitude of the point, x<sup>2</sup> + y<sup>2</sup>.  In simple cases like this, where the
function is just returning the value of an expression, you don't need to write out function body as

<pre>&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;x*x&nbsp;+&nbsp;y*y;&nbsp;}
</pre>
As in this example, the expression after an "" sign will do.</dd>
</dl>
Let's rewrite <tt>countPoints</tt> using our new class:

<pre>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;countPoints(n:Long,&nbsp;rand:()=&#62;Double)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;inCircle:&nbsp;Long&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Long=1;&nbsp;j&lt;=n;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pt&nbsp;=&nbsp;new&nbsp;Point2D(rand(),&nbsp;rand());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pt.magnitude()&nbsp;&lt;=&nbsp;1.0)&nbsp;inCircle++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inCircle;
&nbsp;&nbsp;&nbsp;}
</pre>
We could even go further and instead of using <tt>rand</tt>, we could have

<pre>public&nbsp;static&nbsp;def&nbsp;countPoints(n:Long,&nbsp;rpt:()=&#62;Point2D)&nbsp;{
</pre>
if in <tt>countAtP</tt>, we replace the definition of <tt>rand</tt> with our new function, <tt>rpt</tt>:

<pre>val&nbsp;rpt&nbsp;=&nbsp;()=&#62;new&nbsp;Point2D(r.nextDouble(),&nbsp;r.nextDouble);
</pre>

<div class="p"><!----></div>
You can find the final version in
 
<center> %???? we need to figure out how to ref the real code
<a href="src/montePi/montePiAsync.x10"><b>montePi/montePiCluster2.x10</b></a>.
</center>

<div class="p"><!----></div>
<b>Exercise:</b> You might want to try a slight variation on this theme:  write a method that
uses one or more <tt>Place</tt>s to sum the values of a function  <tt>f:(d:Double)=&#62;Double</tt> over a 
sequence of <tt>N Doubles</tt> of the form <tt>d0, d0+delta, ... d0+k*delta, ...</tt>
For debugging sake, try some simple <tt>f</tt>'s to begin, like <tt>f = (d:Double) =&#62; 1.0</tt> .  Then you
can go hog-wild using your own functions ( <tt>(d:Double)=&#62;d*d</tt>), or
the functions in <tt>x10.Math</tt>, like <tt>sin</tt>, <tt>log</tt>, and 
<tt>sqrt</tt>.

<div class="p"><!----></div>
The amusing questions are: what part of the sum is a given activity responsible for,
and how do we combine the partial results?  Combing the results is really the same as
as what we've done for <tt>MontyPiCluster</tt> here.  Splitting up the sum requires some
thought.

<div class="p"><!----></div>
If there are <tt>p Place</tt>s and <tt>aPerP</tt> activities
in parallel at each <tt>Place</tt>, there will be <tt>aInAll = p*aPerP</tt> activities in all.  Since there are
<tt>N</tt> values to be summed, each activity should handle roughly <tt>N/aInAll</tt> additions-"roughly"
because <tt>aInAll</tt> might not divide <tt>N</tt> evenly.  One solution is to let the
activity <tt>j</tt> (<tt>j=0,1,...,aPerP-1</tt>) at the <tt>Place</tt> whose id is <tt>pid</tt>  take care of the values 
<tt>d0+k*delta</tt>, where <tt>k</tt> runs over <tt>pid*aPerP+j+n*aInAll</tt> for <tt>n = 0,1,... </tt>

<div class="p"><!----></div>
We'll come back to this sort of loop in gory detail in the advanced examples.
</tt>
<br /><br />

</html>