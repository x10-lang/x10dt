<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>Giving Up Inheritance To Get Efficiency</title>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Giving Up Inheritance To Get Efficiency</h2>

<div class="p"><!----></div>
Supporting inheritance does not come with costs when the program runs.  You can see
why most easily by looking at a huge arrays.  
Suppose that an array <tt>arr</tt> is declared as an <tt>Array[T]</tt>.

<blockquote>
Any given entry in the array can actually
have been declared to be a <tt>U</tt>, where <tt>U</tt> is <em>any</em> subclass of <tt>T</tt>.
We don't know how the entry might be used-later on, it might be important that
this is a <tt>U</tt> and not just a <tt>T</tt>-so for every entry,
we have to keep both both a reference
to the object itself <em>and</em> a reference to the object's class information.  If there are
<tt>N</tt> entries in the array, and if the reference to the class uses <tt>k</tt> bytes,
we just used <tt>k*N</tt> bytes to store this data.  And <tt>N</tt> is <em>big</em>!

<div class="p"><!----></div>
Furthermore, whenever
we execute a method call <tt>arr(k).fcn(...)</tt>, we have to use the class information
for <tt>array(k)</tt> to find the code for the method: remember that subclasses can override
the methods of their parents, so we will only know at runtime what to look for.
This slows down every method call.
</blockquote>

<div class="p"><!----></div>
The additional overhead explains why a performance-oriented language avoids using
the normal class hierarchy for primitive types like 32-bit integers.

<div class="p"><!----></div>
<b>Major design issue</b> How much of what classes give us can we keep without
giving up any substantial amount of efficiency?

<div class="p"><!----></div>
There are several issues here: the serial issues-don't wast space, and don't waste time-
and the distribution issue-don't create potential inconsistencies between what one
processor thinks the value of the "thing" is and another thinks, so that communication
between them is required to maintain integrity.

<div class="p"><!----></div>
In short: what we need are values whose type is exactly what they are declared to be,
and not some "improvement."  X10 calls these things (rather unfortunately) "<tt>struct</tt>s".
They bear about the same relation to the familiar <em>C</em> <tt>struct</tt> as class declarations
do, but that's the way it is.

<div class="p"><!----></div>
As an example of a <tt>struct</tt>, X10 style, let us do a variation on our class <tt>Point2D</tt>.

<pre>&nbsp;1&nbsp;&nbsp;public&nbsp;struct&nbsp;Point2D&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;x:&nbsp;Double;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;y:&nbsp;Double;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(x:&nbsp;Double,&nbsp;y:&nbsp;Double)&nbsp;{
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x&nbsp;=&nbsp;x;&nbsp;&nbsp;this.y&nbsp;=&nbsp;y;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;magnitude()&nbsp;=&nbsp;x*x&nbsp;+&nbsp;y*y;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;abs&nbsp;=&nbsp;Math.sqrt(magnitude());
&nbsp;9&nbsp;}
</pre>
As usual, the line-by-line:

<div class="p"><!----></div>

<dl compact="compact">

	<dd><b>line 1:</b> The accessibility rules for a struct are the same as for a class.  We
chose "<tt>public</tt>" for the example, but the default is also possible, and if the struct is
declared in a class body, <tt>protected</tt> and <tt>private</tt> may also be used. 

<div class="p"><!----></div>
Structs may
be generic-that is, may have type parameters-although this one does not.</dd>

	<dd><b>lines 2 and 3:</b>  The instance members of a struct are always <tt>val</tt>s.
In fact, the best way to think of a whole instance of a struct is as a value, just as you would
think of an <tt>Int</tt> as a value: one can have variable <tt>n</tt> whose value is an <tt>Int</tt>, and <tt>n</tt>'s
value may be different <tt>Int</tt>s at different times, but there is nothing within a particular <tt>Int</tt> itself
that you modify.

<div class="p"><!----></div>
One consequence of this is that once the constructor for a struct returns, none
of its instance members can be modified.   Another is that if <tt>s1</tt> and <tt>s2</tt> are
two instances a the same struct, then "<tt>s1 == s2</tt>" means what you think it 
means: their instance members have identical values.  (Remember that for 
instances of a class, ""  is used to determine whether exactly the same object
( the same piece of storage) appears on both sides, not just two objects with instance members
having identical values: the method call <tt>o1.equals(o2)</tt> does that weaker check for
objects.</dd>

	<dd><b>lines 6 and 7</b> Unlike their C namesakes, X10 structs can declare methods.
We've shown both as public here, but both private and default (package private) can be used.
"Protected" makes no sense, since it just weakens the default by also allowing subclasses access,
and  structs <em>never</em> have subclasses.</dd>
</dl>

<div class="p"><!----></div>
We did not show it, but structs can have static methods and members.  In principle, one can
also define static classes in the body of a struct, just as one can in a class.  How often this is
needed is a good question, though: probably not often.   

<div class="p"><!----></div>
The rules for declaring structs are such that the compiler can determine the size of
an instance from the declaration.  The reason is storage efficiency:  once the size is
known, no more space need be allocated than is need to store the value in memory,
and at runtime, we don't have to carry around size information for every instance.

<div class="p"><!----></div>
For example, our <tt>Point2D</tt> with its two <tt>Double</tt>s requires exactly 16 = 2*8
bytes to store an instance.  If we also had to store a pointer to its "class" with
every instance, that would
add at least 4 and maybe up to 12 bytes or even more, depending on what we had to store in
addition to the raw address, and on how many bytes you need for even the raw address: once
memory is measured in gigabytes, at least 6 bytes are needed just for an address.
Yes: 25<br />
<div class="p"><!----></div>
There is one more restriction to what can go into a struct that is critical:
<em>an instance <tt>s</tt> of a struct <tt>S</tt> cannot
have an instance member <tt>s.nextS</tt> that is itself also an <tt>S</tt></em>.  To C programmers
in particular, this may seem a bit weird-how you form lists of these things?  But
remember: <em>instances of structs, unlike instances of classes, are values, <em>not</em> references</em>. 
It may help to understand this if we try to declare a struct <tt>Point2DListItem</tt>.  It has two members,
a <tt>Point2D</tt>, <tt>p</tt>, and a
<tt>Point2DListItem</tt>, <tt>next</tt> which is <tt>p</tt>'s successor in the list.
How big is a <tt>Point2DListItem</tt>?   Well, a <tt>Point2D</tt> itself is
is 16 bytes, so if <tt>sizeOfPLI</tt> is the
size of a <tt>Point2DListItem</tt>,  then adding the sizes of the two instance members, we get a total

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeOfPLI&nbsp;==&nbsp;16&nbsp;+&nbsp;sizeofPLI
</pre>
Oops! Subtracting <tt>sizeOfPLI</tt> from both sides yields <tt>0 == 16</tt>!  

<div class="p"><!----></div>
<b>Aside for C/C++ programmers: </b> The way a C programmer uses structs to create lists is through
a declaration like "<tt>struct S {int a; int; b;</tt>  <tt>struct S *next}</tt>".
In other words,, you put a reference to a <tt>struct S</tt> in the body of the struct, and not a <tt>struct S</tt> itself.
The equivalent X10 would be to put a <tt>var</tt> (and not a <tt>val</tt>) of type <tt>S</tt> in the body, but that won't
work, because in X10, a <tt>var</tt> whose type is a struct is never a reference, no matter whether
the <tt>var</tt> appears on its own as local variable or as a member of a class or struct.  And X10
has no explicit notion of "pointer."

<div class="p"><!----></div>
So how <em>does</em> one design a struct that is a list of structs?  The short answer is: one should not.
Lists are introduced because a collection of uncertain eventual size is being grown, and one
therefore has to forego the efficiency of a pre-allocated array.  One pays the overhead of following a 
reference to the next item (rather than just bumping an array index) so as to have the freedom
to grow and shrink the list efficiently as needed.  In other words: lists are by their very nature dynamic.
The whole point of a struct is that it is static: once constructed it cannot be modified.  Let's return
to our <tt>Point2DListItem</tt>.  If we declare it as follows, there is no problem:

<pre>&nbsp;class&nbsp;Point2DListItem&nbsp;{&nbsp;
&nbsp;&nbsp;public&nbsp;val&nbsp;&nbsp;p:&nbsp;Point2D;
&nbsp;&nbsp;public&nbsp;var&nbsp;&nbsp;next:&nbsp;Point2DListItem;
&nbsp;&nbsp;...
}
</pre>
The member <tt>next</tt> is now a reference.  Now the size required for a reference has nothing
to do with what is being referenced: an address is an address whether it refers to a hut or
a huge factory.   So in this formulation, the size of <tt>Poin2DListItem</tt> is 16 bytes for the struct <tt>p</tt>
plus however many bytes a reference requires.  
If you changed <tt>p</tt> from a <tt>val</tt> to a <tt>var</tt>,  the storage and access
to <tt>p</tt> would be the same, but now you could assign new <tt>Point2D</tt>'s to it as needed.

<div class="p"><!----></div>
<b>Some good advice for all: </b>  No language that expects high performance can allow a 4-byte integer to
consume 16 bytes or more and be accessed indirectly.  For that reason, some object oriented
languages distinguish between primitive "value" types and derived "reference" types that
are built on top of the primitive types.  Java is a good example, and X10 another.  They
took different approaches.  Java tried to be close to the physical reality of the CPU.
X10 tried to keep the value and reference types as close to one another as possible.

<div class="p"><!----></div>
X10's approach allowed it to expose the mechanism, <tt>struct</tt>s, that it uses to implement its primitive types,
so that X10 programmers can eke out efficiencies, too.  We want to warn you,
though, not overuse structs.   The inheritance hierarchy that classes provide is a powerful
mechanism for organizing information, the advantages of which in many situations, if not most,
far outweigh any performance loss.   

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Why dots and not
slashes in the package spec, since it's just a file system path?
Probably because different OS's use different separators
in those paths, so Java picked something OS neutral.
<br /><br />

</html>