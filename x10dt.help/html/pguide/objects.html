<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>A First Look At X10's Types</title>

 <h1><a name="tth_chAp1">
Chapter 2 </a><br />A First Look At X10's Types</h1>
X10's type system is not quite the same as any other object-oriented language, but it is
not really all that different, either.  We'll look at some of the main features here.  We don't
assume that you are familiar with any particular language already, but we do assume that you
have had some experience with at least one object-oriented language.  We'll make references
to Java and C++, since they are so widely taught as a first language,
but only to help compare X10with them. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;What's In An <tt>.x10</tt> File?</h2>
An <tt>.x10</tt> source file has the following structure:

<blockquote>
<b>Optional package name:</b>  The first line in the file, other than blank lines and
comments, can be a "<tt>package</tt>" declaration.  The syntax is

<blockquote><tt>package <em>packageName</em>;</tt></blockquote>
The package name, by convention, is a lower-case identifier ( letters and numbers,
starts with a letter).  You don't need a package spec, and our examples will generally
not bother with them, although we give some examples later for those unfamiliar with
what is at stake.  When no <tt>package</tt> declaration appears, the class is said to be
"in the <em>default package</em>".

<div class="p"><!----></div>
Packages were introduced so that large projects could organize
their classes, both to create some firewalls and to avoid name clashes.  Before
we explain all this, we need the next ingredient in the file, <tt>import</tt> statements.

<div class="p"><!----></div>
<b>Optional Import Statements</b>  After the package statement, if there is one,
come the <tt>import</tt> statements:

<blockquote>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>import <em>fullPackageName.className</em>;</tt><br />
or<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>import <em>fullPackageName.</em>*;</tt>
</blockquote>
We've already seen the example of importing <tt>x10.util.Random</tt>.  Notice that
the full package name is a sequence of "<tt>.</tt>" separated lower-case names,
but the class name is whatever you declared it to be: it should <em>always</em>
be capitalized.  What this statement means is that if you went back to the
file system where <tt>Random.x10</tt> was created, you would find a directory
named <tt>x10</tt> with a subdirectory <tt>util</tt> that contains the source file
<tt>Random.x10</tt>.  The same rules apply to <em>you</em>: if you have

<blockquote><tt>package a.b.c;</tt></blockquote>
at the start of your file, you must have the corresponding directory structure,
and the file must lie in the subdirectory <tt>c</tt>.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>

<div class="p"><!----></div>
The second form, with an asterisk as the final part, says: "import every class
in the package <tt>x10.util</tt>."   When to use the catch-all and when it is better
to do individual imports is a matter of taste.

<div class="p"><!----></div>
As we've said, there are two good things about packages: protection and name-clash avoidance.
Let's look at the name-clash story: we'll worry about protection later, when
we have something to protect.

<div class="p"><!----></div>
Suppose we wanted to compare <em>X10's</em> class <tt>Random</tt> against <em>our</em>
class <tt>Random</tt> in the same piece of code.  How do we tell the compiler, "here
be ours, there be theirs"?  Answer: use package name:

<blockquote>
<pre>val&nbsp;ours&nbsp;=&nbsp;new&nbsp;Random();
val&nbsp;theirs&nbsp;=&nbsp;new&nbsp;x10.lang.Random();
</pre>
</blockquote>
Assuming that <tt>Random.x10</tt> is in the same directory as this code, the 
compiler will find it there, and of course, for <tt>theirs</tt> you left no doubt
about what you meant.  By the way, if you spell out the packaging, as 
we did in the assignment to <tt>theirs</tt>, you don't also need the import
statement.  The only good reason to do so, however, is exactly in this
sort of <em>very rare</em> situation, where you need two or more variations on
a single public name, and even there it can often be avoided.

<div class="p"><!----></div>
Which brings up one final point: how does the compiler know where to look
for imports?  The answer is the command-line option <tt>-classpath</tt>.  If
no class path is specified, the compiler will look in the current directory
or in the X10standard library.  If you need it to look elsewhere, you need to
say so. We don't want to belabor the point here: X10is consistent with
Java in its use of class paths, and you can find a thorough
discussion of that in <a href="http://en.wikipedia.org/wiki/Classpath_%28Java%29">Wikipedia's
article on class paths</a> or any introduction to Java.

<div class="p"><!----></div>
<b>One or more class declarations:</b>  After the option package and import 
statements come one or more class declarations.  The overwhelming majority of the
time, exactly one appears, but there is no hard and fast rule.  One rule does
apply: there can be at most one class in the file that is declared <tt>public</tt>.
A class that is declared without that keyword,  just "<tt>class X {...}</tt>",
is accessible only for use by classes <em>in exactly the same package.</em>
This is part of the protection feature packages provide.  Public classes are usable
by anyone, anywhere. 

<div class="p"><!----></div>
If you must put several classes in one file, make sure that the first has the
same name as the source file.  On the other hand,
someone who is writing <tt>A.x10</tt>, is using the class <tt>B</tt> there, and needs to
look at the source for some reason really expects
to find <tt>B</tt> in <tt>B.x10</tt>, whether it is private to a package or not.  Be kind.

<div class="p"><!----></div>
<b>That's it:</b>  Yes, nothing more other than comments appears in a X10source file.
</blockquote>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;What's In A Class?</h2>

<div class="p"><!----></div>
The best way to see what's in a class is an example that says it all.  <tt>NoahsArk</tt>
in Figure  is it.

<div class="p"><!----></div>
<a name="tth_fIg1">
</a> <a name="fig:nark">
</a><hr />

<pre>&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;NoahsArk&nbsp;{
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;DEFAULT_SIZE&nbsp;=&nbsp;500;
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;val&nbsp;name:&nbsp;String;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;var&nbsp;passengers:&nbsp;Array[String](1);
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;var&nbsp;onBoard:&nbsp;Int&nbsp;=&nbsp;0;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(name:&nbsp;String)&nbsp;{
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(name,&nbsp;DEFAULT_SIZE});
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(name:String,&nbsp;initialCapacity:Int)&nbsp;{
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;passengers&nbsp;=&nbsp;new&nbsp;Array[String][1..initialCapacity);
12&nbsp;&nbsp;&nbsp;&nbsp;}
13&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;def&nbsp;resize(newSize:&nbsp;Int):&nbsp;NoahsArk&nbsp;{&nbsp;...&nbsp;}
14&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;addPassenger(name:&nbsp;String):&nbsp;Int&nbsp;{&nbsp;...&nbsp;}
15&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;throwOverboard(name:&nbsp;String,&nbsp;why:&nbsp;String):&nbsp;Int&nbsp;{&nbsp;...&nbsp;}
16&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;def&nbsp;showPassengers()&nbsp;{&nbsp;...&nbsp;}
17&nbsp;&nbsp;&nbsp;&nbsp;
18&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](0)]&nbsp;{&nbsp;...&nbsp;}
19&nbsp;&nbsp;&nbsp;&nbsp;
20&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;class&nbsp;FareClasses&nbsp;{}&nbsp;&nbsp;&nbsp;
21&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;class&nbsp;Galley&nbsp;{}
&nbsp;&nbsp;&nbsp;}
</pre>
<hr />


<center>Figure 1: A class with just about everything</center>

<div class="p"><!----></div>
While the original Ark may have had two of each kind, we've settled here for one of most kinds,
and as is our custom, we work our way through the code line-by-line.  First, let's agree on some
terminology:  a <em>member</em> of a class is a piece of data, as opposed to a <em>method</em>, which
is a piece of code (a function).

<dl compact="compact">
 <dt><b></b></dt>
	<dd><b>line 1:</b>  A "<tt>static</tt>" member of a class is a constant associated with the class.
We could have said "<tt>static val DEFAULT_SIZE</tt>", but the "<tt>val</tt>" is implied.  This needn't
be a literal constant, as here, but it must be an expression that the compiler can compute.

<div class="p"><!----></div>
There are
no variable static members.  This may seem a bit harsh to Java and C++ programmers,
but there is a good reason.  X10, unlike these languages, has been intended from the start
to make full use of a multi-processor system.  By restricting the data associated with a 
class to that which is put in place at the time the class is loaded, the X10 runtime is
free to copy the loaded class from <tt>Place</tt> to <tt>Place</tt> as needed, with all of the
<tt>Place</tt>'s always then seeing a consistent view of the class.</dd>

	<dd><b>line 2:</b>  An instance member that is a <tt>val</tt> is a constant that must be computed
by the constructor for the instance.  It may be initialized as part of its declaration, but that
would be unusual.  The whole point of an <em>instance</em> <tt>val</tt> is that it is a
<em>per instance</em> constant, not a <em>per class</em> one, so the constructor would 
normally use its arguments to create the instance's value.

<div class="p"><!----></div>
We've shown this instance member as <tt>public</tt>.  As with classes, we could use nothing
here, just "<tt>val name:String</tt>", and the member could then only be used by
classes in exactly the same package (directory).
There are two other keywords available: <tt>protected</tt> and <tt>private</tt>.  A protected member
is usable by any class in the same package, and by any class that <em>extends</em> the
class in which the member is declared. See section .  A private member is
just that: usable only in the class it is declared.  Thus from most widely available to least, we have

<blockquote><tt>public</tt>, <tt>protected</tt>, <em>no spec at all</em>, <tt>private</tt></blockquote></dd>

	<dd><b>lines 3 and 4:</b> Here are two instance members that are variables.  Both are private
for good reason: <tt>onBoard</tt> is the number of valid entries in the <tt>passengers</tt> array,
and the last thing we want to do is to allow the general public complete, direct access to either.
<tt>onBoard</tt> will be updated every time we add a passenger, or throw one overboard.  
<tt>passengers</tt> will be reset when we are at capacity and want to 
add another passenger.</dd>

	<dd><b>lines 6-12:</b>  We show a couple of constructors here.  We chose to make both public,
but we need not have done so: like any other method, we can restrict the availability of 
a constructor.  We could have made one private and one protected if that is really what
we needed, unusual though that would be.

<div class="p"><!----></div>
Notice the way that the first constructor invokes the second.  It is important that this call be
the first executable line in the constructor's body.</dd>

	<dd><b>line 13:</b> This is a "static" method (or, if you prefer, a "class" method).  Static
methods have access to all of the static members and methods of the class, but 
only an instance of the class may refer to instance members methods.  This method
is protected, so if <tt>DieselArk</tt> is an extension of tt NoahsArk (or simply in the
same package), it can invoke <tt>resize</tt>: the syntax is <tt>NoahsArk.resize(...)</tt>.
The moral: static methods <em>really belong to the class in which they are defined.</em></dd>

	<dd><b>lines 14-16:</b> Here we have three instance methods with varying degrees of
protection.  We'll allow anyone to add a passenger, because if the boat threatens
to sink under the weight, we can always say no.  We're a little more careful about
who throw a passenger overboard: this is pretty drastic, and different kinds of
arks may have different policies.  Finally, respecting
its customers' privacy, <tt>NoahsArk</tt> reserves to itself the right to show who is on board.</dd>

	<dd><b>line 18:</b>  You've seen <tt>main</tt> enough times that all we feel we have to say
here is that you don't need one except in a class that will begin a program's execution.</dd>

	<dd><b>line 20:</b> A static class is a static <tt>val</tt> like any other, except that it names
a class.  Within the body of <tt>NoahsArk</tt>, you write "<tt>new FareClasses()</tt>"
in order to construct an instance.  From a class <em>not</em> declared within <tt>NoahsArk</tt>,
you would need  to write "<tt>new NoahsArk.FareClasses()</tt>". In this example, we opted
not to give the class the default accessibility: same package can use, others not.
We could have chosen any of the other three.</dd>

	<dd><b>line 21:</b> This is an instance class, which, to be honest, is something you
are much less likely to need in X10than in  Java, because in X10you can
have instance variables whose values are functions, and you can create a function
to pass as an argument to another function without even giving it a name.  

<div class="p"><!----></div>
In any event, only an object
that is an instance of <tt>NoahsArk</tt> can refer directly to the class.  Importantly though,
the class itself may refer to instance members and methods from <tt>NoahsArk</tt>.
In our discussion of inheritance hierarchies ( See "extra credit:" ,
 we'll say some more
about how classes that <tt>NoahsArk</tt> uses other than <tt>NoahsArk</tt> itself, might 
have a method call that gets passed an instance of <tt>Galley</tt>.

<div class="p"><!----></div>
The term <em>inner class</em> is synonymous with what we've called an instance class.</dd>
</dl>

<div class="p"><!----></div>
We wish we could tell you that this is all there is to a class declaration.  It isn't, but it
is more than enough to get you going.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Inheritance And More</h3><a name="sec:inh">
</a>

<div class="p"><!----></div>
X10supports simple (single) inheritance: all X10classes constitute a tree, in
which the root is the class <tt>x10.lang.Object</tt>, and a class <tt>Parent</tt> is the
parent of a class <tt>Child</tt> when <tt>Child</tt>'s declaration says that it extends <tt>Parent</tt>:

<blockquote><tt>class Child extends Parent { ... }</tt></blockquote>
For example:

<pre>&nbsp;public&nbsp;class&nbsp;DieselArk&nbsp;extends&nbsp;NoahsArk&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;val&nbsp;fuelTankCapacity:&nbsp;Double;&nbsp;//&nbsp;in&nbsp;gallons
&nbsp;&nbsp;&nbsp;public&nbsp;var&nbsp;gallonsRemaining:&nbsp;Double;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(name:String;&nbsp;maxPsgrs:Int,&nbsp;tankSIze:Double)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(name,&nbsp;maxPsgrs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuelTankCapacity&nbsp;=&nbsp;gallonsRemaining&nbsp;=&nbsp;tankSIze;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;def&nbsp;throwOverboard(name:&nbsp;String,&nbsp;why:&nbsp;String):&nbsp;Int&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(name,&nbsp;why);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;more&nbsp;stuff&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;/*&nbsp;...&nbsp;more&nbsp;methods&nbsp;here&nbsp;*/
&nbsp;}
</pre>
 A <tt>DieselArk</tt> is a <tt>NoahsArk</tt> whose method of propulsion we know.  It is that sense
 that <tt>DieselArk</tt> is an extension <tt>NoahsArk</tt>: it is a <tt>NoahsArk</tt> and more.  The use
 of "extension"  is a bit strange: it is easier to be just a <tt>NoahsArk</tt>.  One also says that
"<tt>DieselArk</tt> <em>is a direct subclass of</em> <tt>NoahsArk</tt>", which seems (to the authors, at any
 rate) to be more appealing.
 
<blockquote>
 More generally, a class <tt>S</tt> is a <em>subclass</em> of another class <tt>C</tt> if there is a chain of classes
 <tt>S</tt>, <tt>S1</tt>, ..., <tt>Sn</tt>, <tt>C</tt> in which each is a <em>direct</em> subclass of the next.
</blockquote>
In declarations in which no <tt>extends</tt>
clause appears, like those for the classes <tt>MontePi</tt> or <tt>HelloWorld</tt>, 
the class extends <tt>x10.lang.Object</tt> by default.

<div class="p"><!----></div>
An instance of <tt>DieselArk</tt> will have instance members <tt>name</tt>, <tt>passengers</tt>,
and <tt>onBoard</tt>, and methods <tt>resize</tt>, <tt>addPassenger</tt>, and so on, which are said to
be <em>inherited from <tt>NoahsArk</tt></em>.
Notice that <tt>DieselArk</tt> provides its own version of the method <tt>throwOverboard</tt>, 
so rather than inheriting that method, it <em>overrides it</em>.  The expression <tt>super(name,why)</tt>
in the body of the override invokes the parent's version of <tt>throwOverboard</tt>.

<blockquote>
Be careful! While every instance of <tt>DieselArk</tt> inherits the private members
of <tt>NoahsArk</tt>, <em>only the methods already in <tt>NoahsArk</tt> have access to them.</em>
Thus, <tt>DieselArk</tt> can affect the array <tt>passengers</tt> only by invoking methods
like <tt>addPassenger</tt> that it inherits from <tt>NoahsArk</tt>.
</blockquote>
Subclasses are free to override any of the methods they inherit.

<div class="p"><!----></div>
If a method <tt>m</tt> expects an argument that is an instance of a class <tt>C</tt>,
and if <tt>D</tt> is a subclass of <tt>C</tt>, then it is okay to call <tt>m</tt> with an
instance of <tt>D</tt>.
Suppose, for example, we have a class <tt>CruiseLine</tt> whose instances have fleets of ships
that sail the world with lots of passengers.  A <tt>CruiseLine</tt> instance
might want to add a <tt>NoahsArk</tt> to its fleet, so it has a method

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;addShip(ark:&nbsp;NoahsArk)&nbsp;{&nbsp;...&nbsp;}
</pre>
Because a <tt>DieselArk</tt> <em>is</em> a <tt>NoahsArk</tt>, we can call <tt>addShip</tt>
with a <tt>DieselArk</tt> as the argument.

<div class="p"><!----></div>
A similar rule holds for return values.  If a method is supposed to return a 
<tt>NoahsArk</tt>, it can return one that just happens also to be <tt>DieselArk</tt>.

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.1.1">
2.1.1</a>&nbsp;&nbsp;Extra credit:</h4><a name="ssec:pinc">
</a>
This gets us to the point where we can answer a question we raised in a previous
section, which is "how can one class's methods get passed arguments that are
instances of another class's inner class?"  Again, the honest truth is that occasions
for using inner classes in X10 are pretty rare, so feel free to skip this on first
reading.   

<div class="p"><!----></div>
Subclassing is the key for giving a visible name to an otherwise invisible class:   

<ul>
<li> Suppose
there is a public class <tt>Kitchen</tt>, and suppose that in our declaration of <tt>NoahsArk</tt>
we had written "<tt>protected class Galley extends Kitchen { ... }</tt>" .
<div class="p"><!----></div>
</li>

<li> Let's add to <tt>NoahsArk</tt>  a private member 
"<tt>var galley:Galley</tt>" and a public method <tt>getGalley()</tt> that returns <tt>galley</tt>.
<div class="p"><!----></div>
</li>

<li> If a  class has a method whose signature is "<tt>isWellEquipped(k: Kitchen)</tt>",
and if <tt>anArk</tt> is a <tt>NoahsArk</tt>, then the call

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isWellEquipped(anArk.getGalley())
</pre>
is perfectly okay, because a <tt>Galley</tt>, wherever it came from, is a <tt>Kitchen</tt>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Concrete classes versus wishful thinking</h3>
Our declaration of <tt>NoahsArk</tt> is an example of wishful thinking, because
if you are the least bit realistic about it, an ark without any means of propulsion isn't a very
useful sort of thing, at least if you want to go anywhere in it.  On the other hand, there
are a large number of very different propulsion systems:  we've got <tt>DieselArk</tt>
already, and <tt>SteamArk</tt>, <tt>SailArk</tt>, and <tt>RowedArk</tt> are also good possibilities.

<div class="p"><!----></div>
So, <tt>NoahsArk</tt>, lacking, as it does, any means of getting anywhere, is, in a very clear sense,
not a <em>concrete</em> class: you will never see an instance that is not actually an instance
of some subclass.  Folks just don't build boats that go nowhere.

<div class="p"><!----></div>
But that is not to say that <tt>NoahsArk</tt> can't capture a lot of concrete 
information-passenger lists, fare schedules, itinerary, and so on-that
all arks share, no matter their means of propulsion.  That makes <tt>NoahsArk</tt> a good example of what is 
called an <em>abstract</em> class: a class that one does not intend to instantiate, but
which is the ultimate parent of a set of classes that one does.

<div class="p"><!----></div>
To convert <tt>NoahsArk</tt> to being an abstract class, one just adds the keyword
"<tt>abstract</tt>" to its declaration:

<pre>&nbsp;public&nbsp;abstract&nbsp;class&nbsp;NoahsArk&nbsp;\{&nbsp;...&nbsp;\}
</pre>
An abstract class is permitted to declare method signatures that it itself does not
implement, but that any of its subclasses that
are not themselves abstract <em>must</em> implement.  Here is an example:

<pre>public&nbsp;abstract&nbsp;def&nbsp;costPerPassengerMile():&nbsp;Double;
</pre>
Notice that there is no function body: there is just a trailing semicolon.
If we want to be allowed to execute "<tt>new DieselArk( ... );</tt>", that class will have to implement this
method.  In <tt>DieselArk</tt>, the declaration will look like:

<pre>public&nbsp;def&nbsp;costPerPassengerMile():&nbsp;Double&nbsp;\{&nbsp;...&nbsp;\}
</pre>
The keyword <tt>abstract</tt> does <em>not</em> appear, and the function body does.

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Interfaces: More Abstract Than Abstract</h2><a name="sec:mata">
</a>

<div class="p"><!----></div>
While <tt>NoahsArk</tt> may not be as complete as a real ark should be, it can implement a
lot of important functionality that all its progeny can use directly: a passenger list is a 
passenger list, no matter what else is different!  There are situations though, where all
that one wants to specify is functionality that has no common implementation, but
that a variety of classes will implement, each in its own way.  This sort of specification
is called an <em>interface</em>.  

<blockquote>
Those of you who are coming from a background in C++ will want to work carefully through
our discussion of interfaces, because they constitute the closest approximation
to multiple inheritance that X10provides.
</blockquote>

<div class="p"><!----></div>
A nice example of an interface is <tt>Arithmetic</tt>:

<pre>&nbsp;1&nbsp;public&nbsp;interface&nbsp;Arithmetic[T]&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;add(t:&nbsp;T}:&nbsp;T;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;subtract(t:&nbsp;T):&nbsp;T;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;multiply(t:&nbsp;T):&nbsp;T;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;divide(t:&nbsp;T):&nbsp;T;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;uminus():&nbsp;T;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;VERSION&nbsp;=&nbsp;``1.1'';
&nbsp;8&nbsp;}
</pre>
Line by line:

<dl compact="compact">

	<dd><b>line 1:</b>  Like classes, a top-most interface is either public or accessible only in the
package of which it is a part.  An interface declared within the body of a class is <em>always</em>
static (it is never per-instance and cannot refer to instance members or methods in the 
surrounding context), but it  can have any access limit: public, protected, default, or private. 

<div class="p"><!----></div>
The "<tt>[T]</tt>" following <tt>Arithmetic</tt> says that the interface is parameterized by a type
<tt>T</tt>.  We've seen this before, in the argument <tt>args</tt> for <tt>main()</tt>, whose type is
<tt>Array[String]</tt>.  The lingo of the trades is the <tt>Arithmetic</tt> is a <em>generic interface</em>,
and <em>Array</em> is a <em>generic class</em>.</dd>

	<dd><b>lines 2-7:</b> An interface may only declare abstract methods, so (unlike the story
with abstract classes), you don't need the keyword <tt>abstract</tt>.  What line 2 says is that
if a class <tt>U</tt> implements the interface <tt>Arithmetic[T]</tt>, if <tt>u</tt> is a <tt>U</tt>, and if
<tt>t</tt> is a <tt>T</tt>, then the expression <tt>u.add(t)</tt> produces a result that is a <tt>T</tt>.
In real life, we might have <tt>U</tt> some sort of integer, and <tt>T</tt> some sort of floating
point number, and the value of sum <tt>u.add)t</tt> would be again a floating point.</dd>
 <dt><b></b></dt>
	<dd><b>line 8:</b> Interfaces may also declare static constants.  One could imagine
an interface that did nothing else:

<pre>public&nbsp;interface&nbsp;IntelCpuModel1234&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;REGISTER_WIDTH&nbsp;=&nbsp;64;
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;SPEED_IN_GHZ&nbsp;=&nbsp;2.5;
&nbsp;&nbsp;&nbsp;...
}
</pre>
A class with the same information would probably be more convenient, but who knows?</dd>
</dl>
There is nothing sacred about a generic class or interface being parameterized by one type:  one can
use as many as needed: "<tt>class X[T1, T2, T3,...] {...}</tt>".  

<div class="p"><!----></div>
Here is how interfaces get used: consider the declaration

<pre>class&nbsp;Int32&nbsp;implements&nbsp;Arithmetic&nbsp;{&nbsp;...&nbsp;}
</pre>
It says that in the body of <tt>Int32</tt>, we are guaranteed to find implementations of
all of the methods specified in the interface <tt>Arithmetic</tt>, with exactly the 
argument types and return types shown there.

<div class="p"><!----></div>
We said that interfaces provide a sort of "multiple inheritance."  What we meant is that
a class may declare that implements any number of interfaces.  That is certainly reasonable:
all you are saying is that the class provides several named sets of methods.  It is, of course,
a weaker notion than multiple inheritance, since no instance members or methods are actually
inherited when a class implements an interface: all of the code is in the class or in one of its ancestors up the inheritance chain.

<div class="p"><!----></div>
Finally, just as one class can extend another, one interface can extend another-in fact, it may
extend several:

<pre>&nbsp;interface&nbsp;IA&nbsp;extends&nbsp;IB,&nbsp;IC&nbsp;{&nbsp;...&nbsp;}
</pre>
One could
say "<tt>IA</tt> is a sub-interface of <tt>IB</tt> and <tt>IC</tt>', but it just doesn't sound right:
"<tt>IA</tt> <em>refines</em> <tt>IB</tt> and <tt>IC</tt>" is somehow a lot better.  

<div class="p"><!----></div>
There is a sort of convention that interface names should begin with "<tt>I</tt>",  Suppose
for example, that we had used
<tt>INumber</tt>, instead of <tt>Arithmetic</tt>, for our interface name.  We could then have
declared  a class
named <tt>Number</tt> that implements it.  A matter of taste of course, but not an unreasonable
convention.  A variation on this theme is to append "<tt>Impl</tt>" to the name of an interface
to create the name of a concrete class that implements it:  interface <tt>XmlParser</tt>
is implemented by <tt>XmlParserImpl</tt>.  You will see both conventions widely used.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Giving Up Inheritance To Get Efficiency</h2>

<div class="p"><!----></div>
Supporting inheritance does not come with costs when the program runs.  You can see
why most easily by looking at a huge arrays.  
Suppose that an array <tt>arr</tt> is declared as an <tt>Array[T]</tt>.

<blockquote>
Any given entry in the array can actually
have been declared to be a <tt>U</tt>, where <tt>U</tt> is <em>any</em> subclass of <tt>T</tt>.
We don't know how the entry might be used-later on, it might be important that
this is a <tt>U</tt> and not just a <tt>T</tt>-so for every entry,
we have to keep both both a reference
to the object itself <em>and</em> a reference to the object's class information.  If there are
<tt>N</tt> entries in the array, and if the reference to the class uses <tt>k</tt> bytes,
we just used <tt>k*N</tt> bytes to store this data.  And <tt>N</tt> is <em>big</em>!

<div class="p"><!----></div>
Furthermore, whenever
we execute a method call <tt>arr(k).fcn(...)</tt>, we have to use the class information
for <tt>array(k)</tt> to find the code for the method: remember that subclasses can override
the methods of their parents, so we will only know at runtime what to look for.
This slows down every method call.
</blockquote>

<div class="p"><!----></div>
The additional overhead explains why a performance-oriented language avoids using
the normal class hierarchy for primitive types like 32-bit integers.

<div class="p"><!----></div>
<b>Major design issue</b> How much of what classes give us can we keep without
giving up any substantial amount of efficiency?

<div class="p"><!----></div>
There are several issues here: the serial issues-don't wast space, and don't waste time-
and the distribution issue-don't create potential inconsistencies between what one
processor thinks the value of the "thing" is and another thinks, so that communication
between them is required to maintain integrity.

<div class="p"><!----></div>
In short: what we need are values whose type is exactly what they are declared to be,
and not some "improvement."  X10 calls these things (rather unfortunately) "<tt>struct</tt>s".
They bear about the same relation to the familiar <em>C</em> <tt>struct</tt> as class declarations
do, but that's the way it is.

<div class="p"><!----></div>
As an example of a <tt>struct</tt>, X10 style, let us do a variation on our class <tt>Point2D</tt>.

<pre>&nbsp;1&nbsp;&nbsp;public&nbsp;struct&nbsp;Point2D&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;x:&nbsp;Double;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;y:&nbsp;Double;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(x:&nbsp;Double,&nbsp;y:&nbsp;Double)&nbsp;{
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x&nbsp;=&nbsp;x;&nbsp;&nbsp;this.y&nbsp;=&nbsp;y;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;magnitude()&nbsp;=&nbsp;x*x&nbsp;+&nbsp;y*y;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;abs&nbsp;=&nbsp;Math.sqrt(magnitude());
&nbsp;9&nbsp;}
</pre>
As usual, the line-by-line:

<div class="p"><!----></div>

<dl compact="compact">

	<dd><b>line 1:</b> The accessibility rules for a struct are the same as for a class.  We
chose "<tt>public</tt>" for the example, but the default is also possible, and if the struct is
declared in a class body, <tt>protected</tt> and <tt>private</tt> may also be used. 

<div class="p"><!----></div>
Structs may
be generic-that is, may have type parameters-although this one does not.</dd>

	<dd><b>lines 2 and 3:</b>  The instance members of a struct are always <tt>val</tt>s.
In fact, the best way to think of a whole instance of a struct is as a value, just as you would
think of an <tt>Int</tt> as a value: one can have variable <tt>n</tt> whose value is an <tt>Int</tt>, and <tt>n</tt>'s
value may be different <tt>Int</tt>s at different times, but there is nothing within a particular <tt>Int</tt> itself
that you modify.

<div class="p"><!----></div>
One consequence of this is that once the constructor for a struct returns, none
of its instance members can be modified.   Another is that if <tt>s1</tt> and <tt>s2</tt> are
two instances a the same struct, then "<tt>s1 == s2</tt>" means what you think it 
means: their instance members have identical values.  (Remember that for 
instances of a class, ""  is used to determine whether exactly the same object
( the same piece of storage) appears on both sides, not just two objects with instance members
having identical values: the method call <tt>o1.equals(o2)</tt> does that weaker check for
objects.</dd>

	<dd><b>lines 6 and 7</b> Unlike their C namesakes, X10 structs can declare methods.
We've shown both as public here, but both private and default (package private) can be used.
"Protected" makes no sense, since it just weakens the default by also allowing subclasses access,
and  structs <em>never</em> have subclasses.</dd>
</dl>

<div class="p"><!----></div>
We did not show it, but structs can have static methods and members.  In principle, one can
also define static classes in the body of a struct, just as one can in a class.  How often this is
needed is a good question, though: probably not often.   

<div class="p"><!----></div>
The rules for declaring structs are such that the compiler can determine the size of
an instance from the declaration.  The reason is storage efficiency:  once the size is
known, no more space need be allocated than is need to store the value in memory,
and at runtime, we don't have to carry around size information for every instance.

<div class="p"><!----></div>
For example, our <tt>Point2D</tt> with its two <tt>Double</tt>s requires exactly 16 = 2*8
bytes to store an instance.  If we also had to store a pointer to its "class" with
every instance, that would
add at least 4 and maybe up to 12 bytes or even more, depending on what we had to store in
addition to the raw address, and on how many bytes you need for even the raw address: once
memory is measured in gigabytes, at least 6 bytes are needed just for an address.
Yes: 25<br />
<div class="p"><!----></div>
There is one more restriction to what can go into a struct that is critical:
<em>an instance <tt>s</tt> of a struct <tt>S</tt> cannot
have an instance member <tt>s.nextS</tt> that is itself also an <tt>S</tt></em>.  To C programmers
in particular, this may seem a bit weird-how you form lists of these things?  But
remember: <em>instances of structs, unlike instances of classes, are values, <em>not</em> references</em>. 
It may help to understand this if we try to declare a struct <tt>Point2DListItem</tt>.  It has two members,
a <tt>Point2D</tt>, <tt>p</tt>, and a
<tt>Point2DListItem</tt>, <tt>next</tt> which is <tt>p</tt>'s successor in the list.
How big is a <tt>Point2DListItem</tt>?   Well, a <tt>Point2D</tt> itself is
is 16 bytes, so if <tt>sizeOfPLI</tt> is the
size of a <tt>Point2DListItem</tt>,  then adding the sizes of the two instance members, we get a total

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeOfPLI&nbsp;==&nbsp;16&nbsp;+&nbsp;sizeofPLI
</pre>
Oops! Subtracting <tt>sizeOfPLI</tt> from both sides yields <tt>0 == 16</tt>!  

<div class="p"><!----></div>
<b>Aside for C/C++ programmers: </b> The way a C programmer uses structs to create lists is through
a declaration like "<tt>struct S {int a; int; b;</tt>  <tt>struct S *next}</tt>".
In other words,, you put a reference to a <tt>struct S</tt> in the body of the struct, and not a <tt>struct S</tt> itself.
The equivalent X10 would be to put a <tt>var</tt> (and not a <tt>val</tt>) of type <tt>S</tt> in the body, but that won't
work, because in X10, a <tt>var</tt> whose type is a struct is never a reference, no matter whether
the <tt>var</tt> appears on its own as local variable or as a member of a class or struct.  And X10
has no explicit notion of "pointer."

<div class="p"><!----></div>
So how <em>does</em> one design a struct that is a list of structs?  The short answer is: one should not.
Lists are introduced because a collection of uncertain eventual size is being grown, and one
therefore has to forego the efficiency of a pre-allocated array.  One pays the overhead of following a 
reference to the next item (rather than just bumping an array index) so as to have the freedom
to grow and shrink the list efficiently as needed.  In other words: lists are by their very nature dynamic.
The whole point of a struct is that it is static: once constructed it cannot be modified.  Let's return
to our <tt>Point2DListItem</tt>.  If we declare it as follows, there is no problem:

<pre>&nbsp;class&nbsp;Point2DListItem&nbsp;{&nbsp;
&nbsp;&nbsp;public&nbsp;val&nbsp;&nbsp;p:&nbsp;Point2D;
&nbsp;&nbsp;public&nbsp;var&nbsp;&nbsp;next:&nbsp;Point2DListItem;
&nbsp;&nbsp;...
}
</pre>
The member <tt>next</tt> is now a reference.  Now the size required for a reference has nothing
to do with what is being referenced: an address is an address whether it refers to a hut or
a huge factory.   So in this formulation, the size of <tt>Poin2DListItem</tt> is 16 bytes for the struct <tt>p</tt>
plus however many bytes a reference requires.  
If you changed <tt>p</tt> from a <tt>val</tt> to a <tt>var</tt>,  the storage and access
to <tt>p</tt> would be the same, but now you could assign new <tt>Point2D</tt>'s to it as needed.

<div class="p"><!----></div>
<b>Some good advice for all: </b>  No language that expects high performance can allow a 4-byte integer to
consume 16 bytes or more and be accessed indirectly.  For that reason, some object oriented
languages distinguish between primitive "value" types and derived "reference" types that
are built on top of the primitive types.  Java is a good example, and X10 another.  They
took different approaches.  Java tried to be close to the physical reality of the CPU.
X10 tried to keep the value and reference types as close to one another as possible.

<div class="p"><!----></div>
X10's approach allowed it to expose the mechanism, <tt>struct</tt>s, that it uses to implement its primitive types,
so that X10 programmers can eke out efficiencies, too.  We want to warn you,
though, not overuse structs.   The inheritance hierarchy that classes provide is a powerful
mechanism for organizing information, the advantages of which in many situations, if not most,
far outweigh any performance loss.   

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Why dots and not
slashes in the package spec, since it's just a file system path?
Probably because different OS's use different separators
in those paths, so Java picked something OS neutral.
<br /><br />

</html>