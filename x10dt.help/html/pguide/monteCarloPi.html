<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>Two CPUs Are Better Than One</title>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Two CPUs Are Better Than One</h2>

<div class="p"><!----></div>
The point of X10 is concurrent programming: giving you control over clusters of 
multiprocessors.   We'll get started on this by parallelizing a simple piece of serial
code that computes an approximation to &#960;.  Along the way, we'll introduce some
more of X10's declarative syntax and write our first loops.

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;&#960; via Monte Carlo</h3>

<div class="p"><!----></div>
The unit circle is the set of points (x,y) in the plane that satisfy x<sup>2</sup> + y<sup>2</sup>  &#8804; 1,
and its area is &#960;.  We are going to explore a particularly simple method of estimating
&#960;.  Our starting point is the observation that  
one quarter of the unit circle lies in the unit square, which is the set of (x,y) that satisfy
0  &#8804; x,y  &#8804; 1.  The unit square has area 1, and the fraction of in the unit circle has
area &#960;/4.

<div class="p"><!----></div>
Now imagine picking points at random in the unit square.  What is the
probability that a given pick also lies in the unit circle?  If the points are really random, the
answer ought to be the fraction of the square that lies in the unit circle, namely: &#960;/4.

<div class="p"><!----></div>
One way to estimate &#960;/4, then, is to pick a
large number of points (x,y) in the unit square at random and see what fraction
actually land in the unit circle.  This sort of process is called a "Monte Carlo" algorithm.  

<div class="p"><!----></div>
If ever there
were an easily parallelized type of algorithm, Monte Carlo is it: if we have 1,000
processors, we get let each generate points independently, and at the end, we
just have to merge the results.  The only trick is to make sure that each of the 1,000
processors starts in a way genuinely random with respect to the others, so that
they don't just duplicate each other's efforts. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Getting Started: A Serial Version</h3>
Let's look first, though, at a serial version, which is shown in Figure , 
because it introduces a couple 
of basic X10 idioms that we'll need in the parallel code: the use of <tt>val</tt> and
<tt>var</tt> to introduce declarations, and one of the most commonly needed forms of
X10's <tt>for</tt> loop.

<div class="p"><!----></div>
<a name="tth_fIg1">
</a> <a name="fig:mcpi">
</a><hr />

<pre>
&nbsp;1&nbsp;import&nbsp;x10.io.Console;
&nbsp;2&nbsp;import&nbsp;x10.util.Random;
&nbsp;3&nbsp;public&nbsp;class&nbsp;MonteCarloPi&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;val&nbsp;N&nbsp;=&nbsp;10000;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;inCircle:&nbsp;Double&nbsp;=&nbsp;0.0;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;=&nbsp;N;&nbsp;j++)&nbsp;&nbsp;{
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;x&nbsp;=&nbsp;r.nextDouble();
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;y&nbsp;=&nbsp;r.nextDouble();
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(x*x&nbsp;+y*y&nbsp;&lt;=&nbsp;1.0)&nbsp;inCircle&nbsp;++;
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pi&nbsp;=&nbsp;4&nbsp;*&nbsp;(inCircle&nbsp;/&nbsp;N);
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;"+pi);
15&nbsp;&nbsp;&nbsp;&nbsp;}
16&nbsp;}

</pre>
<hr />


<center>Figure 1: Serial Monte Carlo Approximation of Pi</center>

<div class="p"><!----></div>
Let's look at the declarations first.  There are two keywords, <tt>val</tt>
for naming values, and <tt>var</tt> for naming variables:

<dl compact="compact">

	<dd>val:
 A declaration like "<tt>val N = 10000;</tt>"  in line 4 says that <tt>N</tt> names a
<em>value</em>, in this case,  <tt>10000</tt>.  

<div class="p"><!----></div>
One cannot assign a new value to 
<tt>N</tt> later on in the code: it is a constant, in the same way the <tt>const</tt> is used in Java and C.

<div class="p"><!----></div>
As with return values, the compiler will happily figure out the type of a <tt>val</tt>,
but if you wish, you can provide it.  For example, we could have written
line 6 as

<blockquote><tt>val r:Random = new Random(); </tt></blockquote>
In this case, there's not much point, though, because
adding "<tt>:Random</tt>" helps neither human nor compiler. 

<div class="p"><!----></div>
The initializer for a <tt>val</tt> may be any legal  X10 expression that can be
evaluated at run-time-they need not be compile-time constants.  Lines 9,
10, and 13 are all examples of run-time values as initializers.</dd>

	<dd>var: 
A declaration like "<tt>var result:Double == 0.0;</tt>"  says that
<tt>result</tt> names some storage that holds a value of type <tt>Double</tt>
that is initially <tt>0.0</tt>, but that 
may be updated as the code runs.  In the lingo of the trade, one
says that <tt>result</tt> "refers" to a "<tt>Double</tt>".  

<div class="p"><!----></div>
<tt>Double</tt> values are double-precision floating points, exactly like Java/C++'s
<tt>double</tt>.  In fact,  X10 also allows you to use <tt>int</tt>, <tt>double</tt>, and so on.  So if
you have a lingering fondness for these names, or just don't like typing upper-case
characters, feel free to use the good old names.  Truth be told, though, X10's
convention has the virtue that it is consistent with proper names for types always being
capitalized.

<div class="p"><!----></div>
Sadly, you need to supply
the type for a <tt>var</tt> even when an initial value is provided, as it is here.
The rationale is a bit involved, so we ask you just to take our word for it that 
the compiler does need to be told the type of every <tt>var</tt>.</dd>
</dl>

<div class="p"><!----></div>
The other new ingredient in the code is the "<tt>for</tt>"  loop, lines 8 through 12.

<ul>
<li>The syntax in line 8 should be familiar.  It begins with the declaration and initialization
of the loop
variable <tt>j</tt>, "<tt>var j:Int = 1</tt>".  Important: you need the "<tt>var</tt>", because that
tells the compiler you want to declare a new variable. " <tt>j:Int = 1</tt>" by itself
won't do: the compiler will complain that <tt>j</tt> is a value, not a variable.
<div class="p"><!----></div>
</li>

<li>
As you might guess, "<tt>Int</tt>" is X10's
32-bit integer type.
<div class="p"><!----></div>
</li>

<li>
The declaration for <tt>j</tt> is followed by the test "<tt>j &lt;= N</tt>" .  This expression is
evaluated at each iteration (including the first!) and the loop body will be executed
only so long as it evaluates to "true."
<div class="p"><!----></div>
</li>

<li>
The third expression in line 8, "<tt>j++</tt>", is the re-initialization of the loop variable.  
X10's binary and unary operators are the same as Java and C++, so things like
"<tt>-=</tt>" and "<tt>++</tt>" mean exactly what you expect.
<div class="p"><!----></div>
</li>

<li>
Each time through the loop, we are calling the random number generator
<tt>r</tt> twice to get the coordinates of a point (lines 9 and 10).  Happily, <tt>r.nextDouble</tt>
returns a value between 0 and 1, so we can use it "as is."   In line 11,
we check whether the point is in the unit circle, and if so, we bump
<tt>inCircle</tt> by 1.
<div class="p"><!----></div>
</li>

<li>
 As it happens here, we don't need <tt>j</tt> in the loop, but we do want to emphasize
 that <em>the scope of <tt>j</tt>'s declaration is the loop and nothing but the loop</em>, so when
 when leave the loop, <tt>j</tt> will be unavailable.  There is no rule, however, that says
 you <em>have</em> to declare the loop variable in the <tt>for</tt> statement.  If you need
 the value once the loop completes, just declare it in a context surrounding the 
 loop, and set it to its initialize value wherever it is convenient to do so, <em>e.g.</em>:
 
<pre>
&nbsp;var&nbsp;j:&nbsp;int&nbsp;=&nbsp;1;
&nbsp;for(&nbsp;;&nbsp;j&nbsp;&lt;=&nbsp;N;&nbsp;j++)&nbsp;{&nbsp;...&nbsp;}
&nbsp;Console.OUT.println("Is&nbsp;"+j+"&nbsp;==&nbsp;"+(N+1)+"?");
&nbsp;
</pre>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
On exit from the loop at line 13, <tt>inCircle/N</tt> is the fraction of points
in the circle, which is going to be a positive number less than 1, so we
have to use a <tt>Double</tt> (or if we don't care about the precision, a <tt>Float</tt>)
to capture the value.  
That's why we made <tt>inCircle</tt> a "<tt>Double</tt>" in line 7.
When we do the division here, the compiler will arrange to convert
<tt>N</tt> to a <tt>Double</tt>, too, and will use double precision floating
point division.  

<div class="p"><!----></div>
Suppose we had said to ourselves, "bumping a <tt>Double</tt> by 1 inside that
loop has got to
be more expensive than bumping an <tt>Int</tt>.  So let's declare <tt>inCircle</tt> to be
an <tt>Int</tt>."  That's fine, but when we get to line 13, we have to be careful to
convert it to a <tt>Double</tt>:

<pre>13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pi&nbsp;=&nbsp;4&nbsp;*&nbsp;(inCircle&nbsp;as&nbsp;Double&nbsp;/&nbsp;N);
</pre>
Of course, we could also have been polite and written "4.0" instead of "4.",
which would have saved the compiler some work and might have been
a better for readability.  Adding an "<tt>as Double</tt>" to force the conversion
of <tt>N</tt> explicitly would also have helped the compiler, and is a perfectly reasonable 
thing to do, but probably doesn't make the whole expression more readable.

<div class="p"><!----></div>
Time to try compiling and running the code.  Here is our console log:

<pre>
%&nbsp;x10c&nbsp;MonteCarloPi.x10&nbsp;
%&nbsp;x10&nbsp;MonteCarloPi
The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;3.1368

</pre>
Not a brilliant guess at &#960;, but we didn't really try all that many points.  Your
answer might vary: in fact, the answer will vary with each run if, whenever
<tt>Random</tt> creates a new generator, it
chooses a new starting point for computing its values.
The first two digits, 3.1, though, should be stable.  Good luck!

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.3">
1.3</a>&nbsp;&nbsp;Putting Lipstick On A Pig</h3>

<div class="p"><!----></div>
There are some pretty primitive aspects to our first cut at &#960;.  In this section
we'll introduce a few features of X10 that will help us pretty up the code a little
bit.

<div class="p"><!----></div>
To begin with, that "<tt>static val N = 10000;</tt>" in line 4 is really, truly primitive. 
We have a perfectly good set of command line arguments.  Why not use the first, if
supplied, to set the number of points to try?  That would have let us try 1,000,000
points right away to see how much better we could do than 10,000.
The code we need is simple enough:

<pre>
&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;&nbsp;val&nbsp;N&nbsp;=&nbsp;args.size()&nbsp;&#62;&nbsp;0&nbsp;?&nbsp;Int.parse(args(0))&nbsp;:&nbsp;10000;

</pre>
Some comments:
 
<ul>
<li> The command line arguments come in in the array <tt>args</tt>.  The declaration
 "<tt>args:Array[String](1)</tt>" should be read: "<tt>args</tt> is a value whose type
 is an array of strings indexed by a single integer."   X10 arrays, unlike Java
 or C++ arrays, may be indexed by arbitrarily many integers, so you have to 
 tell the compiler what sort of indexing you want.  So don't be confused here: the
 "<tt>(1)</tt>" is not the size of the array: it is how you index it.
<div class="p"><!----></div>
</li>

<li>
 X10 actually uses a call to the method
 <tt>size</tt> to get the number of elements in an array, and uses
 ordinary parentheses to access array elements.  
 Thus, <tt>args(0)</tt> is the first element in the <tt>args</tt> array.  Arrays
 are a whole subject unto themselves in X10, which we will get to in ????.
 % 
</li>
</html>