<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Function types</title>
</head>

<body>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Function types</h2>
<a name="FunctionTypes">
</a>
<a name="FunctionType">
</a>



<div class="p"><!----></div>
X10 functions, like mathematical functions, take some arguments and produce a
result.  X10 functions, like other X10 code, can change mutable state and
throw exceptions.  Closures (&#167;) and method
selectors (&#167;) are of function type.
Typical functions are the reciprocal function: 
<pre>
val recip = (x : Double) =&#62; 1/x;
</pre>
and a function which increments  element <b>i</b> of a rail <b>r</b>, or throws an exception
if there is no such element, where, for the sake of example, we constrain the
type of <b>i</b>:  
<pre>
val inc = (r:Rail[Int]!, i: Int{i != r.length}) =&#62; {
  if (i &lt; 0 </td><td width="150">
&#124;&#124; i &#62;= r.length) throw new DoomExn();
  r(i)++;
};
</pre>

<div class="p"><!----></div>
So, in general, a function type needs to list the types 
"T<sub>i</sub>"
of all the formal parameters,
and their distinct names "x<sub>i</sub>" in case other types refer to them; a
constraint 
<b>c</b> on the
function as a whole; a return type <b>T</b>; and the exceptions 
that the function might throw when applied: 

<div class="p"><!----></div>
<em><em>Limitation</em> The <b>throws</b> clause is not currently implemented.  Also,
some method modifiers (<b>safe</b>, <b>atomic</b>, etc.) will apply to function
types as well.</em>

<div class="p"><!----></div>
<pre>
(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} =&#62; T
        throws EX<sub>1</sub>, ..., EX<sub>k</sub>
</pre>

<div class="p"><!----></div>
The names "x<sub>i</sub>" of the formal parameters are not relevant.  Types
which differ only in the names of formals (following the usual rules for
renaming of variables, as in &#945;-renaming in the &#955; calculus
) are considered equal.  , 
<b>(a:Int, b:Rail[String]{b.length==a}) =&#62; Boolean</b>
and 
<b>(b:Int, a:Rail[String]{a.length==b}) =&#62; Boolean</b>
are equivalent types.

<div class="p"><!----></div>
The formal parameter names are in scope from the point of definition to the
end of the function type-they may be used in the types of other formal parameters
and in the return type. 
Value parameters names may be
omitted if they are not used; the type of the reciprocal function can be
written as
<b>(Double)=&#62;Double</b>. 

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">FunctionType ::= TypeParameters<sup>?</sup>&nbsp;<b>(</b> Formals<sup>?</sup>&nbsp;<b>)</b> Constraint<sup>?</sup>&nbsp;
<b>=&#62;</b> Type Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">TypeParameters ::= <b>[</b> TypeParameter ( <b>,</b> TypeParameter
)<sup>*</sup>&nbsp;<b>]</b> </td></tr>
<tr><td align="right">TypeParameter ::= Identifier </td></tr>
<tr><td align="right">Formals ::= Formal ( <b>,</b> Formal )<sup>*</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A function type is covariant in its result type and contravariant in
each of its argument types. That is, let 
<b>S1,...,Sn,S,T1,...Tn,T</b> be any
types satisfying <b>Si &lt;: Ti</b> and <b>S &lt;: T</b>. Then
<b>(x1:T1,...,xn:Tn){c}=&#62;S</b> is a subtype of
<b>(x1:S1,...,xn:Sn){c}=&#62;T</b>.

<div class="p"><!----></div>
A class or struct definition may use a function type 
<b>F = (x1:T1,...,xn:Tn){c}=&#62;T</b> in its 
implements clause; 
this is equivalent to implementing an interface requiring the single method
<b>def apply(x1:T1,...,xn:Tn){c}:T</b>. 
Similarly, an interface
definition may specify a function type <b>F</b> in its <b>extends</b> clause.
Values of a class or struct implementing <b>F</b> 
can be used as functions of type <b>F</b> in all ways.  
In particular, applying one to suitable arguments calls the <b>apply</b>
method. 

<div class="p"><!----></div>
A function type <b>F</b> is not a class type in that it does not extend any
type or implement any interfaces, or support equality tests. 
<b>F</b> may be implemented, but not extended, by a class or function type. 
Nor is it a struct type, for it has no predefined notion of equality.

<div class="p"><!----></div>

</body>
</html>