<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Operations on arrays</title>
</head>

<body>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Operations on Arrays and Distributed Arrays</h2>

<div class="p"><!----></div>
Arrays and distributed arrays share many operations.
In the following, let <b>a</b> be an array with base type T, and <b>da</b> be an
array with distribution <b>D</b> and base type <b>T</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Element operations</h3>
The value of <b>a</b> at a point <b>p</b> in its region of definition is
obtained by using the indexing operation <b>a(p)</b>. 
The value of <b>da</b> at <b>p</b> is similarly
<b>da(p)</b>
This operation
may be used on the left hand side of an assignment operation to update
the value: 
<b>a(p)=t;</b>
and 
<b>da(p)=t;</b>
The operator assignments, <b>a(i) += e</b> and so on,  are also
available. 

<div class="p"><!----></div>
It is a runtime error to use either <b>da(p)</b> or <b>da(p)=v</b> at a place
other than <b>da.dist(p)</b>, <em>viz</em> at the place that the element exists. 

<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Constant promotion</h3><a name="ConstantArray">
</a>


<div class="p"><!----></div>
For a region <b>R</b> and a value <b>v</b> of type <b>T</b>, the expression 
<b>new Array[T](R, v)</b> 
produces an array on region <b>R</b> initialized with value <b>v</b>
Similarly, 
for a distribution <b>D</b> and a value <b>v</b> of
type <b>T</b> the expression 
<b>DistArray.make[T](D, (Point(D.rank))=&#62;v)</b>
constructs a distributed array with
distribution <b>D</b> and base type <b>T</b> initialized with <b>v</b>
at every point.

<div class="p"><!----></div>
Note that <b>Array</b>s are constructed by constructor calls, but
<b>DistArrays</b> are constructed by calls to the factory methods
<b>DistArray.make</b>. This is because <b>Array</b>s are fairly simple objects,
but <b>DistArray</b>s may be implemented by different classes for different
distributions. The use of the factory method gives the library writer the
freedom to select appropriate implementations.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Restriction of an array</h3>

<div class="p"><!----></div>
Let <b>R</b> be a sub-region of <b>da.region</b>. Then 
<b>da </td><td width="150">
&#124; R</b>
represents the sub-<b>DistArray</b> of <b>da</b> on the region <b>R</b>.
That is, <b>da </td><td width="150">
&#124; R</b> has the same values as <b>da</b> when subscripted by a
point in region <b>R &amp;&amp; da.region</b>, and is undefined elsewhere.
`
Recall that a rich set of operators are available on distributions
(&#167;<a href="#XtenDistributions">4</a>) to obtain sub-distributions
(e.g. restricting to a sub-region, to a specific place etc).

<div class="p"><!----></div>

     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Operations on Whole Arrays</h3>

<div class="p"><!----></div>

<b>Pointwise operations&nbsp;&nbsp;</b><a name="ArrayPointwise">
</a>
The unary <b>map</b> operation applies a function to each element of
a distributed or non-distributed array, returning a new distributed array with
the same distribution, or a non-distributed array with the same region.
For example, the following produces an array of cubes: 
<pre>
val A = new Array[Int](1..10, (p:Point(1))=&#62;p(0) );
// A = 1,2,3,4,5,6,7,8,9,10
val cube = (i:Int) =&#62; i*i*i;
val B = A.map(cube);
// B = 1,8,27,64,216,343,512,729,1000
</pre>

<div class="p"><!----></div>
A variant operation lets you specify the array <b>B</b> into which the result
will be stored.   
<pre>
val A = new Array[Int](1..10, (p:Point(1))=&#62;p(0) );
// A = 1,2,3,4,5,6,7,8,9,10
val cube = (i:Int) =&#62; i*i*i;
val B = new Array[Int](A.region); // B = 0,0,0,0,0,0,0,0,0,0
A.map(B, cube);
// B = 1,8,27,64,216,343,512,729,1000
</pre>

This is convenient if you have an already-allocated array lying around unused.
In particular, it can be used if you don't need <b>A</b> afterwards and want to
reuse its space:
<pre>
val A = new Array[Int](1..10, (p:Point(1))=&#62;p(0) );
// A = 1,2,3,4,5,6,7,8,9,10
val cube = (i:Int) =&#62; i*i*i;
A.map(A, cube);
// A = 1,8,27,64,216,343,512,729,1000
</pre>

<div class="p"><!----></div>
The binary <b>map</b> operation takes a binary function and
another
array over the same region or distributed array over the same  distribution,
and applies the function 
pointwise to corresponding elements of the two arrays, returning
a new array or distributed array of the same shape.
The following code adds two distributed arrays: 
<pre>
static def add(da:DistArray[Int], db: DistArray[Int]{da.dist==db.dist})
    = da.map(db, Int.+);
</pre>

<div class="p"><!----></div>

<b>Reductions&nbsp;&nbsp;</b><a name="ArrayReductions">
</a>

<div class="p"><!----></div>
Let <b>f</b> be a function of type <b>(T,T)=&#62;T</b>.  Let
<b>a</b> be an array over base type <b>T</b>.
Let <b>unit</b> be a value of type <b>T</b>.
Then the
operation <b>a.reduce(f, unit)</b> returns a value of type <b>T</b> obtained
by performing <b>f</b> on all points in <b>a</b> in some unspecified order
(perhaps in parallel).  In order to guarantee that the result is precisely
determined, the  function <b>f</b> should be associative and
commutative, and the value <b>unit</b> should satisfy
<b>f(unit,x)</b> <b>==</b> <b>x</b> <b>==</b> <b>f(x,unit)</b>.
For example, 
<pre>
val a = [1,2,3,4];
val sum = a.reduce(Int.+, 0); 
assert(sum == 10); // 10 == 1+2+3+4
</pre>

<div class="p"><!----></div>
<b>DistArray</b>s have the same operation.
This operation involves communication between the places over which
the <b>DistArray</b> is distributed. The X10 implementation guarantees that
only one value of type <b>T</b> is communicated from a place as part of
this reduction process.

<div class="p"><!----></div>

<b>Scans&nbsp;&nbsp;</b><a name="ArrayScans">
</a>

<div class="p"><!----></div>
Let <b>f:(T,T)=&#62;T</b>, <b>unit:T</b>, and <b>a</b> be an <b>Array[T]</b> or
<b>DistArray[T]</b>.  Then <b>a.scan(f,unit)</b> is the array or distributed
array of type <b>T</b> whose ith element in canonical order is the
reduction by <b>f</b> with unit <b>unit</b> of the first i elements of
<b>a</b>. 

<div class="p"><!----></div>
This operation involves communication between the places over which the
distributed array is distributed. The X10 implementation will endeavour to
minimize the communication between places to implement this operation.

<div class="p"><!----></div>
Other operations on arrays, distributed arrays, and the related classes may be
found in the <b>x10.array</b> package.

<br /><br />

</body>
</html>