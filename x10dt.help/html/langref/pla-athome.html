<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>athome: Returning Values from at Blocks</title>
</head>

<body>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;<tt>athome</tt>: Returning Values from <tt>at</tt>-Blocks</h2>
<a name="sect:athome">
</a>


<div class="p"><!----></div>
The <b>at(p;F)S</b> construct renders external variables unavailable within
<b>S</b>.  However, it is often useful to transmit values back from <b>S</b>,
and store them in external variables. 

<div class="p"><!----></div>
The <b>athome(V;F)S</b> construct provides
this ability.  <b>V</b> is a list of variables, which must all be defined at
the same place.  <b>athome(V;F)S</b> goes to the place where the variables are
defined, copying <b>F</b> as for <b>at(p;F)S</b>, and executes <b>S</b> -
allowing reading, assignment and initialization of the listed variables in
<b>V</b>. 

<div class="p"><!----></div>
<b>V</b>, the list of variables, may include one or more variables.  It is a
static error if X10 cannot determine that all the variables in the list are
defined at the same place.

<div class="p"><!----></div>
<b>athome</b> allows returning multiple pieces of information from an
<b>at</b>-statement.  In the following example, we return two data: 
one as a <b>val</b> named <b>square</b>, and the other as an addition in to a
partially-computed polynomial named <b>poly</b>.  
<pre>
static def example(a: Int, mathProc: Place) { 
  val square : Int;
  var poly : Int = 1 + a; // will be 1+a+a*a
  at(mathProc; a) {
    val sq = a*a; 
    athome(square, poly; sq) {
       square = sq;  // initialization
       poly += sq;   // read and update
    }
  return [square, poly];
  }
</pre>


<div class="p"><!----></div>
The abbreviated form <b>athome S</b> is equivalent to <b>athome(V;F)S</b>,
where: 

<ul>
<li> <b>V</b> is the list of all variables appearing on the left-hand side of
      an assignment or update statement in <b>S</b>, excluding those which
      appear inside an <b>at</b> or <b>athome</b> statement in <b>S</b>;
<div class="p"><!----></div>
</li>

<li> <b>F</b> is the same as for <b>at(p)S</b> (&#167;<a href="#sect:copy-spec">3.1</a>)
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Much as the blanket <b>at</b> construct <b>at(p)S</b> is convenient for
executing a small code body at another place, the blanket <b>athome</b>
construct <b>athome S</b> is convenient for returning a result or two.   The
preceding example could have been written using blanket statements.

<div class="p"><!----></div>
<pre>
static def example(a: Int, mathProc: Place) { 
  val square : Int;
  var poly : Int = 1 + a; // will be 1+a+a*a
  at(mathProc) {
    val sq = a*a; 
    athome {
       square = sq;  // initialization
       poly += sq;   // read and update
    }
  return [square, poly];
  }
</pre>


<div class="p"><!----></div>
<b>Design:</b> It is not fundamentally essential to distinguish <b>at</b> from
<b>athome</b>.  <b>at(p;F)S</b> could allow writing to variables whose homes are
known at compile-time to be equal to <b>p</b>.  Indeed, in earlier versions of
X10, it did so.    This required an idiom in which programmers had to manage
the home locations of variables directly, and keep track of which home
location corresponded to which variable.  The <b>athome</b> construct makes
this idiom more convenient. 
</body>
</html>