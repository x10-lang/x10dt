<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Inner Classes</title>
</head>

<body>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Inner Classes</h2>
<a name="InnerClasses">
</a>



<div class="p"><!----></div>
Non-static nested classes are called <em>inner classes</em>. An inner class
instance can be thought of as a very elaborate member of an object - one
with a full class structure of its own.   The crucial characteristic of an
inner class instance is that it has an implicit reference to an instance of
its containing class.  

<div class="p"><!----></div>
This feature is particularly useful when an instance of the inner class makes
no sense without reference to an instance of the outer, and is closely tied to
it.  For example, consider a range class, describing a span of integers m
to n, and an iterator over the range.  The iterator might as well have
access to the range object, and there is little point to discussing
iterators-over-ranges without discussing ranges as well.
In the following example, the inner class <b>RangeIter</b> iterates over the
enclosing <b>Range</b>.  

<div class="p"><!----></div>
It has its own private cursor field <b>n</b>, telling
where it is in the iteration; different iterations over the same <b>Range</b>
can exist, and will each have their own cursor.
It is perhaps unwise to use the name <b>n</b> for a field of the inner class,
since it is also a field of the outer class, but it is legal.  (It can happen
by accident as well - <em>e.g.</em>, if a programmer were to add a field <b>n</b> to a
superclass of the  outer class, the inner class would still work.)
It does not even
interfere with the inner class's ability to refer to the outer class's <b>n</b>
field: the cursor initialization 
refers to the <b>Range</b>'s lower bound through a fully qualified name
<b>Range.this.n</b>.
Its <b>hasNext()</b> method refers to the outer class's <b>m</b> field, which is
not shadowed.

<div class="p"><!----></div>
<pre>
class Range(m:Int, n:Int) implements Iterable[Int]{
  public def iterator ()  = new RangeIter();
  private class RangeIter implements Iterator[Int] {
     private var n : Int = m;
     public def hasNext() = n &lt;= Range.this.n;
     public def next() = n++;
  }
  public static def main(argv:Array[String](1)) {
    val r = new Range(3,5);
    for(i in r) Console.OUT.println(&#239;=" + i);
  }
}
</pre>

<div class="p"><!----></div>
An inner class has full access to the members of its enclosing class, both
static and instance.  In particular, it can access <b>private</b> information,
just as methods of the enclosing class can.  

<div class="p"><!----></div>
An inner class can have its own members.  
Inside instance methods of an inner class, <b>this</b> refers to the instance
of the <em>inner</em> class.  The instance of the outer class can be accessed as
<em>Outer</em><b>.this</b> (where <em>Outer</em> is the name of the outer class).
If, for some dire reason, it is necessary to have an inner class within an inner
class, the innermost class can refer to the <b>this</b> of either outer class
by using its name.

<div class="p"><!----></div>
An inner class can inherit from any class in scope,
with no special restrictions. <b>super</b> inside an inner class refers to the
inner class's superclass. If it is necessary to refer to the outer classes's
superclass, use a qualified name of the form <em>Outer</em><b>.super</b>.

<div class="p"><!----></div>
The only restriction placed on the members of inner classes is that the static
fields of an inner class must be compile-time constant expressions. 

<div class="p"><!----></div>
An inner class <b>IC1</b> of some outer class <b>OC1</b> can be extended by
another class <b>IC2</b>. However, since an <b>IC1</b> only exists as a
dependent of an <b>OC1</b>, each <b>IC2</b> must be associated with an <b>OC1</b>
- or a subtype thereof - as well.   For example, one often extends an
inner class when one extends its outer class: 
<pre>
class OC1 {
   class IC1 {}
}
class OC2 extends OC1 {
   class IC2 extends IC1 {} 
}
</pre>

<div class="p"><!----></div>
The hiding of method names has one fine point.  If an inner class defines a
method named <b>doit</b>, then <em>all</em> methods named <b>doit</b> from the
outer class are hidden - even if they have different argument types than the
one defined in the inner class.
They are still accessible via
<b>Outer.this.doit()</b>, but not simply via <b>doit()</b>.  The following code
is correct, but would not be correct if the ERROR line were uncommented.

<div class="p"><!----></div>
<pre>
class Outer {
  def doit() {}
  def doit(String) {}
  class Inner { 
     def doit(Boolean, Outer) {}
     def example() {
        doit(true, Outer.this);
        Outer.this.doit();
        //ERROR: doit("fails");
     }
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Constructors and Inner Classes</h3>


<div class="p"><!----></div>
If <b>IC</b> is an inner class of <b>OC</b>, then instance code in the body of
<b>OC</b> can create instances of <b>IC</b> simply by calling a constructor
<b>new IC(...)</b>: 
<pre>
class OC {
  class IC {}
  def method(){
    val ic = new IC();
  }
}
</pre>

<div class="p"><!----></div>
Instances of <b>IC</b> can be constructed from elsewhere as well.  Since every
instance of <b>IC</b> is associated with an instance of <b>OC</b>, an <b>OC</b>
must be supplied to the <b>IC</b> constructor.  The syntax for doing so is: 
<b>oc.new IC()</b>.  For example: 
<pre>
/*NONSTATIC*/class OC {
  class IC {}
  static val oc1 = new OC();
  static val oc2 = new OC();
  static val ic1 = oc1.new IC();
  static val ic2 = oc2.new IC();
}
class Elsewhere{
  def method(oc : OC) {
    val ic = oc.new IC();
  }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

</body>
</html>