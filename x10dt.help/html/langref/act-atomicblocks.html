<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Atomic blocks</title>
</head>

<body>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Atomic blocks</h2><a name="AtomicBlocks">
</a>
Languages such as Java use low-level synchronization locks to allow
multiple interacting threads to coordinate the mutation of shared
data. X10 eschews locks in favor of a very simple high-level
construct, the <em>atomic block</em>.

<div class="p"><!----></div>
A programmer may use atomic blocks to guarantee that invariants of
shared data-structures are maintained even as they are being accessed
simultaneously by multiple activities running in the same place.  

<div class="p"><!----></div>
For example, consider a class <b>Redund[T]</b>, which encapsulates a list
<b>list</b> and, (redundantly) keeps the size of the list in a second field
<b>size</b>.  Then <b>r:Redund[T]</b> has the invariant 
<b>r.list.size() == r.size</b>, which must be true at any point that there are
no method calls on <b>r</b> active.

<div class="p"><!----></div>
If the <b>add</b> method on <b>Redund</b> (which adds an element to the list) 
were defined as: 
<pre>
def add(x:T) { // Incorrect
  this.list.add(x);
  this.size = this.size + 1;
}
</pre>
Then two activities simultaneously adding elements to the same <b>r</b> could break the
invariant.  Suppose that <b>r</b> starts out empty.  Let the first activity
perform the <b>list.add</b>, and compute <b>this.size+1</b>, which is 1, but not store it
back into <b>this.size</b> yet.  
(At this point, <b>r.list.size()==1</b> and <b>r.size==0</b>; the invariant
expression is false, but, as the first call to <b>r.add()</b> is active, the
invariant does not need to be true - it only needs to be true when the
call finishes.)
Now, let the second activity do its call to
<b>add</b> to completion, which finishes with <b>r.size==1</b>.  
(As before, the invariant expression is false, but a call to <b>r.add()</b> is
still active, so the invariant need not be true.)
Finally, let
the first activity finish, which assigns the <b>1</b> computed before back into
<b>this.size</b>.  At the end, there are two elements in <b>r.list</b>, but
<b>r.size==1</b>. Since there are no calls to <b>r.add()</b> active, the
invariant must be true, but it is not.

<div class="p"><!----></div>
In this case, the invariant can be maintained by making the increment atomic.
Doing so forbids that sequence of events; the <b>atomic</b> block cannot be
stopped partway.  
<pre>
def add(x:T) { 
  this.list.add(x);
  atomic { this.size = this.size + 1; }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Unconditional atomic blocks</h3>
The simplest form of an atomic block is the <em>unconditional
atomic block</em>:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= AtomicStatement </td></tr>
<tr><td align="right">AtomicStatement ::= <b>atomic</b>  Statement </td></tr>
<tr><td align="right">MethodModifier ::= <b>atomic</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
For the sake of efficient implementation X10 v2.0 requires
that the atomic block be <em>analyzable</em>, that is, the set of
locations that are read and written by the <em>BlockStatement</em> are
bounded and determined statically.<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>
The exact algorithm to be used by
the compiler to perform this analysis will be specified in future
versions of the language.


<div class="p"><!----></div>
Such a statement is executed by an activity as if in a single step
during which all other concurrent activities in the same place are
blocked. If execution of the statement may throw an exception, it is
the programmer's responsibility to wrap the atomic block within a
<b>try</b>/<b>finally</b> clause and include undo code in the finally
clause. Thus the <b>atomic</b> statement only guarantees atomicity on
successful execution, not on a faulty execution.

<div class="p"><!----></div>
We allow methods of an object to be annotated with <b>atomic</b>. Such
a method is taken to stand for a method whose body is wrapped within an
<b>atomic</b> statement.

<div class="p"><!----></div>
Atomic blocks are closely related to non-blocking synchronization
constructs [], and can be used to implement 
non-blocking concurrent algorithms.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
In <b>atomic S</b>, <b>S</b> may include calls to <b>safe</b> methods, and use of
sequential control structures.

<div class="p"><!----></div>
It may <em>not</em> include an <b>async</b> activity (such as creation
of a <b>future</b>).

<div class="p"><!----></div>
It may <em>not</em> include any statement that may potentially block at
runtime (, <b>when</b>, <b>force</b> operations, <b>next</b>
operations on clocks, <b>finish</b>). 

<div class="p"><!----></div>
All locations accessed in an atomic block must statically satisfy the
<em>locality condition</em>: they must belong to the place of the current
activity.<a name="LocalityCondition">
</a> 

<div class="p"><!----></div>
The compiler checks for this condition by checking whether the statement
could be the body of a <b>void</b> method annotated with <b>safe</b> at
that point in the code (&#167;).

<div class="p"><!----></div>

<b>Consequences.&nbsp;&nbsp;</b>
Note an important property of an (unconditional) atomic block:

<div class="p"><!----></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table><tr><td nowrap="nowrap" align="right" colspan="1"> <b><b>atomic</b> {<b>s</b><b>1</b><b>;</b> <b>atomic</b> <b>s</b><b>2</b>}</b> &amp;=&amp; <b><b>atomic</b> {<b>s</b><b>1</b><b>;</b> <b>s</b><b>2</b>}</b></td></tr></table></td><td width="50%"></td><td width="1" align="right">(1)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Atomic blocks do not introduce deadlocks.    They may exhibit all the bad
behavior of sequential programs, including throwing exceptions and running
forever, but they are guaranteed not to deadlock.

<div class="p"><!----></div>
      <h4><a name="tth_sEc11.1.1">
11.1.1</a>&nbsp;&nbsp;Example</h4>

<div class="p"><!----></div>
The following class method implements a (generic) compare and swap (CAS) operation:

<div class="p"><!----></div>
<pre>
var target:Object = null;
public atomic def CAS(old: Object, new: Object): Boolean {
   if (target.equals(old)) {
     target = new;
     return true;
   }
   return false;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Conditional atomic blocks</h3>

<div class="p"><!----></div>
Conditional atomic blocks allow the activity to wait for some condition to be
satisfied before executing an atomic block. For example, consider a
<b>Redund</b> class holding a list <b>r.list</b> and, redundantly, its length
<b>r.size</b>.  A <b>pop</b> operation will delay until the <b>Redund</b> is
nonempty, and then remove an element and update the length.  
<pre>
def pop():T {
  var ret : T;
  when(size&#62;0) {
    ret = list.removeAt(0);
    size -;
    }
  return ret;
}
</pre>

<div class="p"><!----></div>
The execution of the test is atomic with the execution of the block.  This is
important; it means that no other activity can sneak in and make the condition
be false before the block is executed.  In this example, two <b>pop</b>s
executing on a list with one element would work properly. Without the
conditional atomic block - even doing the decrement atomically - one call to
<b>pop</b> could pass the <b>size&#62;0</b> guard; then the other call could run to
completion (removing the only element of the list); then, when the first call
proceeds, its <b>removeAt</b> will fail.  

<div class="p"><!----></div>
Note that <b>if</b> would not work here.  
<b>if(size&#62;0) atomic{size--; return list.removeAt(0);}</b> allows another
activity to act between the test and the atomic block.  
And 
<b>atomic{ if(size&#62;0) {size--; ret = list.removeAt(0);}}</b> 
does not wait for <b>size&#62;0</b> to become true.

<div class="p"><!----></div>
Conditional atomic blocks are of the form:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::=  WhenStatement </td></tr>
<tr><td align="right">WhenStatement ::=  <b>when</b> <b>(</b> Expression <b>)</b> Statement </td></tr>
<tr><td align="right">&#124; WhenStatement <b>or</b> <b>(</b> Expression <b>)</b> Statement 
</td></tr></table>
</em>

<div class="p"><!----></div>
In such a statement the one or more expressions are called <em>
guards</em> and must be <b>Boolean</b> expressions. The statements are the
corresponding <em>guarded statements</em>.  

<div class="p"><!----></div>
An activity executing such a statement suspends until such time as any
one of the guards is true in the current state. In that state, the
statement corresponding to the first guard that is true is executed.
The checking of the guards and the execution of the corresponding
guarded statement is done atomically. 

<div class="p"><!----></div>
X10 does not guarantee that a conditional atomic block
will execute if its condition holds only intermittently. For, based on
the vagaries of the scheduler, the precise instant at which a
condition holds may be missed. Therefore the programmer is advised to
ensure that conditions being tested by conditional atomic blocks are
eventually stable, , they will continue to hold until the block
executes (the action in the body of the block may cause the condition
to not hold any more).

<div class="p"><!----></div>

<div class="p"><!----></div>
 Rationale:
The guarantee provided by <b>wait</b>/<b>notify</b> in Java is no
stronger. Indeed conditional atomic blocks may be thought of as a
replacement for Java's wait/notify functionality.
 

<div class="p"><!----></div>
We note two common abbreviations. The statement <b>when (true) S</b> is
behaviorally identical to <b>atomic S</b>: it never suspends. Second,
<b>when (c) ;</b> may be abbreviated to <b>await(c);</b>-it
simply indicates that the thread must await the occurrence of a
certain condition before proceeding.  Finally note that a <b>when</b>
statement with multiple branches is behaviorally identical to a
<b>when</b> statement with a single branch that checks the disjunction of
the condition of each branch, and whose body contains an
<b>if</b>/<b>then</b>/<b>else</b> checking each of the branch conditions.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
For the sake of efficient implementation certain restrictions are
placed on the guards and statements in a conditional atomic
block. 


<div class="p"><!----></div>
Guards are statically required not to have side-effects, not to spawn
asynchronous activities (as for the <b>sequential</b> qualifier on methods) and
to have a statically determinable upper bound on their execution (as for the
<b>nonblocking</b> qualifier on methods).

<div class="p"><!----></div>
The body of a <b>when</b> statement must satisfy the conditions
for the body of an <b>atomic</b> block.

<div class="p"><!----></div>
Note that this implies that guarded statements are required to be <em>
flat</em>, that is, they may not contain conditional atomic blocks. (The
implementation of nested conditional atomic blocks may require
sophisticated operational techniques such as rollbacks.)

<div class="p"><!----></div>
The following class shows how to implement a bounded buffer of size
1 in X10 for repeated communication between a sender and a
receiver.  The call <b>buf.send(ob)</b> waits until the buffer has space, and
then puts <b>ob</b> into it.  Dually, <b>buf.receive()</b> waits until the
buffer has something in it, and then returns that thing.

<div class="p"><!----></div>
<pre>
class OneBuffer[T] {
  var datum: T;
  var filled: Boolean = false;
  public def send(v: T) {
    when (!filled) {
      this.datum = v;
      this.filled = true;
    }
  }
  public def receive(): T {
    when (filled) {
      v: T = datum;
      filled = false;
      return v;
    }
  }
}
</pre>


<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Note
  that depending on the state of the computation the activation path may
  traverse activities that are running, blocked or terminated.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>In X10 v2.0 the <b>finish</b>
statement is the only statement that marks its activity as a root
activity. Future versions of the language may introduce more such
statements.
<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>X10 v2.0 does
not specify a particular algorithm; this will be fixed in future
versions.
<div class="p"><!----></div>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>This program ignores the subtleties of which
estimate of variance to use, etc.
<div class="p"><!----></div>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>A static bound is a constant
that depends only on the program text, and is independent 
of any runtime parameters.

</body>
</html>