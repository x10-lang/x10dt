<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Constrained types</title>
</head>

<body>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Constrained types</h2>
<a name="ConstrainedTypes">
</a>
<a name="DepType:DepType">
</a>
<a name="DepTypes">
</a>

<div class="p"><!----></div>
Basic types, like <b>Int</b> and <b>List[String]</b>, provide useful
descriptions of data.  Indeed, most typed programming languages get by with no
more specific descriptions.

<div class="p"><!----></div>
However, there are a lot of things that one frequently wants to say about
data.  One might want to know that a <b>String</b> variable is not <b>null</b>,
or that a matrix is square, or that one matrix has the same number of columns
that another has rows (so they can be multiplied).  In the multicore setting,
one might wish to know that two values are located at the same processor, or
that one is located at the same place as the current computation.

<div class="p"><!----></div>
In most languages, there is simply no way to say these things statically.
Programmers must made do with comments, <b>assert</b> statements, and dynamic
tests.  X10 can do better, with <em>constraints</em> on types (and methods and
other things).

<div class="p"><!----></div>
A constraint is a boolean expression <b>e</b> attached to a basic type <b>T</b>,
written <b>T{e}</b>.  (Only a limited selection of boolean expressions is
available.)  The values of type <b>T{e}</b> are the values of <b>T</b> for which
<b>e</b> is true.  For example: 

<div class="p"><!----></div>

<ul>
<li> <b>String{self != null}</b> is the type of non-null strings.  <b>self</b>
      is a special variable available only in constraints; it refers to the
      datum being constrained.
<div class="p"><!----></div>
</li>

<li> If <b>Matrix</b> has properties <b>rows</b> and <b>cols</b>, 
      <b>Matrixrows == cols</b> is the type of square matrices.
<div class="p"><!----></div>
</li>

<li> One way to say that <b>a</b> has the same number of columns that <b>b</b>
      has rows (so that <b>a*b</b> is a valid matrix product), one could say: 
<pre>
  val a : Matrix = someMatrix() ;
  var b : Matrix{b.rows == a.cols} ;
</pre>

<div class="p"><!----></div>
When constraining a value of type <b>T</b>, <b>self</b> refers to the object of
type <b>T</b> which is being constrained.  For example, <b>Int{self == 4}</b> is
the type of <b>Int</b>s which are equal to 4 - the best possible description
of <b>4</b>, and a very difficult type to express without using <b>self</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<b>T{e}</b> is a <em>dependent type</em>, that is, a type dependent on values. The
type <b>T</b> is called the <em>base type</em> and <b>e</b> is called the <em>
  constraint</em>. If the constraint is omitted, it is <b>true</b>-that is, the
  base type is unconstrained.

<div class="p"><!----></div>
Constraints may refer to values in the local environment: 
<pre>
     val n = 1;
     var p : Point{rank == n};
</pre>
Indeed, there is technically no need for a constraint to refer to the
properties of its type; it can refer entirely to the environment, thus: 
<pre>
     val m = 1;
     val n = 2;
     var p : Point{m != n};
</pre>

<div class="p"><!----></div>
Constraints on properties induce a natural subtyping relationship:
<b>C{c}</b> is a subtype of
<b>D{d}</b> if <b>C</b> is a subclass of <b>D</b> and
<b>c</b> entails <b>d</b>.
For example: 

<ul>
<li> <b>Int{self == 3} &lt;: Int{self != 14}</b>.  The only value of
      <b>Int{self ==3}</b> is 3.  All integers but 14 are members of
      <b>Int{self != 14}</b>, and in particular 3 is.
<div class="p"><!----></div>
</li>

<li> Suppose we have classes <b>Child &lt;: Person</b>, and <b>Person</b> has a
      long <b>ssn</b> property.  If <b>rhys : Child{ssn == 123456789}</b>, then
      <b>rhys</b> is also a <b>Person</b> and still has <b>ssn==123456789</b>, so 
      <b>rhys : Person{ssn==123456789}</b> as well.  
      So, <b>Child{ssn == 123456789} &lt;: Person{ssn == 123456789}</b>.
<div class="p"><!----></div>
</li>

<li> Furthermore, since <b>123456789 != 555555555</b>, 
      <b>rhys : Person{ssn != 555555555}</b>.  
      So, <b>Child{ssn == 123456789} &lt;: Person{ssn != 555555555}</b>.
<div class="p"><!----></div>
</li>

<li> <b>T{e} &lt;: T</b> for any type <b>T</b>.  That is, if you have a value
      <b>v</b> of some base type <b>T</b> which satisfied <b>e</b>, then <b>v</b>
      is of that base type <b>T</b> (with the constraint ignored).
<div class="p"><!----></div>
</li>

<li> If <b>A &lt;: B</b>, then <b>A{c} &lt;: B{c}</b> for every constraint <b>{c}</b>
      for which <b>A{c}</b> and <b>B{c}</b> are defined.  That is, if every
      <b>A</b> is also a <b>B</b>, and <b>a : A{c}</b>, then 
      <b>a</b> is an <b>A</b> and <b>c</b> is true of it. So <b>a</b> is also a
      <b>B</b> (and <b>c</b> is still true of 
      it), so <b>a : B{c}</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Constraint Expressions</h3>

<div class="p"><!----></div>
Only a few kinds of expressions can appear in constraints.  For fundamental
reasons of mathematical logic, the more kinds of expressions that can appear
in constraints, the harder it is to compute the essential properties of
constrained type - in particular, the harder it is to compute 
<b>A{c} &lt;: B{d}</b>.  It doesn't take much to make this basic fact undecidable.
In order to
make sure that it stays decidable, X10 places quite stringent restrictions on
constraints.  

<div class="p"><!----></div>
Only the following forms of expression are allowed in constraints.  

<div class="p"><!----></div>
<b>Value expressions in constraints</b> may be: 

<ol type="1">
<li> Literal constants, like <b>3</b> and <b>true</b>;
<div class="p"><!----></div>
</li>

<li> Expressions computable at compile time, like <b>3*4+5</b>;
<div class="p"><!----></div>
</li>

<li> Accessible and immutable variables and parameters;
<div class="p"><!----></div>
</li>

<li> Accessible and immutable fields of the containing object;
<div class="p"><!----></div>
</li>

<li> Properties of the type being constrained;
<div class="p"><!----></div>
</li>

<li> Property methods;
<div class="p"><!----></div>
</li>

<li> <b>this</b>, if the constraint is in a place where <b>this</b> is defined;
<div class="p"><!----></div>
</li>

<li> <b>here</b>;
<div class="p"><!----></div>
</li>

<li> <b>self</b>;
<div class="p"><!----></div>
</li>

<li> Calls to property methods, where the receiver and arguments must be
      value expressions acceptable in constraints.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
<b>Constraints</b>, and <b>Boolean expressions in constraints</b>  may be any of
the following, where 
all value expressions are of the forms which may appear in constraints: 

<ol type="1">
<li> Equalities <b>e == f</b>;
<div class="p"><!----></div>
</li>

<li> Inequalities of the form <b>e != f</b>;<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>
<div class="p"><!----></div>
</li>

<li> Conjunctions of Boolean expressions that may appear in constraints;
<div class="p"><!----></div>
</li>

<li> Subtyping and supertyping expressions: <b>T &lt;: U</b> and <b>T :&#62; U</b>;
<div class="p"><!----></div>
</li>

<li> Type equalities and inequalities: <b>T == U</b> and <b>T != U</b>;
<div class="p"><!----></div>
</li>

<li> Testing a type for a default: <b>hasZero T</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
All variables appearing in a constraint expression must be visible wherever
that expression can used.  , properties and public fields of an object are
always permitted, but private fields of an object can only constrain private
members.  (Consider a class <b>PriVio</b> with a private field <b>p</b> and a
public method <b>m(x: Int{self != p})</b>, and a call <b>ob.m(10)</b> made
outside of the class. Since <b>p</b> is only visible inside the class, there is
no way to tell if <b>10</b> is of type <b>Int{self != p}</b> at the call site.)

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
The static constraint checker approximates computational reality in some
cases.  For example, it assumes that built-in types are infinite. This is a
good approximation for <b>Int</b>.  It is a poor approximation for <b>Boolean</b>,
as the checker believes that <b>a != b &amp;&amp; a != c &amp;&amp; b != c</b> is satisfiable
over <b>Boolean</b>, which it is not.  However, the checker is always correct
when computing the truth or falsehood of a constraint.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
      <h4><a name="tth_sEc5.1.1">
5.1.1</a>&nbsp;&nbsp;Acyclicity restriction</h4>

<div class="p"><!----></div>
To ensure that type-checking is decidable, we require that property graphs be
acyclic.  The property graph, at an instant in an X10 execution, is the graph
whose nodes are all objects in existence at that instance, with an edge from
x to y if x is an object with a property whose value is y. 

<div class="p"><!----></div>
Currently this restriction is not checked by the compiler. Future
versions of the compiler will check this restriction by introducing
rules on escaping of <b>this</b> () before the invocation of
<b>property</b> calls.

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Place constraints</h3>
<a name="PlaceTypes">
</a>
<a name="PlaceType">
</a>

<a name="DepType:PlaceType">
</a>

<div class="p"><!----></div>
An  computation spans multiple places (). Much data
can only be accessed from the proper place, and often it is preferable to
determine this statically. So, X10 has special syntax for working with places.
<b>T!</b> is a value of type <b>T</b> located at the right place for the current
computation, and <b>T!p</b> is one located at place <b>p</b>.

<div class="p"><!----></div>
PlaceConstraint     ::= <b>!</b> Place <br />
Place              ::=   Expression <br />


<div class="p"><!----></div>
More specifically, All  classes extend the class <b>x10.lang.Object</b>,
which defines a property <b>home</b> of type <b>Place</b>.  <b>T!p</b>, when
<b>T</b> is a class, is <b>Tself.home==p</b>.  If <b>p</b> is omitted, it
defaults to <b>here</b>.   <b>T!</b> is far and away the most common usage of
<b>!</b>. 

<div class="p"><!----></div>
Structs don't have <b>home</b>; they are available everywhere.  For structs, 
<b>T!</b> and <b>T!p</b> are synonyms for <b>T</b>. Since <b>T</b> is available
everywhere, it is available <b>here</b> and at <b>p</b>. 

<div class="p"><!----></div>
<b>!</b> may be combined with other constraints.  <b>T{c}!</b> is the type of
values of <b>T!</b> which satisfy <b>c</b>; it is <b>T{c &amp;&amp; self.home==here}</b>
for an object type and <b>T{c}</b> for a struct type.  
<b>T{c}!p</b> is the type of
values of <b>T!p</b> which satisfy <b>c</b>; it is <b>T{c &amp;&amp; self.home==p}</b>
for an object type and <b>T{c}</b> for a struct type.  

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Variables in Constraints</h3>

<div class="p"><!----></div>
X10 permits a <b>val</b> variable to appear in constraints on its own type as
it is being declared.  For example, <b>val nz: Intnz != 0 = 1;</b> declares a
non-zero variable <b>nz</b>.


<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;Operations on Constrained Types</h3>

<div class="p"><!----></div>
An instance <b>o</b> of <b>C</b> is said to be of type <b>C{c}</b> (or: <em>
belong to</em> <b>C{c}</b>) if the constraint <b>c</b> evaluates to <b>true</b> in
the current lexical environment, augmented with the binding <b>self</b>
&#8594; <b>o</b>.

<div class="p"><!----></div>
The <b>instanceof</b> operation lets programs test type membership.  
<b>e instanceof C{c}</b> returns true if <b>e</b> belongs to <b>C{c}</b>, and
false otherwise.  
<b>1 instanceof Int{self != 2}</b> returns true, 
and 
<b>x instanceof Int{self == 1}</b> returns false if 
<b>x==2</b>.

<div class="p"><!----></div>
However, it is a static error if <b>e</b> cannot possibly be an instance of
<b>C{c}</b>; the compiler will reject <b>1 instanceof Int{self == 2}</b> because
<b>1</b> can never satisfy <b>Int{self == 2}</b>. Similarly, <b>1 instanceof
String</b> is a static error, rather than an expression always returning false. 

<div class="p"><!----></div>
The <b>as</b> operation attempts to convert a value to a given constrained
type, as described in .   As with <b>instanceof</b>, it may
succeed, fail with a dynamic error, or, in the case where the cast is
impossible, fail to compile.

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.5">
5.5</a>&nbsp;&nbsp;Example of Constraints</h3>

<div class="p"><!----></div>
Constraints can be used to express simple relationships between objects,
enforcing some class invariants statically.  For example, in geometry, a line
is determined by two <em>distinct</em> points; a <b>Line</b> class can specify the
distinctness in a type constraint:<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>

<div class="p"><!----></div>
<pre>
class Position(x: Int, y: Int) {
   def this(x:Int,y:Int){property(x,y);}
   }
class Line(start: Position, 
           end: Position{self != start}) {}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Extending this concept, a <b>Triangle</b> can be defined as a figure with three
line segments which match up end-to-end.  Note that the degenerate case in
which two or three of the triangle's vertices coincide is excluded by the
constraint on <b>Line</b>.  However, not all degenerate cases can be excluded
by the type system; in particular, it is impossible to check that the three
vertices are not collinear. 

<div class="p"><!----></div>
<pre>
class Triangle 
 (a: Line, 
  b: Line{a.end == b.start}, 
  c: Line{b.end == c.start &amp;&amp; c.end == a.start})  {
   def this(a:Line,
            b: Line{a.end == b.start}, 
            c: Line{b.end == c.start &amp;&amp; c.end == a.start}) 
   {property(a,b,c);}
 }
</pre>

<div class="p"><!----></div>

</body>
</html>