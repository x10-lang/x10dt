<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Constrained types</title>
</head>

<body>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Constrained types</h2>
<a name="ConstrainedTypes">
</a>
<a name="DepType:DepType">
</a>
<a name="DepTypes">
</a>

<div class="p"><!----></div>
Basic types, like <b>Int</b> and <b>List[String]</b>, provide useful
descriptions of data.  

<div class="p"><!----></div>
However, one frequently wants to say more.  One might want to know
that a <b>String</b> variable is not <b>null</b>, or that a matrix is
square, or that one matrix has the same number of columns as another
has rows (so they can be multiplied).  In the multicore setting, one
might wish to know that two values are located at the same processor,
or that one is located at the same place as the current computation.

<div class="p"><!----></div>
In most languages, there is simply no way to say these things
statically.  Programmers must made do with comments, <b>assert</b>
statements, and dynamic tests.  X10 programs can do better, with <em>
  constraints</em> on types, and guards on class, method and type
definitions,

<div class="p"><!----></div>
A constraint is a boolean expression <b>e</b> attached to a basic type <b>T</b>,
written <b>T{e}</b>.  (Only a limited selection of boolean expressions is
available.)  The values of type <b>T{e}</b> are the values of <b>T</b> for which
<b>e</b> is true.  For example: 

<div class="p"><!----></div>

<ul>
<li> <b>String{self != null}</b> is the type of non-null strings.  <b>self</b>
      is a special variable available only in constraints; it refers to the
      datum being constrained, and its type is the type to which the
      constraint is attached.
<div class="p"><!----></div>
</li>

<li> If <b>Matrix</b> has properties <b>rows</b> and <b>cols</b>, 
      <b>Matrixself.rows == self.cols</b> is the type of square matrices.
<div class="p"><!----></div>
</li>

<li> One way to say that <b>a</b> has the same number of columns that <b>b</b>
      has rows (so that <b>a*b</b> is a valid matrix product), one could say: 
<pre>
  val a : Matrix = someMatrix() ;
  var b : Matrix{b.rows == a.cols} ;
</pre>

<div class="p"><!----></div>
When constraining a value of type <b>T</b>, <b>self</b> refers to the object of
type <b>T</b> which is being constrained.  For example, <b>Int{self == 4}</b> is
the type of <b>Int</b>s which are equal to 4 - the best possible description
of <b>4</b>, and a very difficult type to express without using <b>self</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<b>T{e}</b> is a <em>dependent type</em>, that is, a type dependent on values. The
type <b>T</b> is called the <em>base type</em> and <b>e</b> is called the <em>
  constraint</em>. If the constraint is omitted, it is <b>true</b>-that is, the
  base type is unconstrained.

<div class="p"><!----></div>
Constraints may refer to immutable values in the local environment: 
<pre>
     val n = 1;
     var p : Point{rank == n};
</pre>
In a variable declaration, the variable itself is in scope in its
type. For example, <b>val nz: Int{nz != 0} = 1;</b> declares a
non-zero variable <b>nz</b>.


<div class="p"><!----></div>

<div class="p"><!----></div>
A constrained type may be constrained further: the type <b>S{c}{d}</b>
is the same as the type <b>S{c,d}</b>.  Multiple constraints are equivalent to
conjoined constraints: <b>S{c,d}</b> in turn is the same as <b>S{c &amp;&amp; d}</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Syntax of constraints</h3>


<a name="PermittedConstraints">
</a>




<div class="p"><!----></div>
Only a few kinds of expressions can appear in constraints.  For fundamental
reasons of mathematical logic, the more kinds of expressions that can appear
in constraints, the harder it is to compute the essential properties of
constrained type - in particular, the harder it is to compute 
<b>A{c} &lt;: B{d}</b>.  It doesn't take much to make this basic fact undecidable.
In order to make sure that it stays decidable, X10 places stringent restrictions on
constraints.  

<div class="p"><!----></div>
Only the following forms of expression are allowed in constraints.  

<div class="p"><!----></div>
<b>Value expressions in constraints</b> may be: 

<ol type="1">
<li> Literal constants, like <b>3</b> and <b>true</b>;
<div class="p"><!----></div>
</li>

<li> Expressions computable at compile time, like <b>3*4+5</b>;
<div class="p"><!----></div>
</li>

<li> Accessible and immutable variables and parameters;
<div class="p"><!----></div>
</li>

<li> Accessible and immutable fields of objects;
<div class="p"><!----></div>
</li>

<li> Properties of the type being constrained;
<div class="p"><!----></div>
</li>

<li> <b>this</b>, if the constraint is in a place where <b>this</b> is defined;
<div class="p"><!----></div>
</li>

<li> <b>here</b>, if the constraint is in a place where <b>here</b> is defined;
<div class="p"><!----></div>
</li>

<li> <b>self</b>;
<div class="p"><!----></div>
</li>

<li> Calls to property methods, where the receiver and arguments must be
      value expressions acceptable in constraints.
<div class="p"><!----></div>
</li>
</ol>
For an expression <b>self.p</b> to be legal in a constraint, 
<b>p</b> must be 
a property. However terms <b>t.f</b> may be
used in constraints (where <b>t</b> is a term other than <b>self</b> and
<b>f</b> is an immutable field.

<div class="p"><!----></div>
<b>Constraints</b>, and <b>Boolean expressions in constraints</b>  may be any of
the following, where 
all value expressions are of the forms which may appear in constraints: 

<ol type="1">
<li> Equalities <b>e == f</b>;
<div class="p"><!----></div>
</li>

<li> Inequalities of the form <b>e != f</b>;<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>
<div class="p"><!----></div>
</li>

<li> Conjunctions of Boolean expressions that may appear in constraints (but
      only in top-level constraints, not in Boolean expressions in constraints);
<div class="p"><!----></div>
</li>

<li> Subtyping and supertyping expressions: <b>T &lt;: U</b> and <b>T :&#62; U</b>;
<div class="p"><!----></div>
</li>

<li> Type equalities and inequalities: <b>T == U</b> and <b>T != U</b>; 

<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
All variables appearing in a constraint expression must be visible wherever
that expression can used.  <em>E.g.</em>, properties and public fields of an object are
always permitted, but private fields of an object can only constrain private
members.  (Consider a class <b>PriVio</b> with a private field <b>p</b> and a
public method <b>m(x: Int{self != p})</b>, and a call <b>ob.m(10)</b> made
outside of the class. Since <b>p</b> is only visible inside the class, there is
no way to tell if <b>10</b> is of type <b>Int{self != p}</b> at the call site.)

<div class="p"><!----></div>
<em><em>Limitation</em> 
Certain spurious syntactic forms - such as <b>a+b,a*b,(c==a&amp;&amp;b),a &lt;b</b> -
are accepted by the compiler but treated incorrectly.  
</em>

<div class="p"><!----></div>
      <h4><a name="tth_sEc4.1.1">
4.1.1</a>&nbsp;&nbsp;Semantics of constraints</h4>

<a name="SemanticsOfConstraints">
</a>
An assignment of values to variables is said to be a <em>solution</em> for a
constraint <b>c</b> if under this assignment <b>c</b> evaluates to
<b>true</b>. For instance, the assignment that maps 
the variables <b>a</b> and <b>b</b> to a value <b>t</b> is a solution for
the constraint <b>a==b</b>. An assignment that maps <b>a</b> to 
<b>s</b> and <b>b</b> to a distinct value <b>t</b> is a solution for 
<b>a != b</b>. 

<div class="p"><!----></div>
An instance <b>o</b> of <b>C</b> is said to be of type <b>C{c}</b> (or <em>
belong to</em> <b>C{c}</b>) if the constraint <b>c</b> evaluates to <b>true</b> in
the current lexical environment augmented with the binding <b>self</b>
&#8594; <b>o</b>.

<div class="p"><!----></div>
A constraint <b>c</b> is said to <em>entail</em> a
constraint <b>d</b> if every solution for <b>c</b> is also a solution
for <b>d</b>. For instance the constraint
<b>x==y &amp;&amp; y==z &amp;&amp; z !=a</b> entails <b>x != a</b>.

<div class="p"><!----></div>
The constraint solver considers the assignment <b>a</b> to <b>null</b>
to  satisfy any constraint of the form <b>a.f==t</b>. Thus, for
instance, the assignment <b>var x:Tree{self.home==p}=null</b> does not
produce an error, since <b>self==null</b> is considered a solution for <b>self.home==p</b>.

<div class="p"><!----></div>
To ensure that type-checking is decidable, we require that property graphs be
acyclic.  The property graph, at an instant in an X10 execution, is the graph
whose nodes are all objects in existence at that instance, with an edge from
x to y if x is an object with a property whose value is y. 
The rules for constructors guarantee this.

<div class="p"><!----></div>
Constraints participate in the subtyping relationship in a natural way:
"S[S1,&#8230;, Sm]{c}" 
is a subtype of 
"T[T1,&#8230;, Tn]{d}" 
if "S[S1,&#8230;,Sm]" is a subtype of "T[T1,&#8230;,Tn]" and
<b>c</b> entails <b>d</b>.

<div class="p"><!----></div>
For examples of constraints and entailment, see (&#167;)

<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Constraint solver: incompleteness and approximation</h3>


<div class="p"><!----></div>
The constraint solver is sound in that if it claims that <b>c</b> entails <b>d</b>
then in fact it is the case that every value that satisfies <b>c</b>
satisfies <b>d</b>. 

<div class="p"><!----></div>
<em><em>Limitation</em> X10's Entailment Algorithm is Incomplete</em>
However, X10's constraint solver is incomplete. There are situations
in which <b>c</b> entails <b>d</b> but the solver cannot establish it. For
instance it cannot establish that <b>a != b &amp;&amp; a != c &amp;&amp; b != c</b>
entails <b>false</b> if <b>a</b>, <b>b</b>, and <b>c</b> are of type
<b>Boolean</b>.

<div class="p"><!----></div>
Certain other constraint entailments are prohibitively expensive to calculate.  The issues
concern constraints that connect different levels of recursively-defined
types, such as the following.  
<pre>
class Listlike(x:Int) {
  val kid : Listlike{self.x == this.x};
  def this(x:Int, kid:Listlike) { 
     property(x); 
     this.kid = kid as Listlike{self.x == this.x};}
}
</pre>
There is nothing wrong with <b>Listlike</b> itself, or with most uses of it;
however, a sufficiently complicated use of it could, in principle, cause X10's
typechecker to fail. 
It is hard to give a plausible example of when X10's algorithm fails, as we
have not yet observed such a failure in practice for a correct program.  

<div class="p"><!----></div>
The entailment algorithm of X10 2.0 imposes a certain limit on the number of
times such types will be unwound.   If this limit is exceeded, the compiler
will print a warning, and type-checking will fail in a situation where it is
semantically allowed.  In this case, insert a dynamic cast at the point where
type-checking failed.  

<div class="p"><!----></div>
<em><em>Limitation</em>  Support for comparisons of generic type variables is
  limited. This will be fixed in future releases.</em>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Example of Constraints</h3>
<a name="ConstraintExamples">
</a>

<div class="p"><!----></div>
Example of entailment and subtyping involving constraints.

<ul>
<li> <b>Int{self == 3} &lt;: Int{self != 14}</b>.  The only value of
      <b>Int{self ==3}</b> is 3.  All integers but 14 are members of
      <b>Int{self != 14}</b>, and in particular 3 is.
<div class="p"><!----></div>
</li>

<li> Suppose we have classes <b>Child &lt;: Person</b>, and <b>Person</b> has a
      long <b>ssn</b> property.  If <b>rhys : Child{ssn == 123456789}</b>, then
      <b>rhys</b> is also a <b>Person</b> and still has <b>ssn==123456789</b>, so 
      <b>rhys : Person{ssn==123456789}</b> as well.  
      So, <b>Child{ssn == 123456789} &lt;: Person{ssn == 123456789}</b>.
<div class="p"><!----></div>
</li>

<li> Furthermore, since <b>123456789 != 555555555</b>, 
      <b>rhys : Person{ssn != 555555555}</b>.  
      So, <b>Child{ssn == 123456789} &lt;: Person{ssn != 555555555}</b>.
<div class="p"><!----></div>
</li>

<li> <b>T{e} &lt;: T</b> for any type <b>T</b>.  That is, if you have a value
      <b>v</b> of some base type <b>T</b> which satisfied <b>e</b>, then <b>v</b>
      is of that base type <b>T</b> (with the constraint ignored).
<div class="p"><!----></div>
</li>

<li> If <b>A &lt;: B</b>, then <b>A{c} &lt;: B{c}</b> for every constraint <b>{c}</b>
      for which <b>A{c}</b> and <b>B{c}</b> are defined.  That is, if every
      <b>A</b> is also a <b>B</b>, and <b>a : A{c}</b>, then 
      <b>a</b> is an <b>A</b> and <b>c</b> is true of it. So <b>a</b> is also a
      <b>B</b> (and <b>c</b> is still true of 
      it), so <b>a : B{c}</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Constraints can be used to express simple relationships between objects,
enforcing some class invariants statically.  For example, in geometry, a line
is determined by two <em>distinct</em> points; a <b>Line</b> struct can specify the
distinctness in a type constraint:<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>

<div class="p"><!----></div>
<pre>
struct Position(x: Int, y: Int) {}
struct Line(start: Position, end: Position){start != end} {}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Extending this concept, a <b>Triangle</b> can be defined as a figure with three
line segments which match up end-to-end.  Note that the degenerate case in
which two or three of the triangle's vertices coincide is excluded by the
constraint on <b>Line</b>.  However, not all degenerate cases can be excluded
by the type system; in particular, it is impossible to check that the three
vertices are not collinear. 

<div class="p"><!----></div>
<pre>
struct Triangle 
 (a: Line, 
  b: Line{a.end == b.start}, 
  c: Line{b.end == c.start &amp;&amp; c.end == a.start})  
 {}
</pre>

<div class="p"><!----></div>
The <b>Triangle</b> class automatically gets a ternary constructor which takes
suitably constrained <b>a</b>, <b>b</b>, and <b>c</b> and produces a new
triangle. 

<div class="p"><!----></div>

</body>
</html>