<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>at: Place changeing</title>
</head>

<body>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp; <tt>at</tt>: Place Changing and Object Copying</h2><a name="AtStatement">
</a>


<div class="p"><!----></div>
An activity may change place using the <b>at</b> statement or
<b>at</b> expression:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= AtStatement </td></tr>
<tr><td align="right">AtStatement ::= <b>at</b> PlaceExpressionSingleList Statement </td></tr>
<tr><td align="right">Expression ::= AtExpression </td></tr>
<tr><td align="right">AtExpression ::= <b>at</b> PlaceExpressionSingleList ClosureBody 
</td></tr></table>
</em>

<div class="p"><!----></div>
The statement <b>at (p) S</b> executes the statement <b>S</b>
synchronously at a place described by <b>p</b>.
The expression <b>at (p) E</b> executes the statement <b>E</b>
synchronously at place <b>p</b>, returning the result to the
originating place.  

<div class="p"><!----></div>
<b>p</b> may be an expression of type <b>Place</b>, in which case its value is
used as the place to execute the body: 
<pre>
   at (here.next()) S();
</pre>


<div class="p"><!----></div>
<b>at(p)S</b> does <em>not</em> start a new activity.  It should be thought of as
transporting the current activity to <b>p</b>, running <b>S</b> there, and then
transporting it back.    If you want to start a new activity, use <b>async</b>;
if you want to start a new activity at <b>p</b>, use 
<b>at(p) async S</b>.  

<div class="p"><!----></div>
As a consequence of this, <b>S</b> may contain constructs which only make sense
within a single activity.  
For example, 
<pre>
    for(x in globalRefsToThings) 
      if (at(x.home) x().nice()) 
        return x();
</pre>
returns the first nice thing in a collection.   If we had used 
<b>async at(x.home)</b>, this would not be allowed; 
you can't <b>return</b> from an
<b>async</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Implicit copying from <tt>at</tt> </h3>


<div class="p"><!----></div>
<b>at(p)S</b> copies nearly all data that <b>S</b> might reference, and sends it
to place <b>p</b>, before executing <b>S</b> there. The only things that are not
copied are values only reachable through <b>GlobalRef</b>s.    If <b>x</b> is a
variable name referring to some object <b>ob</b> outside of <b>S</b>, then the
same variable name <b>x</b> refers to a deep copy <b>ob&#8242;</b> of <b>ob</b>
inside of <b>S</b>.  In this way the body <b>S</b> is in a separate block with
different variable bindings.

<div class="p"><!----></div>
For example, consider the following program.
<pre>
val c = new Cell[Int](5); // (1)
at (here) {               // (2)
   assert(c() == 5);      // (3)
   c.set(8);              // (4)
   assert(c() == 8);      // (5)
}
assert(c() == 5);         // (6)
</pre>
The <b>at</b> statement implicitly copies the <b>Cell</b> and its contents.  
After <b>(1)</b>, <b>c</b> is a <b>Cell</b> containing 5; call that cell c<sub>1</sub>
At <b>(2)</b>, that cell is copied, resulting in another cell c<sub>2</sub> whose
contents are also 5, as tested at <b>(3)</b>.
(Note that the copying behavior of <b>at</b> happens <em>even when the
destination place is the same as the starting place</em>- even with
<b>at(here)</b>.)
At <b>(4)</b>, the contents of c<sub>2</sub> are changed to 8, as confirmed at <b>(5)</b>; the contents of
c<sub>1</sub> are of course untouched.    Finally, at <b>(c)</b>, outside the scope
of the <b>at</b> started at line <b>(2)</b>, <b>c</b> refers to its original
value c<sub>1</sub> rather than the copy c<sub>2</sub>.  

<div class="p"><!----></div>
The <b>at</b> statement induces a <em>deep copy</em>.  Not only does it copy the
values of variables, it copies values that they refer to through zero or more
levels of reference.  Structures are preserved as well: if two fields
<b>x.f</b> and <b>x.g</b> refer to the same object o<sub>1</sub> in the original, then
<b>x.f</b> and <b>x.g</b> will both refer to the same object o<sub>2</sub> in the
copy.  

<div class="p"><!----></div>
For example, in the following variation of the preceding example,
<b>a</b>'s original value a<sub>1</sub> is an array with two references to the same
<b>Cell[Int]</b> c<sub>1</sub>.  The fact that a<sub>1</sub>(0) and a<sub>1</sub>(1) are both
identical to c<sub>1</sub> is demonstrated in <b>(A)</b>-<b>(C)</b>, as a<sub>1</sub>(0) is modified
and a<sub>1</sub>(1) is observed to change.  In <b>(D)</b>-<b>(F)</b>, the copy
a<sub>2</sub> is tested in the same way, showing that a<sub>2</sub>(0) and a<sub>2</sub>(1) both
refer to the same <b>Cell[Int]</b> c<sub>2</sub>.  However, the test at <b>(G)</b>
shows that c<sub>2</sub> is a different cell from c<sub>1</sub>, because changes to
c<sub>2</sub> did not propagate to c<sub>1</sub>.  
<pre>
val c = new Cell[Int](5);
val a = new Array[Cell[Int]][c,c];
assert(a(0)() == 5 &amp;&amp; a(1)() == 5);     // (A)
c.set(6);                               // (B)
assert(a(0)() == 6 &amp;&amp; a(1)() == 6);     // (C)
at(here) {
  assert(a(0)() == 6 &amp;&amp; a(1)() == 6);   // (D)
  c.set(7);                             // (E)
  assert(a(0)() == 7 &amp;&amp; a(1)() == 7);   // (F)
}
assert(a(0)() == 6 &amp;&amp; a(1)() == 6);     // (G)
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.1.1">
2.1.1</a>&nbsp;&nbsp;Copying and GlobalRef</h4>



<div class="p"><!----></div>
The single barrier to the potentially copious copying behavior of <b>at</b>
is the <b>GlobalRef</b> struct.  A <b>GlobalRef[T]</b> contains a reference to
a value of type <b>T</b>, in a form which can be transmitted, and a <b>Place</b>
<b>gr.home</b> indicating where the value lives.
The <b>GlobalRef</b> itself is copied across
<b>at</b> boundaries-but the value referred to is <em>not</em>
copied.<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a> 

<div class="p"><!----></div>
The following example does not copy the value <b>huge</b>.  However, <b>huge</b>
would have been copied if it had been put into a <b>Cell</b>, or simply used
directly. 
<pre>
val huge = &#196; potentially big thing";
val href = GlobalRef(huge);
at (here) {
   use(href);
  }
}
</pre>

<div class="p"><!----></div>
Values protected in <b>GlobalRef</b>s can be retrieved by the <b>gr.apply()</b>
method, often abbreviated simply <b>gr()</b>.  <b>gr.apply()</b> is guarded; it can
only be called when <b>gr.home == here</b>.  If you  want to do anything other
than pass a global reference around or compare two of them for equality, you
need to placeshift back to the home place of the reference, often with
<b>at(gr.home)</b>.   For example, the following (silly) program modifies the
command-line argument array.

<div class="p"><!----></div>
<pre>
  public static def main(argv: Array[String](1)) {
    val argref = GlobalRef[Array[String](1)](argv);
    at(here.next()) use(argref);
  }
  static def use(argref : GlobalRef[Array[String](1)]) {
    at(argref.home) {
      val argv = argref();
      argv(0) = "Hi!";
    }
  }
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.1.2">
2.1.2</a>&nbsp;&nbsp;Warnings about <b>at</b></h4>
There are two dangers involved with <b>at</b>: 

<ul>
<li> Careless use of <b>at</b> can result in copying and transmission
of very large data structures.
<div class="p"><!----></div>
</li>

<li> As seen in the examples above, changes made to copied objects are not
      propagated back to the originals.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

</body>
</html>