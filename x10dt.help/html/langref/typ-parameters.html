<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Type parameters</title>
</head>

<body>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Type Parameters and Generic Types</h2>
<a name="TypeParameters">
</a>

<div class="p"><!----></div>
<a name="Generics">
</a>A class, interface, method, or type definition  may have type
parameters.  Type parameters can be used as types, and will be bound to types
on instantiation.  For example, a generic stack class may be defined as 
<b>Stack[T]{...}</b>.  Stacks can hold values of any type; <em>e.g.</em>, 
<b>Stack[Int]</b> is a stack of integers, and 
<b>Stack[Point {self!=null}]</b> is a stack of non-null <b>Point</b>s.
Generics <em>must</em> be instantiated when they are used: <b>Stack</b>, by
itself, is not a valid type.
Type parameters may be constrained by a guard on the declaration
(&#167;,
&#167;,&#167;).

<div class="p"><!----></div>
A <em>generic class</em> (or struct, interface, or type definition) 
is a class (resp. struct, interface, or type definition) 
declared with k  &#8805; 1 type parameters. 
A generic class (or struct, interface, or type definition) 
can be used to form a type by supplying k types as type arguments within
<b>[</b> ... <b>]</b>.
For example,
<b>Stack</b> is a generic class, 
<b>Stack[Int]</b> is a type, and can be used as one: 
<b>var stack : Stack[Int];</b>

<div class="p"><!----></div>
A <b>Cell[T]</b> is a generic object, capable of holding a value of type
<b>T</b>.  For example, a <b>Cell[Int]</b> can hold an <b>Int</b>, and a
<b>Cell[Cell[Int{self!=0}]]</b> can hold a <b>Cell</b> which in turn can
only hold non-zero numbers. 
<pre>
class Cell[T] {
    var x: T;
    def this(x: T) { this.x = x; }
    def get(): T = x;
    def set(x: T) = { this.x = x; }
}
</pre>

<div class="p"><!----></div>
<b>Cell[Int]</b> is the type of <b>Int</b>-holding cells.  
The <b>get</b> method on a <b>Cell[Int]</b> returns an <b>Int</b>; the
<b>set</b> method takes an <b>Int</b> as argument.  Note that
<b>Cell</b> alone is not a legal type because the parameter is
not bound.

<div class="p"><!----></div>
A class (whether generic or not) may have generic methods.
Below,
<b>NonGeneric</b> has a generic method 
<b>first[T](x:List[T])</b>. An invocation of such a method may supply
the type parameters explicitly (<em>e.g.</em>, <b>first[Int](z)</b>).
 In certain cases (<em>e.g.</em>, <b>first(z)</b>)
type parameters may
be omitted and are inferred by the compiler (&#167;).

<div class="p"><!----></div>
<pre>
class NonGeneric {
  static def first[T](x:List[T]):T = x(0);
  def m(z:List[Int]) {
    val f = first[Int](z);
    val g = first(z);
    return f == g;
  }
}
</pre>
<em><em>Limitation</em>  X10 v2.1's C++ back end requires generic methods to be
static or final; the Java back end can accomodate generic instance methods as well. </em>

<div class="p"><!----></div>
Unlike other kinds of variables, type parameters may <em>not</em> be shadowed.  
If name <b>X</b> is in scope as a type, <b>X</b> may not be rebound as a type
variable.  
For example, neither <b>class B</b> nor <b>class C[B]</b> are allowed in the
following code, because they both shadow the type variable <b>B</b>.
<pre>
class A[B] {
  // ILLEGAL: class B{} 
  // ILLEGAL: class C[B]{} 
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Variance of Type Parameters</h3>







<div class="p"><!----></div>

<div class="p"><!----></div>
Class, struct and interface definitions are permitted to specify a <em>
  variance</em> 
for each type parameter. 
There are three variance specifications: 
<b>+</b> indicates <em>co-variance</em>,  <b>-</b> indicates <em>
  contravariance</em> and the absence of  <b>+</b> and 
 <b>-</b> indicates <em>invariance</em>. For a class (or struct or
 interface) <b>S</b> specifying that a particular parameter position
 (say, <b>i</b>) is covariant means that 
if <b>Si &lt;: Ti</b> then
"S[S1,&#8230;,Sn] &lt;: S[S1,&#8230;, Si-1,Ti,Si+1,&#8230; Sn]".
Similarly, saying that position <b>i</b> is is contravariant means
that 
if <b>Si &lt;: Ti</b> then
"S[S1,&#8230;, Si-1,Ti,Si+1,&#8230; Sn] &lt;: S[S1,&#8230;,Sn]". If the
position is invariant, then no such relationship is asserted between
<b>Si &lt;: Ti</b> 
and
"S[S1,&#8230;, Si-1,Ti,Si+1,&#8230; Sn]". The compiler must perform
several checks on the body of the class (or struct or interface) to
establish that type parameters with a variance are used in a manner
that is consistent with their semantics.

<div class="p"><!----></div>
<em><em>Limitation</em> </em> The implementation of variance specifications  suffers from
various limitations in X10 v2.1. Users are strongly encouraged not
to use variance. (Some classes, structs, and interfaces in the standard
libraries use variance specifications in a careful way that
circumvents these limitations.)

<div class="p"><!----></div>

</body>
</html>