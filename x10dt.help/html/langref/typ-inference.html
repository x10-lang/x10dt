<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Type inference</title>
</head>

<body>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Type inference</h2>
<a name="TypeInference">
</a>



<div class="p"><!----></div>
X10 v2.1 supports limited local type inference, permitting
certain variable types and return types to be elided.
It is a static error if an omitted type cannot be inferred or
uniquely determined. Type inference does not consider coercions.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Variable declarations</h3>

<div class="p"><!----></div>
The type of a <b>val</b> variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.
For example, 
<b>val seven = 7;</b>
is identical to 
<b>val seven: Int{self==7} = 7;</b>
Note that type inference gives the most precise X10 type, which might be more
specific than the type that a programmer would write.

<div class="p"><!----></div>
<em><em>Limitation</em> At the moment,  <b>var</b> declarations may not have their types
elided in this way.  
</em>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Return types</h3>

<div class="p"><!----></div>
The return type of a method can be omitted if the method has a body (, is
not <b>abstract</b> or <b>native</b>). The inferred return type is the computed
type of the body.  In the following example, the return type inferred for
<b>isTriangle</b> is 
<b>Boolean{self==false}</b>
<pre>
class Shape {
  def isTriangle() = false; 
}  
</pre>
Note that, as with other type inference, methods are given the most specific
type.  In many cases, this interferes with subtyping.  For example, if one
tried to write: 
<pre>
class Triangle extends Shape {
  def isTriangle() = true;
}
</pre>

the X10 compiler would reject this program for attempting to override
<b>isTriangle()</b> by a method with the wrong type, <em>viz</em>,
<b>Boolean{self==true}</b>.  In this case, supply the type that is actually
intended for <b>isTriangle</b>, such as 
<b>def isTriangle() :Boolean =false;</b>. 

<div class="p"><!----></div>
The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a constructor can be omitted if the
constructor has a body.
The inferred return type is the enclosing class type with
properties bound to the arguments in the constructor's <b>property</b>
statement, if any, or to the unconstrained class type.
For example, the <b>Spot</b> class has two constructors, the first of which has
inferred return type <b>Spot{x==0}</b> and the second of which has 
inferred return type <b>Spot{x==xx}</b>. 
<pre>
class Spot(x:Int) {
  def this() {property(0);}
  def this(xx: Int) { property(xx); }
}
</pre>

<div class="p"><!----></div>
A method or closure that has expression-free <b>return</b> statements
(<b>return;</b> rather than <b>return e;</b>) is said to return <b>void</b>.
<b>void</b> is not a type; there are no <b>void</b> values, nor can <b>void</b>
be used as the argument of a generic type. However, <b>void</b> takes the
syntactic place of a type. A method returning <b>void</b> can be specified by
<b>def m():void</b>: 

<div class="p"><!----></div>
<pre>
val f : () =&#62; void = () =&#62; {return;};
</pre>

<div class="p"><!----></div>
By a convenient abuse of language, <b>void</b> is sometimes
lumped in with types; <em>e.g.</em>, we may say "return type of a method" rather than
the formally correct but rather more awkward "return type of a method, or
<b>void</b>".   Despite this informal usage, <b>void</b> is not a type.  For
example, given 
<pre>
  static def eval[T] (f:()=&#62;T):T = f();
</pre>

The call <b>eval[void](f)</b> does <em>not</em> typecheck; <b>void</b> is not a
type and thus cannot be used as a type argument.  There is no way in X10 to
write a generic function which works with both functions which return a value
and functions which do not.  In most cases, functions which have no sensible
return value can be provided with a dummy return value.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Inferring Type Arguments</h3>

<div class="p"><!----></div>
A call to a polymorphic method %, closure, or constructor 
may omit the
explicit type arguments.  If the method has a type parameter
<b>T</b>, the type argument corresponding to <b>T</b> is inferred
to be a common ancestor of the types of any formal
parameters of type <b>T</b>.

<div class="p"><!----></div>
Consider the following method, which chooses one of its arguments.  (A more
sophisticated one might sometimes choose the second argument, but that does
not matter for the sake of this example.)
<pre>
static def choose[T](a: T, b: T): T = a; 
</pre>

<div class="p"><!----></div>
The type argument <b>T</b> can always be supplied: 
<b>choose[Int](1, 2)</b> picks an integer, 
and <b>choose[Any](1, &#255;es")</b> picks a value that might be an integer or a
string.  
However, the type argument can be elided.  Suppose that <b>Sub &lt;: Super</b>;
then the following compiles: 

<div class="p"><!----></div>
<pre>
  static def choose[T](a: T, b: T): T = a; 
  static val j : Any = choose(&#223;tring", 1);
  static val k : Super = choose(new Sub(), new Super());
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc11.3.1">
11.3.1</a>&nbsp;&nbsp;Sketch of X10 Type Inference for Method Calls</h4>

<div class="p"><!----></div>
When the X10 compiler sees a method call 
&#228;.m(b<sub>1</sub>, &#8230;,b<sub>n</sub>)", and attempts to infer type parameters to see if it could be use of a
method "def m[X<sub>1</sub>, &#8230;, X<sub>t</sub>](y<sub>1</sub>: S<sub>1</sub>, &#8230;, y<sub>n</sub>:S<sub>n</sub>)", 
it reasons as follows. 

<div class="p"><!----></div>
Suppose that "b<sub>i</sub>" has type "T<sub>i</sub>".  Then, X10 is seeking a
set of type B bindings "X<sub>j</sub> = U<sub>j</sub>", for 1  &le; j  &le; t, such that 
"T<sub>i</sub> &lt;: S<sup>*</sup><sub>i</sub>" for 1  &le; i  &le; n, where "S<sup>*</sup>" is
<b>S</b> with each type variable "X<sub>j</sub>" replaced by the corresponding
&#220;<sub>j</sub>".  If it can find such a B, it has a usable choice of type
arguments and can do the type inference.  If it cannot find B, then it
cannot do type inference.    (Note that X10's type inference algorithm is
incomplete - there may <em>be</em> such a B that X10 cannot find.  If this
occurs in your program, you will have to write down the type arguments
explicitly.) 

<div class="p"><!----></div>
Let B<sub>0</sub> be the set { T<sub>i</sub> &lt;: S<sub>i</sub> </td><td width="150">
&#124; 1 &le; i &le; n}.  Let
B<sub>n+1</sub> be B<sub>n</sub> with one element F  &lt; : G or 
F =  = G removed, and
C(F  &lt; : G) 
or C(F =  = G) (defined below) added.  Repeat this until 
B<sub>n</sub> consists entirely of comparisons with type variables (<em>viz</em>, 
"Y<sub>j</sub> == U", 
"Y<sub>j</sub> &lt;: U", and
"Y<sub>j</sub> :&#62; U"), 
or until some n exceeds a predefined compiler limit. 

<div class="p"><!----></div>
The candidate inferred types may be read off of B<sub>n</sub>.  The guessed binding
for "X<sub>j</sub>" is: 

<ul>
<li> If there is an equality "X<sub>j</sub>==W" in B<sub>n</sub>, then guess the
      binding "X<sub>j</sub>=W".  Note that there may be several such
      equalities with different choices of <b>W</b>, but, if the inference is
      to work, all the choices of <b>W</b> must be equal types anyways.
<div class="p"><!----></div>
</li>

<li> Otherwise, if there is one or more upper bounds 
"X<sub>j</sub> &lt;: V<sub>k</sub>" in B<sub>n</sub>, guess the binding 
"X<sub>j</sub> = V<sub>+</sub>", where 
"V<sub>+</sub>" is the computed lower bound of all the "V<sub>k</sub>''s.
<div class="p"><!----></div>
</li>

<li> Otherwise, if there is one or more lower bounds 
"R<sub>k</sub> &lt;: X<sub>j</sub>", guess that
"X<sub>j</sub> = R<sub>+</sub>", where 
"R<sub>+</sub>" is the computed upper bound of all the "R<sub>k</sub>''s.
<div class="p"><!----></div>
</li>
</ul>
If this does not yield a binding for some variable "X<sub>j</sub>", then type
inference fails.  Furthermore, if every variable "X<sub>j</sub>" is given a
binding &#220;<sub>j</sub>", but the 
bindings do not work - 
that is, if 
&#228;.m[U<sub>1</sub>, &#8230;, U<sub>t</sub>](b<sub>1</sub>, &#8230;,b<sub>n</sub>)"
is not a call of 
the original method 
"def m[X<sub>1</sub>, &#8230;, X<sub>t</sub>](y<sub>1</sub>: S<sub>1</sub>, &#8230;, y<sub>n</sub>:S<sub>n</sub>)"
- then type inference also fails.

<div class="p"><!----></div>

<b>Computation of the Replacement Elements&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Given a type relation
r of the form F  &lt; : G
or F =  = G, we compute the set C(r) of
replacement constraints.  There are a number of cases; we present only the
interesting ones. 

<div class="p"><!----></div>

<ul>
<li> If F has the form "F&#8242;{c}" 
"C(r)" is defined to be
 "F&#8242; == G" if r is an equality, or 
 "F&#8242; &lt;: G" if r is a subtyping.
That is, we erase type constraints.  
Validity is not an issue at this point in the algorithm, as 
we check at the end that the result is valid.
However, in important cases, the replacement is valid, in the sense that the 
solutions of B<sub>k+1</sub> are precisely the solutions of B<sub>k</sub>.
Specifically, if the equation had the form "Z{c} == A", it could be
solved by <b>Z==A</b> or by <b>Z = A{c}</b>.  By dropping constraints in this
rule, we choose the former solution.
<div class="p"><!----></div>
</li>

<li> Similarly, we drop constraints on G as well.
<div class="p"><!----></div>
</li>

<li> If F has the form "K[F<sub>1</sub>, &#8230;, F<sub>k</sub>]"
and 
G
has the form "K[G<sub>1</sub>, &#8230;, G<sub>k</sub>]", 
then C(r) has one type relation comparing each parameter of 
F with the corresponding one of G. 

<div class="p"><!----></div>
If r is a type equality F =  = G, then 
C(r) = { F<sub>l</sub> == G<sub>l</sub> </td><td width="150">
&#124; 1 &le; l &le; k.

<div class="p"><!----></div>
If r is a type comparison, and the l<sup>th</sup> type parameter of <b>K</b> is
invariant (resp. covariant or contravariant), then 
C(r) has F<sub>l</sub> =  = G<sub>l</sub>
(resp F<sub>l</sub>  &lt; : G<sub>l</sub> or G<sub>l</sub>  &lt; : F<sub>l</sub> . 

<div class="p"><!----></div>
For example, the constraint "List[X] == List[Y]" produces the
constraint <b>X==Y</b>, because <b>List</b> is nonvariant.  
If <b>Contra[X]</b> is contravariant, 
the constraint <b>Contra[X] &lt;: Contra[List[Y]]</b> 
produces the constraint <b>List[Y] &lt;: X</b>.
<div class="p"><!----></div>
</li>

<li> Other cases are fairly routine.  <em>E.g.</em>, if F is a <b>type</b>-defined
      abbreviation, it is expanded.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Suppose we have: 
<pre>
import x10.util.*;
class Cl[C1, +C2, -C3]{}
class Example {
  static def me[X1, X2](Cl[Int, X1, X2]) = 
     new Cl[X1, X2, Point]();
  static def example() {
    val a = new Cl[Int, Boolean, String]();
    val b : Cl[Boolean, String, Point] = me[Boolean, String](a);
  }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>

<div class="p"><!----></div>

</body>
</html>