<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Type inference</title>
</head>

<body>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Type inference</h2>
<a name="TypeInference">
</a>



<div class="p"><!----></div>
X10 v2.1 supports limited local type inference, permitting
certain variable types and return types to be elided.
It is a static error if an omitted type cannot be inferred or
uniquely determined. Type inference does not consider coercions.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Variable declarations</h3>

<div class="p"><!----></div>
The type of a <b>val</b> variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.
For example, 
<b>val seven = 7;</b>
is identical to 
<b>val seven: Int{self==7} = 7;</b>
Note that type inference gives the most precise X10 type, which might be more
specific than the type that a programmer would write.

<div class="p"><!----></div>
<em><em>Limitation</em> At the moment,  <b>var</b> declarations may not have their types
elided in this way.  
</em>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Return types</h3>

<div class="p"><!----></div>
The return type of a method can be omitted if the method has a body (, is
not <b>abstract</b> or <b>native</b>). The inferred return type is the computed
type of the body.  In the following example, the return type inferred for
<b>isTriangle</b> is 
<b>Boolean{self==false}</b>
<pre>
class Shape {
  def isTriangle() = false; 
}  
</pre>
Note that, as with other type inference, methods are given the most specific
type.  In many cases, this interferes with subtyping.  For example, if one
tried to write: 
<pre>
class Triangle extends Shape {
  def isTriangle() = true;
}
</pre>

the X10 compiler would reject this program for attempting to override
<b>isTriangle()</b> by a method with the wrong type, <em>viz</em>,
<b>Boolean{self==true}</b>.  In this case, supply the type that is actually
intended for <b>isTriangle</b>, such as 
<b>def isTriangle() :Boolean =false;</b>. 

<div class="p"><!----></div>
The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a constructor can be omitted if the
constructor has a body.
The inferred return type is the enclosing class type with
properties bound to the arguments in the constructor's <b>property</b>
statement, if any, or to the unconstrained class type.
For example, the <b>Spot</b> class has two constructors, the first of which has
inferred return type <b>Spot{x==0}</b> and the second of which has 
inferred return type <b>Spot{x==xx}</b>. 
<pre>
class Spot(x:Int) {
  def this() {property(0);}
  def this(xx: Int) { property(xx); }
}
</pre>

<div class="p"><!----></div>
A method or closure that has expression-free <b>return</b> statements
(<b>return;</b> rather than <b>return e;</b>) is said to return <b>void</b>.
<b>void</b> is not a type; there are no <b>void</b> values, nor can <b>void</b>
be used as the argument of a generic type. However, <b>void</b> takes the
syntactic place of a type. A method returning <b>void</b> can be specified by
<b>def m():void</b>: 

<div class="p"><!----></div>
<pre>
val f : () =&#62; void = () =&#62; {return;};
</pre>

<div class="p"><!----></div>
By a convenient abuse of language, <b>void</b> is sometimes
lumped in with types; <em>e.g.</em>, we may say "return type of a method" rather than
the formally correct but rather more awkward "return type of a method, or
<b>void</b>".   Despite this informal usage, <b>void</b> is not a type.  For
example, given 
<pre>
  static def eval[T] (f:()=&#62;T):T = f();
</pre>

The call <b>eval[void](f)</b> does <em>not</em> typecheck; <b>void</b> is not a
type and thus cannot be used as a type argument.  There is no way in X10 to
write a generic function which works with both functions which return a value
and functions which do not.  In most cases, functions which have no sensible
return value can be provided with a dummy return value.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Inferring Type Arguments</h3>

<div class="p"><!----></div>
A call to a polymorphic method %, closure, or constructor 
may omit the
explicit type arguments.  If the method has a type parameter
<b>T</b>, the type argument corresponding to <b>T</b> is inferred
to be a common ancestor of the types of any formal
parameters of type <b>T</b>.

<div class="p"><!----></div>
Consider the following method, which chooses one of its arguments.  (A more
sophisticated one might sometimes choose the second argument, but that does
not matter for the sake of this example.)
<pre>
static def choose[T](a: T, b: T): T = a; 
</pre>

<div class="p"><!----></div>
The type argument <b>T</b> can always be supplied: 
<b>choose[Int](1, 2)</b> picks an integer, 
and <b>choose[Any](1, &#255;es")</b> picks a value that might be an integer or a
string.  
However, the type argument can be elided.  Suppose that <b>Sub &lt;: Super</b>;
then the following compiles: 

<div class="p"><!----></div>
<pre>
  static def choose[T](a: T, b: T): T = a; 
  static val j : Any = choose(&#223;tring", 1);
  static val k : Super = choose(new Sub(), new Super());
</pre>

<div class="p"><!----></div>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>

<div class="p"><!----></div>
</li>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Currently inequalities
      of the form <b>e &lt; f</b> are not supported.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>We call them
<b>Position</b> to avoid confusion with the built-in class <b>Point</b>. 
Also, <b>Position</b> is a struct rather than a class so that the non-equality
test <b>start != end</b> compares the coordinates.  If <b>Position</b> were a
class, <b>start != end</b> would check for different <b>Position</b> objects,
which might have the same coordinates.

<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>Java, for one, suffers a number of
  inconveniences because some built-in types like <b>int</b> and <b>char</b>
  aren't subtypes of anything else.
<br /><br />

</body>
</html>