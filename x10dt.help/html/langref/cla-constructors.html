<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Constructors</title>
</head>

<body>
<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Constructors</h2>


<div class="p"><!----></div>
Instances of classes are created by the <b>new</b> expression: <br />

  <em>
  
<table>

<tr><td align="right">ClassInstCreationExp ::= <b>new</b> TypeName TypeArguments<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; <b>new</b> TypeName <b>[</b> Type <b>]</b> <b>[</b> ArgumentList<sup>?</sup>&nbsp;<b>]</b> </td></tr>
<tr><td align="right">&#124; Primary <b>.</b> <b>new</b> Id TypeArguments<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; AmbiguousName <b>.</b> <b>new</b> Id TypeArguments<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
This constructs a new object, and calls some code, called a <em>constructor</em>,
to initialize the newly-created object properly.

<div class="p"><!----></div>
Constructors are defined like methods, except that they are named <b>this</b>
and ordinary methods may not be.    The content of a constructor body has
certain capabilities (<em>e.g.</em>, <b>val</b> fields of the object may be initialized)
and certain restrictions (<em>e.g.</em>, most methods cannot be called); see
&#167; for the details.

<div class="p"><!----></div>
The following class provides two constructors.  The unary constructor 
<b>def this(b : Int)</b> allows initialization of the <b>a</b> field to an 
arbitrary value.  The nullary constructor <b>def this()</b> gives it a default
value of 10.  The <b>example</b> method illustrates both of these calls.

<pre>
class C {
  public val a : Int;
  def this(b : Int) { a = b; } 
  def this() { a = 10; }
  static def example() {
     val two = new C(2);
     assert two.a == 2;
     val ten = new C(); 
     assert ten.a == 10;
  }
}
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Automatic Generation of Constructors</h3>


<div class="p"><!----></div>
Classes that have no constructors written in the class declaration are
automatically given a constructor which sets the class properties and does
nothing else. If this automatically-generated constructor is not valid (<em>e.g.</em>,
if the class has <b>val</b> fields that need to be initialized in a
constructor), the class has no constructor, which is a static error.

<div class="p"><!----></div>
The following class has no explicit constructor.   

<div class="p"><!----></div>
<pre>
class C(x:Int) {
  static def example() {
    val c : C = new C(4);
    assert c.x == 4;
  }
}
</pre>

<div class="p"><!----></div>
<pre>
class C(x:Int) {
  val d: Int;
  static def example() {
    val thisShouldBeWrong = new C(40);
  }
}
</pre>

<div class="p"><!----></div>
Thus, it has an implicit constructor: 
<b>def this(x:Int)property(x);</b>

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Calling Other Constructors</h3>

<div class="p"><!----></div>
The <em>first</em> statement of a constructor body may be a call of the form 
<b>this(a,b,c)</b> or <b>super(a,b,c)</b>.  The former will execute the body of
the matching constructor of the current class; the latter, of the superclass. 
This allows a measure of abstraction in constructor definitions; one may be
defined in terms of another.

<div class="p"><!----></div>
The following class has two constructors.  <b>new Ctors(123)</b> constructs a
new <b>Ctors</b> object with parameter 123.  <b>new Ctors()</b> constructs one
whose parameter has a default value of 100: 
<pre>
class Ctors {
  val a : Int;
  def this(a:Int) { this.a = a; }
  def this() {
    this(100);
  }
}
</pre>


<div class="p"><!----></div>
In the case of a class which implements <b>operator ()</b> 
- or any other constructor and application with the same signature - 
this can be ambiguous.  If <b>this()</b> appears as the first statement of a
constructor body, it could, in principle, mean either a constructor call or an
operator evaluation.   This ambiguity is resolved so that <b>this()</b> always
means the constructor invocation.  If, for some reason, it is necessary to
invoke an application operator early in a constructor, precede it with a dummy
statement, such as <b>if(false);</b>  

<div class="p"><!----></div>

</body>
</html>