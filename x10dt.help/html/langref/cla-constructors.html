<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Constructors</title>
</head>

<body>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Constructors</h2>

<div class="p"><!----></div>
Constructors allow the initialization of objects by the execution of
almost-arbitrary code.  Like methods, constructors can have formal parameters,
a constraint, a return type, a <b>throws</b> clause, an <b>offers</b> clause, 
and a body. The formals,
constraint, and <b>throws</b> and <b>offers</b> clauses are identical to those for a method.
A constructor is declared by <b>def this()...</b>; that is, as if it were a
method whose name were the reserved word <b>this</b>.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Constructor Return Types</h3>

<div class="p"><!----></div>
The return type of a constructor describes the values that constructor can
create.  While all constructors for class <b>C</b> create objects of base class
<b>C</b>, some individual constructors may construct objects with more specific
constraints.    For example, in
<pre>
class Crate(n:Int) {
  def this() : Crate{self.n==0} = { property(0); }
  def this(b:Boolean) : Crate{self.n==1} = { property(1); }
}
</pre>

the nullary constructor call <b>new Crate()</b> will return a value of type 
<b>Crate{self.n == 0}</b>- the <b>n</b> field is zero and the compiler knows
it.  The unary Boolean constructor will return an object of type 
<b>Crate{self.n==1}</b>.
A less trivial example might be a specialized constructor for a square matrix, 
which returned type <b>Matrix{self.rows==self.cols}</b>.  

<div class="p"><!----></div>
If the constructor type is omitted, the constructor returns 
the type of its class, constrained by the actual parameters to the
<b>property</b> call in the constructor.  That is, the first constructor 
call above could be abbreviated:
<pre>
  def this() { property(0); }
  // And to prove that the nullary constructor knows n==0: 
  static def confirm() {
    val v : Crate{self.n == 0} = new Crate();
  }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Constructor Bodies</h3>

<div class="p"><!----></div>
Constructors have many restrictions, designed to ensure that objects behave
sanely while being constructed.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;<b> proto</b> qualifier on types</h3>
<a name="Prototypes">
</a>

X10 ensures that every variable must have a value consistent with its type
before it is read.  This is to prevent the unfortunate situations possible in
other languages, such as: 
<pre>
class Evil {
   val f : Int; // uninitialized
   def getf() = this.f;
   def this() { 
       val f0 = this.getf();
       println(&#239;nitially, f0=" + f0);
       this.f = f0 + 1;
       println("now, this.f =" + this.f);
   }
}
</pre>

<b>f</b> is a <b>val</b> field and should never change.  However, in this
example, it starts out uninitialized.  Its uninitialized value is read by the
call <b>this.getf()</b>, giving a meaningless value-no value could be
meaningful, since the field is not initialized.  The constructor prints
<b>f</b>'s initial value, increments it, initializes <b>f</b> to the incremented
value, and prints the new value.  This program prints two different numbers.
That is, a <b>val</b> field-supposedly immutable-has been observed to
change.  

<div class="p"><!----></div>
This approach can be extended to give almost arbitrarily bad behavior 
for partially-initialized objects.  The issue is particularly pernicious with
concurrency, where one activity initializes an object while another one uses
it.  

<div class="p"><!----></div>
Many languages with constructors simply admit (or avoid admitting) that method
calls on partially-initialized objects are dangerous and should be avoided.
X10 takes a more careful approach: some method calls in constructors are
allowed, but ones which could cause this problem are not.  

<div class="p"><!----></div>
The approach is based on <b>proto</b> types. If <b>C</b> is a class, 
<b>proto C</b> is a type that describes partially-initialized values of
<b>C</b>.  The rules in this section are designed to allow methods to <em>
write</em> into fields of a <b>proto C</b> object, thus initializing it, but not
<em>read</em> them and thus not stumble into the error above.

<div class="p"><!----></div>


<div class="p"><!----></div>
For local variables, this is ensured by using a pre-specified static
analysis to ensure that every local variable is written into before it
is read. Type-checking of assignment ensures the value written is
consistent with the static type of the variable.

<div class="p"><!----></div>
For fields, this is ensured by introducing a form of ownership types
called <em>incomplete types</em> to address the <em>escaping-this</em>
problem.  To permit flexibility in writing constructors, X10 v1.7
permits <b>this</b> to be used in a constructor as a reference to the
object currently being constructed. Unfortunately there are no
restrictions on the usage of <b>this</b>. In particular, this reference
can be permitted to escape: it may be stored in variables on the heap
(thereby permitting concurrently executing activities to read the
value of fields that may not yet have been initialized), passed as an
argument to method invocations, or used as the target for a method
invocation. Indeed, the method may be invoked in a super constructor,
and may have been overridden at a subclass, guaranteeing that accesses
to fields defined in the subclass are accesses to uninitialized
variables. For instance an immutable field may be observed containing
a value (the value the field was initialized with) which may be
different from the value it will contain once the constructor has
returned.

<div class="p"><!----></div>
Incomplete types are designed with the following goals:
 
<ul>
<li> Guarantee that fields are not read before they are initialized.
<div class="p"><!----></div>
</li>

<li>  Allow the creation of immutable cyclic object graphs.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>  This requires that it be possible to pass an
  object under construction into a constructor invocation.
<div class="p"><!----></div>
</li>

<li> Allow appropriate user-defined methods can be called during object
  creation (so that the transformation between the values supplied as
  parameters to a constructor and the values actually placed in fields
  is determined by arbitrary user-defined code).
<div class="p"><!----></div>
</li>

<li> Keep the design minimally invasive. Most programmers should
  not have to be concerned about this problem.
<div class="p"><!----></div>
</li>

<li> Ensure that there is no runtime overhead.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
These goals are met by introducing incomplete types through the type
qualifier <b>proto</b>. Types of the form <b>proto T</b> are said to be
<em>incomplete types</em>; types that do not have the qualifier are said to be
<em>complete</em>.
 Say that an object <b>o</b> is <em>confined</em>
to a given activity <b>A</b> if it can be reached only from stack
frames of <b>A</b> or from objects which are, recursively, confined to
<b>A</b>. Thus confined objects cannot be accessed by activities other
than <b>A</b>.

<div class="p"><!----></div>
Incomplete types ensure that objects whose construtors have not exited
are confined. Further, all references to such objects on the stack
are contained in variables of incomplete types. The compiler does not
permit the fields of variables of incomplete types to be read. 
Thus incomplete types permit the construction of graphs of objects
while ensuring that these objects are confined and their fields are not
read during construction. 

<div class="p"><!----></div>
The return value of a constructor for class <b>C</b> that takes no
incomplete arguments is (a subtype of) <b>C</b>, that is, a complete
type. It will point only to completed objects. It can now be
assigned to any (type-consistent) field of any object, that is, it is
now allowed to escape.

<div class="p"><!----></div>

</body>
</html>