<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Constructors</title>
</head>

<body>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Constructors</h2>

<div class="p"><!----></div>
Constructors allow the initialization of objects by the execution of
almost-arbitrary code.  Like methods, constructors can have formal parameters,
a constraint, a return type, 
and a body. The formals and constraint
 are identical to those for a method.
A constructor is declared by <b>def this()...</b>; that is, as if it were a
method whose name were the reserved word <b>this</b>.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Constructor Return Types</h3>

<div class="p"><!----></div>
The return type of a constructor describes the values that constructor can
create.  While all constructors for class <b>C</b> create objects of base class
<b>C</b>, some individual constructors may construct objects with more specific
constraints.    For example, in
<pre>
class Crate(n:Int) {
  def this() : Crate{self.n==0} = { property(0); }
  def this(b:Boolean) : Crate{self.n==1} = { property(1); }
}
</pre>

the nullary constructor call <b>new Crate()</b> will return a value of type 
<b>Crate{self.n == 0}</b>- the <b>n</b> field is zero and the compiler knows
it.  The unary Boolean constructor will return an object of type 
<b>Crate{self.n==1}</b>.
A less trivial example might be a specialized constructor for a square matrix, 
which returned type <b>Matrix{self.rows==self.cols}</b>.  

<div class="p"><!----></div>
If the constructor type is omitted, the constructor returns 
the type of its class, constrained by the actual parameters to the
<b>property</b> call in the constructor.  That is, the first constructor 
call above could be abbreviated:
<pre>
  def this() { property(0); }
  // And to prove that the nullary constructor knows n==0: 
  static def confirm() {
    val v : Crate{self.n == 0} = new Crate();
  }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Constructor Bodies</h3>

<div class="p"><!----></div>
Constructors have many restrictions, designed to ensure that objects behave
sanely while being constructed. Constructors initialize fields of objects and
establish object invariants.  It should never be possible to observe an
uninitialized object outside of a constructor call.  However, without some
restrictions, it would be possible to do so quite easily.  A constructor could
put <b>this</b> into a data structure before initializing it, and a concurrent
activity could read it before the initialization is finished.  If the 
line marked <b>ILLEGAL</b> were uncommented, the following program would
exhibit the problem: 
<pre>
class Escaper {
   static val all = new ArrayList[Escaper]();
   val fld : String;
   def this() {
      //ILLEGAL: all.add(this);
      this.fld = &#239;nitialized";
   }
   def Main(Array[String](1)):Void {
      finish{
        async {new Escaper();}
        async {
          for (e in Escaper.all) 
            assert(e.fld == &#239;nitialized");
        }
      }
   }
}
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.2.1">
6.2.1</a>&nbsp;&nbsp;Initialization of Fields</h4>

<div class="p"><!----></div>
All fields of an object must be given a value before they are used.  There are
several ways that this can be accomplished: 

<ul>
<li> A <b>var</b> field of a type with a default value, if not otherwise
      initialized, 
      will have its type's default value. (<b>val</b> fields may not use this
      option; they must be given values explicitly, either by an initializer
      or by a constructor.)  For example, <b>(new C()).zero</b>
      in the example below will be zero, the default value of an <b>Int</b>.
<pre>
class C {
  var zero : Int;
}
</pre>
<div class="p"><!----></div>
</li>

<li> A field may have an explicit initializer, in which case its value is the
      value of the initializer.  <b>(new D()).one</b> is one.
<pre>
class D {
  val one = 1;
}
</pre>
<div class="p"><!----></div>
</li>

<li> A field may be given a value in a constructor, or in a method called
      from a constructor.  <b>(new E()).x</b> is two; <b>(new E(3)).x</b> is
      three. 
<pre>
class E {
   var x : Int;
   def this() { x = 2; }
   def this(n: Int) { 
      this.setX(n);
   }
   private final def setX(n:Int) {
     this.x = n;
   }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.2.2">
6.2.2</a>&nbsp;&nbsp;Calling Another Constructor</h4>

<div class="p"><!----></div>
A constructor for class <b>C</b> can call another constructor, either of
<b>C</b> itself or of <b>C</b>'s supertype.  The call to the other constructor
must be the first statement of the constructor body.

<div class="p"><!----></div>
<pre>
class C {
  val a : Int;
  def this(a:Int) { this.a = a; }
  def this() { 
     this(0); // call another constructor of C
  }
}
class D extends C {
  val b : Int; 
  def this(a:Int, b:Int) {
     super(a); // call superclass constructor
     this.b = b;
  }
}
</pre>

<div class="p"><!----></div>
No fields of <b>this</b> may be read before the optional <b>this</b>- or
<b>super</b>-call. For example, having <b>super(this.x);</b> as the
constructor-call is illegal, since it reads <b>this.x</b> before the
constructor-call.

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.2.3">
6.2.3</a>&nbsp;&nbsp;<b>property</b> Statement</h4>

<div class="p"><!----></div>
The <b>property</b> statement sets the properties of <b>this</b>; note that
properties may not be assigned to directly.  For example, 
<b>(new C(10)).x == 10</b>.
<pre>
class C(x:Int, y:Boolean) {
   def this(x:Int) {
      property(x, true);
   }
}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
The properties of <b>this</b> may be read after the <b>property</b> statement,
but not before it: 
<pre>
class C(x:Int, y:Boolean) {
   val z : Int;
   def this(x:Int) {
      // x cannot be read here.
      property(x, true);
      this.z = x+3;
   }
}
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.2.4">
6.2.4</a>&nbsp;&nbsp;Use of <b>this</b> in a Constructor Body</h4>

<div class="p"><!----></div>
After the optional constructor-call and optional <b>property</b> statement,
<b>this</b> <em>can</em> be used, subject to certain restrictions. 
We say that a method is <em>constructor-like</em> if it is <b>private</b>,
<b>final</b>, and obeys the following restrictions.

<div class="p"><!----></div>

<ul>
<li> <b>this</b> may not be assigned to anything. This prevents problematic
      cases such as: 
<pre>
class Outer {
   var leak : Inner;
   class Inner {
      def this() {
        //ILLEGAL: Outer.this.leak = this;
      }
   }
}
</pre>
(It also prevents harmless cases, such as <b>val nonleak = this;</b>
<div class="p"><!----></div>
</li>

<li> <b>this</b> may only be used as an argument or receiver of a
      constructor-like method call.  The following class definition is legal.
<pre>
class C {
  private final def ctorLike() {
    x10.io.Console.OUT.println("constructed");
  }
  def this() {
    this.ctorLike();
  }
}
</pre>
      It would not be legal if <b>private</b> or <b>final</b> were omitted, or
      if <b>ctorLike</b> called <b>x10.io.Console.OUT.println(this +
      "constructed");</b>.  (The implicit <b>this.toString()</b> call is a call to
      a non-constructor-like method.)
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Constructor code may refer to fields of <b>this</b> only after they have been
definitely assigned.&#167;  For example: 
<pre>
class C {
  val d : Int, e:Int; var f: Int;
  def this() {
    // ILLEGAL: f = d - 1; 
    d = 1;
    e = d + 2;

<div class="p"><!----></div>
  }
}
</pre>

<div class="p"><!----></div>
The bodies of constructor-like methods called from constructors may only read
fields of <b>this</b> which have been initialized at the point that the method
was called.  They differ from true constructor bodies in that only 
constructor bodies, not constructor-like methods, may assign to <b>val</b>
fields. 
<pre>
class C {
  val m: Int;
  var n:Int; 
  private final def ctorLike() {
     n = m + 3;
     }
  def this() { 
     //ILLEGAL: ctorLike();
     m = 7;
     ctorLike();
     }
}
</pre>

<div class="p"><!----></div>

</body>
</html>