<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Where Clauses</title>
</head>

<body>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Where clauses</h2><a name="DepType:WhereClauses">
</a>

<div class="p"><!----></div>
There is a general recipe for constructing a list of parameters or
properties <tt>T1(:c1) x1, ... , Tk(:ck) xk</tt> that must satisfy a given
(satisfiable) constraint <tt>c</tt>. 

<div class="p"><!----></div>
<pre>
class Foo (T1 (: (T2 x2; ...; Tk xk;  c) x1, 
       T2 (: (T3 x3; ...; Tk xk;  c) x2, 
        ...
       Tk (:  c) xk)  
 ...

</pre>

<div class="p"><!----></div>
The first type <tt>T1 (:T2 x2;...;Tk xk; c) x1</tt> is consistent iff
<tt>(exists T1 x1, T2 x2,..., Tk xk) c</tt> is consistent. The second is
consistent iff
<pre>
forall T1(: exists (T2 x2,..., Tk xk) c) x1
exists T2 x2. (exists T3 x2,..., Tk xk) c
</pre>

<div class="p"><!----></div>
 But this is always true. Similarly for the conditions for the other
properties.

<div class="p"><!----></div>
Thus logically every satisfiable constraint <tt>c</tt> on a list of parameters
<tt>x1,..., xk</tt> can be expressed using the dependent types of xi, provided
that the constraint language is rich enough to permit existential
quantifiers.

<div class="p"><!----></div>
Nevertheless we will find it convenient to permit the programmer to
explicitly specify a depclause after the list of properties, thus:
<pre>
class Point(int i, int j) { ... }
class Line(Point start, Point end :  end != start) 
  { ... }
class Triangle (Line a, Line b, Line c 
       : a.end == b.start &amp;&amp; b.end == c.start &amp;&amp;
         c.end == a.start) { ... }
class SolvableQuad(int a, int b, int c 
                   : a*x*x+b*x+c==0)  { ... }
class Circle (int r, int x, int y 
              : r &#62; 0 &amp;&amp; r*r==x*x+y*y){ ... }
class NonEmptyList extends List(: n &#62; 0) {...}
</pre>

<div class="p"><!----></div>
Consider the definition of the class <tt>Line</tt>. This may be thought of as
saying: the class <tt>Line</tt> has two fields, <tt>Point start</tt> and <tt>Point
end</tt>. Further, every instance of Line must satisfy the constraint that
<tt>end !=start</tt>. Similarly for the other class definitions. 

<div class="p"><!----></div>
In the general case, the production for <tt>NormalClassDeclaration</tt>
specifies that the list of properties may be followed by a <tt>
WhereClause</tt>:

<div class="p"><!----></div>
<pre>
NormalClassDeclaration ::= 
    ClassModifiersopt class identifier 
    PropertyListopt Superopt Interfacesopt ClassBody

<div class="p"><!----></div>
NormalInterfaceDeclaration ::= 
   InterfaceModifiersopt interface identifier 
   PropertyListopt ExtendsInterfacesopt InterfaceBody

<div class="p"><!----></div>
PropertyList     ::= ( Properties WhereClauseopt )
</pre>

<div class="p"><!----></div>
All the properties in the list, together with inherited properties,
may appear in the <tt>WhereClause</tt>. A property list <tt>T1 x1, ...., Tn xn : c</tt>
for a class <tt>Foo</tt> is said to be consistent if each of the <tt>Ti</tt> are
consistent and the constraint
<pre>
      exists  T1 x1, ..., Tn xn, Foo self . c
</pre>

<div class="p"><!----></div>
 is valid (always true).

</body>
</html>