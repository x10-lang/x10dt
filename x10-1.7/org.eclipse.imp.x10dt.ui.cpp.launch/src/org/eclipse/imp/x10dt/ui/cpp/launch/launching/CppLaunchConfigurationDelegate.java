/*******************************************************************************
 * Copyright (c) 2009 IBM Corporation.                                         *
 * All rights reserved. This program and the accompanying materials            *
 * are made available under the terms of the Eclipse Public License v1.0       *
 * which accompanies this distribution, and is available at                    *
 * http://www.eclipse.org/legal/epl-v10.html                                   *
 *******************************************************************************/
package org.eclipse.imp.x10dt.ui.cpp.launch.launching;

import static org.eclipse.ptp.core.IPTPLaunchConfigurationConstants.ATTR_EXECUTABLE_PATH;
import static org.eclipse.ptp.core.IPTPLaunchConfigurationConstants.ATTR_WORK_DIRECTORY;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.filesystem.EFS;
import org.eclipse.core.filesystem.IFileStore;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.debug.core.ILaunch;
import org.eclipse.debug.core.ILaunchConfiguration;
import org.eclipse.debug.core.ILaunchManager;
import org.eclipse.imp.utils.ConsoleUtil;
import org.eclipse.imp.x10dt.ui.cpp.launch.Constants;
import org.eclipse.imp.x10dt.ui.cpp.launch.LaunchCore;
import org.eclipse.imp.x10dt.ui.cpp.launch.LaunchMessages;
import org.eclipse.imp.x10dt.ui.cpp.launch.builder.CppBuilder;
import org.eclipse.imp.x10dt.ui.cpp.launch.utils.IResourceUtils;
import org.eclipse.imp.x10dt.ui.cpp.launch.utils.RemoteProcessOutputListener;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.osgi.util.NLS;
import org.eclipse.ptp.core.attributes.AttributeManager;
import org.eclipse.ptp.core.elementcontrols.IResourceManagerControl;
import org.eclipse.ptp.core.elements.IPJob;
import org.eclipse.ptp.core.elements.IPQueue;
import org.eclipse.ptp.core.elements.IResourceManager;
import org.eclipse.ptp.core.elements.attributes.JobAttributes;
import org.eclipse.ptp.debug.core.IPDebugger;
import org.eclipse.ptp.debug.core.launch.IPLaunch;
import org.eclipse.ptp.launch.ParallelLaunchConfigurationDelegate;
import org.eclipse.ptp.launch.messages.Messages;
import org.eclipse.ptp.remote.core.IRemoteConnection;
import org.eclipse.ptp.remote.core.IRemoteFileManager;
import org.eclipse.ptp.remote.core.IRemoteProcess;
import org.eclipse.ptp.remote.core.IRemoteProcessBuilder;
import org.eclipse.ptp.remote.core.IRemoteServices;
import org.eclipse.ptp.remote.core.PTPRemoteCorePlugin;
import org.eclipse.ptp.rmsystem.IResourceManagerConfiguration;
import org.eclipse.ui.console.MessageConsole;
import org.eclipse.ui.console.MessageConsoleStream;

import polyglot.ext.x10cpp.ExtensionInfo;

/**
 * Performs linking and launching of C++ application generated by X10 back-end.
 * 
 * @author egeay
 */
public final class CppLaunchConfigurationDelegate extends ParallelLaunchConfigurationDelegate {

  // --- Overridden methods
  
  protected AttributeManager getAttributeManager(final ILaunchConfiguration configuration, 
                                                 final String mode) throws CoreException {
    final IResourceManagerControl resourceManager = (IResourceManagerControl) getResourceManager(configuration);
    if (resourceManager == null) {
      throw new CoreException(new Status(IStatus.ERROR, LaunchCore.PLUGIN_ID, LaunchMessages.CLCD_NoResManagerError));
    }

    final AttributeManager attrMgr = new AttributeManager();

    // Collects attributes from Resource tab
    attrMgr.addAttributes(getResourceAttributes(configuration, mode));

    // Makes sure there is a queue, even if the resources tab doesn't require one to be specified.
    if (attrMgr.getAttribute(JobAttributes.getQueueIdAttributeDefinition()) == null) {
      final IPQueue queue = getQueueDefault(resourceManager);
      attrMgr.addAttribute(JobAttributes.getQueueIdAttributeDefinition().create(queue.getID()));
    }

    // Collects attributes from Application tab
    final IPath programPath = verifyExecutablePath(configuration);
    attrMgr.addAttribute(JobAttributes.getExecutableNameAttributeDefinition().create(programPath.lastSegment()));

    final String path = programPath.removeLastSegments(1).toString();
    if (path != null) {
      attrMgr.addAttribute(JobAttributes.getExecutablePathAttributeDefinition().create(path));
    }

    // Collects attributes from Arguments tab
    final String wd = verifyWorkDirectory(configuration);
    if (wd != null) {
      attrMgr.addAttribute(JobAttributes.getWorkingDirectoryAttributeDefinition().create(wd));
    }

    final String[] argArr = getProgramArguments(configuration);
    if (argArr != null) {
      attrMgr.addAttribute(JobAttributes.getProgramArgumentsAttributeDefinition().create(argArr));
    }

    // Collects attributes from Environment tab
    final String[] envArr = getEnvironmentToAppend(configuration);
    if (envArr != null) {
      attrMgr.addAttribute(JobAttributes.getEnvironmentAttributeDefinition().create(envArr));
    }

    // PTP launched this job
    attrMgr.addAttribute(JobAttributes.getLaunchedByPTPFlagAttributeDefinition().create(true));
    
    if (mode.equals(ILaunchManager.DEBUG_MODE)) { 
      final String hostAddress = getDebugHostAddress(resourceManager);
      attrMgr.addAttribute(X10DebugAttributes.getDebuggerHostAddressAttributeDefinition().create(hostAddress));
    }
    
    return attrMgr;
  }
  
  protected void doCompleteJobLaunch(final ILaunchConfiguration configuration, final String mode, final IPLaunch launch, 
                                     final AttributeManager mgr, final IPDebugger debugger, final IPJob job) {
    if (mode.equals(ILaunchManager.DEBUG_MODE)) {
      job.setDebug();
    }
    super.doCompleteJobLaunch(configuration, mode, launch, mgr, debugger, job);
  }
  
  public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, 
                     final IProgressMonitor monitor) throws CoreException {
    final IResourceManager resourceManager = getResourceManager(configuration);
    try {
      // Performs linking first.
      monitor.beginTask(null, 10);
      monitor.subTask(LaunchMessages.CLCD_ExecCreationTaskName);
      createExecutable(resourceManager, configuration, verifyProject(configuration), new SubProgressMonitor(monitor, 3));
      
      // Then, performs the launch.
      monitor.subTask(LaunchMessages.CLCD_LaunchCreationTaskName);
      super.launch(configuration, mode, launch, new SubProgressMonitor(monitor, 7));
    } finally {
      monitor.done();
    }
  }
  
  // Override for Cygwin, which needs a ".exe" here
  protected IPath verifyExecutablePath(ILaunchConfiguration configuration) throws CoreException {
    try {
      return super.verifyExecutablePath(configuration);
    } catch (CoreException e) {
      if (!e.getStatus().getMessage().equals(Messages.AbstractParallelLaunchConfigurationDelegate_Application_file_does_not_exist))
        throw e;
      // Try to append ".exe"
      String exePath = getExecutablePath(configuration) + ".exe"; //$NON-NLS-1$
      try {
    	  return verifyResource(exePath, configuration);
      } catch (CoreException e1) {
    	  throw e; // this was the original error
      }
    }
  }
  
  // --- Private code
  
  private String getDebugHostAddress(final IResourceManagerControl rm) {
     final IResourceManagerConfiguration rmc = rm.getConfiguration(); 
    /*  FIXME rmc.testOption doesn't exist when rmc is not an AbstractRemoteResourceManagerConfiguration   
    if (rmc.testOption(IRemoteProxyOptions.PORT_FORWARDING)) {
      final IRemoteServices remServices = PTPRemoteCorePlugin.getDefault().getRemoteServices(rmc.getRemoteServicesId());
      final IRemoteUIServices remUIServices = PTPRemoteUIPlugin.getDefault().getRemoteUIServices(remServices);
        if (remServices != null && remUIServices != null) {
        final IRemoteConnection rmConn = remServices.getConnectionManager().getConnection(rmc.getConnectionName());
        return rmConn.getAddress();
      }
    } else {
      final String localAddress = rmc.getLocalAddress();
      if (localAddress != null) {
        return localAddress;
      }
      try {
        final InetAddress ip = InetAddress.getLocalHost();
        return ip.getHostAddress();
      } catch (UnknownHostException except) {
        // Simply forgets
      }
    }
    */
    return null;
  }
  
  private void createExecutable(final IResourceManager resourceManager, final ILaunchConfiguration configuration,
                                final IProject project, final IProgressMonitor monitor) throws CoreException {
    final IRemoteFileManager fileManager = CppBuilder.getFileManager(resourceManager);
    try {
      final String workspaceDir = configuration.getAttribute(ATTR_WORK_DIRECTORY, (String) null);
      final String appProgName = configuration.getAttribute(ATTR_EXECUTABLE_PATH, (String) null);
      final boolean shouldLinkApp = configuration.getAttribute(Constants.ATTR_SHOULD_LINK_APP, true);

      IFileStore appProg = fileManager.getResource(appProgName);
      if (appProg.fetchInfo(EFS.NONE, monitor).exists() && !shouldLinkApp) {
    	  return;
      }
      // Cygwin needs a ".exe" here
      appProg = fileManager.getResource(appProgName + ".exe"); //$NON-NLS-1$
      if (appProg.fetchInfo(EFS.NONE, monitor).exists() && !shouldLinkApp) {
    	  return;
      }
      
      createMainFile(fileManager, appProgName, workspaceDir, monitor);
      
      final IPreferenceStore store = LaunchCore.getInstance().getPreferenceStore();
      final String x10DistLoc = store.getString(Constants.P_CPP_BUILDER_X10_DIST_LOC);
      final String pgasLoc = store.getString(Constants.P_CPP_BUILDER_PGAS_LOC);
      String linkCmdStart = store.getString(Constants.P_CPP_BUILDER_LINK_CMD);
      linkCmdStart = linkCmdStart.replace("${X10_DIST_LOC}", x10DistLoc); //$NON-NLS-1$
      linkCmdStart = linkCmdStart.replace("${PGAS_LOC}", pgasLoc); //$NON-NLS-1$
      
      final List<String> command = new ArrayList<String>();
      command.addAll(CppBuilder.getAllTokens(linkCmdStart));
      int insertionPoint = command.indexOf("#"); //$NON-NLS-1$
      if (insertionPoint == -1)
    	  insertionPoint = command.size();
      else
    	  command.remove(insertionPoint);
      command.add(insertionPoint++, "-L"+workspaceDir); //$NON-NLS-1$
      command.add(insertionPoint++, "-I"+workspaceDir); //$NON-NLS-1$
      command.add(insertionPoint++, workspaceDir+"/"+MAIN_FILE_NAME); //$NON-NLS-1$
      command.add(insertionPoint++, "-o"); //$NON-NLS-1$
      command.add(insertionPoint++, appProgName);
      command.add(insertionPoint++, "-l"+project.getName()); //$NON-NLS-1$
      
      final IRemoteProcessBuilder processBuilder = CppBuilder.getProcessBuilder(resourceManager, command);
      
      final IRemoteProcess process = processBuilder.start();
      
      final OutputStream errorStream = new ByteArrayOutputStream();
      final OutputStream outputStream = new ByteArrayOutputStream();
      new RemoteProcessOutputListener(process, outputStream, errorStream).start();
      
      process.waitFor();
      
      final int returnCode = process.exitValue();
      process.destroy();
      
      if (returnCode != 0) {
        IResourceUtils.addMarkerTo(project, NLS.bind(LaunchMessages.CLCD_LinkCmdError, command.toString()), 
                                   IMarker.SEVERITY_ERROR, project.getFullPath().toString(), IMarker.PRIORITY_HIGH);
        final MessageConsole messageConsole = ConsoleUtil.findConsole(LaunchMessages.CPPB_ConsoleName);
        final MessageConsoleStream mcStream = messageConsole.newMessageStream();
        mcStream.println(NLS.bind(LaunchMessages.CLCD_CmdUsedMsg, command.toString()));
        mcStream.println(errorStream.toString());
      }
    } catch (IOException except) {
      throw new CoreException(new Status(IStatus.ERROR, LaunchCore.PLUGIN_ID, LaunchMessages.CLCD_LinkExecError, except));
    } catch (InterruptedException except) {
      throw new CoreException(new Status(IStatus.CANCEL, LaunchCore.PLUGIN_ID, LaunchMessages.CLCD_LinkCancellation));
    }
  }
  
  private void createMainFile(final IRemoteFileManager fileManager, final String appProgName, 
                              final String workspaceDir, IProgressMonitor monitor) throws CoreException {
    final URL url = ExtensionInfo.class.getClassLoader().getResource(MAIN_TEMPLATE_FILE);
    try {
      if (url == null) {
        throw new FileNotFoundException(NLS.bind(LaunchMessages.CLCD_NoMainCPFileError, MAIN_TEMPLATE_FILE));
      } else {
        try {
          // Firstly, reads the content of the file and instantiates it with the main class name,
          final BufferedReader reader = new BufferedReader(new FileReader(new File(FileLocator.toFileURL(url).toURI())));
          
          final File tmpMainFile = new File(System.getProperty("java.io.tmpdir"), MAIN_FILE_NAME); //$NON-NLS-1$
          final BufferedWriter writer = new BufferedWriter(new FileWriter(tmpMainFile));          
          try {
            final StringBuilder sb = new StringBuilder();
            sb.append("#include \"").append(appProgName).append(".h\"\n"); //$NON-NLS-1$ //$NON-NLS-2$
            writer.write(sb.toString());
            final String progName = appProgName.substring(appProgName.lastIndexOf('/') + 1);
            
            String line = null;
            while ((line = reader.readLine()) != null) {
              writer.write(line.replace(PATTERN, progName).replace("##", "#") + '\n'); //$NON-NLS-1$ //$NON-NLS-2$
            }
          } finally {
            reader.close();
            writer.close();
          }
          IFileStore mainFile = EFS.getLocalFileSystem().getStore(new Path(tmpMainFile.getAbsolutePath()));
          // Secondly, transfers the file in the remote directory.
          IFileStore dir = fileManager.getResource(workspaceDir);
          IFileStore destFile = dir.getChild(MAIN_FILE_NAME);
          mainFile.copy(destFile, EFS.OVERWRITE, monitor);
          // Thirdly and finally, deletes the local temporary file.
          tmpMainFile.delete();
        } catch (URISyntaxException except) {
          // Should really never occur.
        } 
      }
    } catch (IOException except) {
      throw new CoreException(new Status(IStatus.ERROR, LaunchCore.PLUGIN_ID, LaunchMessages.CLCD_NoMainFileAccessIOError, 
                                         except));
    }
  }
  
  // --- Fields
  
  private static final String PATTERN = "#0"; //$NON-NLS-1$
  
  private static final String MAIN_FILE_NAME = "xxx_main_xxx.cc"; //$NON-NLS-1$
  
  private static final String MAIN_TEMPLATE_FILE = "data/MainMP.xcd"; //$NON-NLS-1$
  
}
