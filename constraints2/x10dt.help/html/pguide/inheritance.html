<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>Giving Up Inheritance To Get Efficiency</title>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Giving Up Inheritance To Get Efficiency</h2><a name="sec:guitge">
</a>

     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;What's The Problem</h3>

<div class="p"><!----></div>
This section is only here for motivation and may be skipped on first reading.
The real work begins in Section .

<div class="p"><!----></div>
Supporting inheritance does not come without costs when a program runs.  Looking
carefully at the class <tt>Point2D</tt> will show what happens:

<div class="p"><!----></div>

<blockquote>Let "<tt>public def doIt(p:Point2D) {...}</tt>" be a method declared in some
class or other (we don't care where).  We're going to look at the cost of
an invocation <tt>p.magnitude()</tt> within the body of <tt>doIt</tt>.

<ul>
<li> The value passed to <tt>doIt</tt> for <tt>p</tt>
might really be an instance of some subclass <tt>Point2DX</tt> of <tt>Point2D</tt>.  
One only knows when the program is run what actually gets passed.
<div class="p"><!----></div>
</li>

<li> The class <tt>Point2DX</tt> can
have its own implementation of <tt>magnitude</tt>, so we have to make sure
that if <tt>p</tt> really is a <tt>Point2DX</tt>, the right call is made.
<div class="p"><!----></div>
</li>

<li> Therefore, the running program has to be able to compute what <tt>p</tt>'s class is
in order to find the right code to call.
<div class="p"><!----></div>
</li>
</ul>
If there were no
inheritance hierarchy, the compiler itself could already determine the
correct code to call, completely eliminating this runtime lookup cost.

<div class="p"><!----></div>
The upshot is that whenever you have a <tt>Point2D</tt> you have to know
both where the object's data is and where information about the
object's class is. A <tt>Point2D</tt>, with its two <tt>Double</tt>s,
requires exactly 16 = 2*8 bytes to store the data an instance.
If we also store a pointer to its "class", we have to add at least 4 bytes,
and maybe up to 12 bytes or even more, depending on 

<blockquote>
1) what we had to store in
addition to the raw address of the class's info<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>, and

<div class="p"><!----></div>
2) on how many bytes are needed for the address itself: with today's
large memories, 6 (or even 8) bytes might be used for addresses.
</blockquote>

<div class="p"><!----></div>
Think about it.
If you have an array of one Meg of <tt>Point2D</tt>s at 16 bytes per <tt>Point2D</tt>, 
you use 16 megabytes for storing the data you're really interested in, 
and then another 6 megabytes or
more for type information (whether it is really needed or not!).  Sound like a good deal to you?
</blockquote>

<div class="p"><!----></div>
These considerations explain why a performance-oriented language avoids using
the normal class hierarchy for primitive types like 32-bit integers.

<div class="p"><!----></div>
<b>Major design issue:</b> How much of what classes give us can we keep without
incurring any substantial overhead?

<div class="p"><!----></div>
There are two sets of  issues here: serial issues like "don't waste space",
and "don't waste time looking stuff up",
and distribution issues like "don't create the possibility of inconsistencies between what one
processor thinks the value of the "thing" is and what another thinks, so that communication
between the processors is required to maintain integrity".

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;The Solution</h3><a name="sec:ecs">
</a>
What we need are <em>values</em> whose type must be exactly what they are declared to be.
 X10 calls these things (rather unfortunately) "<tt>struct</tt>s".
They bear about the same relation to the familiar <em>C</em> <tt>struct</tt> as X10 classes
do, but that's the way it is.

<div class="p"><!----></div>
As an example of an X10 struct, let us change our class <tt>Point2D</tt> to be 
a struct.  The only real difference is that the keyword <tt>struct</tt> replaces <tt>class</tt> in
the declaration:

<pre>&nbsp;1&nbsp;&nbsp;public&nbsp;struct&nbsp;Point2D&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;x:&nbsp;Double;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;y:&nbsp;Double;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(x:&nbsp;Double,&nbsp;y:&nbsp;Double)&nbsp;{
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x&nbsp;=&nbsp;x;&nbsp;&nbsp;this.y&nbsp;=&nbsp;y;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;magnitude()&nbsp;=&nbsp;x*x&nbsp;+&nbsp;y*y;
&nbsp;9&nbsp;}
</pre>
As usual, the line-by-line:

<div class="p"><!----></div>

<dl compact="compact">

	<dd><b>line 1:</b> The accessibility rules for a struct are the same as for a class.  We
chose "<tt>public</tt>" for the example, but the default is also possible, and if the struct is
declared in a class body, <tt>protected</tt> and <tt>private</tt> may also be used. 

<div class="p"><!----></div>
Structs may
be generic-that is, may have type parameters-although this one does not.</dd>

	<dd><b>lines 2 and 3:</b>  The instance members of a struct are always <tt>val</tt>s.
Once the constructor for a struct returns, the instance cannot be modified.
This eliminates the consistency problem: you can freely copy the instance
to remote <tt>Place</tt>s as need be. or share it among activities at a fixed
<tt>Place</tt>.

<div class="p"><!----></div>
Another benefit is that if <tt>s1</tt> and <tt>s2</tt> are
two instances of the same struct, then "<tt>s1 == s2</tt>" is true exactly when
you think it should be: when their instance members have identical values.  For example, now that
<tt>Point2D</tt> is a struct,  the expression <tt>p1 == p2</tt> is equivalent,
when both  <tt>p1</tt> and <tt>p2</tt> are <tt>Point2D</tt>s,
to <tt>(p1.x == p2.x) <br /></td><td width="150">
 (p1.y == p2.y)</tt>.

<div class="p"><!----></div>
If <tt>Point2D</tt> were still a class, then <tt>p1 == p2</tt> being true would mean that
<em><tt>p1</tt> and <tt>p2</tt> were both references to exactly the same instance of <tt><em>Point2D</em></tt>.</em>
This is a much stricter notion than that their instance members have the same values. 
You would have to use the method call <tt>p1.equals(p2)</tt> to do the weaker check 
of whether <tt>(p1.x == p2.x) <br /></td><td width="150">
 (p1.y == p2.y)</tt> is true.</dd>

	<dd><b>line 7:</b> Unlike their C namesakes, X10 structs can declare methods.
We've shown a public method here, but both private and default access (only in the
same package) can be used.
Structs <em>never</em> have subclasses,  so "protected," which just broadens the
default access by allowing access to subclasses, adds nothing
in this context.</dd>
</dl>

<div class="p"><!----></div>
We did not show it, but structs can have static methods and members.  In principle, one can
also define static classes in the body of a struct, just as one can in a class.  How often this is
needed is a good question, though: probably not often.   

<div class="p"><!----></div>
<b>Important: </b>The keyword <tt>new</tt> is <em>not</em> used when creating
 a new instance of a struct-in contrast to the story for classes.
Here is an example that assigns a <tt>Point2D</tt> value:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;p:&nbsp;Point2D&nbsp;=&nbsp;Point2D(1.2,&nbsp;3.4);
</pre>
Now that <tt>Point2D</tt> is a struct, there's no "<tt>new</tt>" on the right-hand side.
If you put the "<tt>new</tt>" in
by mistake, the compiler will happily generate an error message telling you
to remove it.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a> Furthermore,
you should understand that <tt><em>p</em></tt> <em>is <em>not</em> a reference to the</em> <tt>Point2D</tt>:
what is stored for <tt>p</tt> is the whole 16-bit value, not where to find that value.  
To repeat: <em>there are <em>no</em> references to instances of a struct.</em>   

<div class="p"><!----></div>

<div class="p"><!----></div>
The rules for what can be part of a struct are designed so that the compiler can determine the size of
an instance from the declaration.  The reason is storage efficiency:  once the size is
known, no more space need be allocated than is needed to store the value in memory,
and at runtime, we don't have to carry around size information for every instance.

<div class="p"><!----></div>
There is one more restriction to what can go into a struct that is critical:

<blockquote>
An instance <tt>s</tt> of a struct <tt>S</tt> cannot
have an instance member <tt>s.nextS</tt> that is itself also an <tt>S</tt>.</blockquote>
To understand what's at stake, it may help  if we try to declare a 
struct <tt>Point2DListItem</tt> so that we can form lists of <tt>Point2D</tt>s. 

<pre>public&nbsp;struct&nbsp;Point2DListItem&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;p:&nbsp;Point2D;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;point
&nbsp;&nbsp;&nbsp;public&nbsp;next&nbsp;Point2DListItem;&nbsp;//&nbsp;and&nbsp;its&nbsp;successor&nbsp;in&nbsp;the&nbsp;list.
}
</pre>
It may seem a bit weird that this is not legal-how <em>do</em> you form lists of these things?   
First, let's understand why this is not legal.
Ask yourself, "How big is a <tt>Point2DListItem</tt>?"   Well, a <tt>Point2D</tt> itself is
is 16 bytes, so if <tt>sizeOfPLI</tt> is the
size of a <tt>Point2DListItem</tt>,  then adding the sizes of the two instance members, we get a total
<tt>16 + sizeofPLI</tt>.
But that has to be the size of the whole <tt>Point2DListItem</tt> in which these are the 
instance members, and that size is only <tt>sizeOfPLI</tt>.
Oops!  Something is wrong.

<div class="p"><!----></div>
The way a C programmer uses structs to create lists is through
a declaration like "<tt>struct S {int a; int; b;</tt>  <tt>struct S *next}</tt>".
In other words,, you put a reference to a <tt>struct S</tt> in the body of the struct, and not a <tt>struct S</tt> itself.
Java works the same way: <tt>next</tt> will be a reference to an object.
The equivalent X10 would be to put a <tt>var</tt> (and not a <tt>val</tt>) of type <tt>S</tt> in the body, but that won't
do, because X10 structs simply cannot have members that are variables.

<div class="p"><!----></div>
So how <em>does</em> one design an X10 struct that is a list?  The short answer is: one does not.
Lists are introduced because a collection of uncertain eventual size is being grown, and one
therefore has to forego the efficiency of a pre-allocated array.  One pays the overhead of following a 
reference to the next item (rather than just bumping an array index to get there) so as to have the freedom
to grow and shrink the list efficiently as needed.  In other words: lists are by their very nature dynamic.
The whole point of a struct is that it is static: once constructed it cannot be modified.  Let's return
to our <tt>Point2DListItem</tt>.  If we declare it as follows, there is no problem:

<pre>&nbsp;class&nbsp;Point2DListItem&nbsp;{&nbsp;
&nbsp;&nbsp;public&nbsp;val&nbsp;&nbsp;p:&nbsp;Point2D;
&nbsp;&nbsp;public&nbsp;var&nbsp;&nbsp;next:&nbsp;Point2DListItem;
&nbsp;&nbsp;...
}
</pre>
Because <tt>Point2DListItem</tt> is now a class (not a struct),  the member <tt>next</tt> references an object,
namely some instance of that class.  The size required for a reference has nothing
to do with what is being referenced: an address is an address whether it refers to a small house or
a huge factory.   So in this formulation, the size of <tt>Poin2DListItem</tt> is 16 bytes for the struct <tt>p</tt>
plus however many bytes a reference requires.  
If you changed <tt>p</tt> from a <tt>val</tt> to a <tt>var</tt>,  the storage and access
to <tt>p</tt> would be the same, but now you could assign new <tt>Point2D</tt>'s to it as needed.

<div class="p"><!----></div>
<b>Some good advice for all: </b>  No language that expects high performance can allow a 4-byte integer to
consume 16 bytes or more and be accessed indirectly.  For that reason, some object oriented
languages distinguish between primitive "value" types and derived "reference" types that
are built on top of the primitive types.  Java is a good example, and X10 another.  They
took different approaches.  Java tried to be close to the physical reality of the CPU.
X10 tried to keep the value and reference types as close to one another as possible.

<div class="p"><!----></div>
X10's approach allowed it to expose the mechanism,
<tt>struct</tt>s, that it uses to implement its primitive types,
so that X10 programmers can eke out efficiencies, too.  <em>We want to warn you,
though, not to overuse structs.</em>   The inheritance hierarchy that classes provide is a powerful
mechanism for organizing information, the advantages of which in many situations, if not most,
far outweigh any performance loss.   

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>
For example, information required to do automatic garbage collection
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>The rationale is probably that you are just describing a value,
not requesting storage that the run-time is obligated to manage.
<br /><br />

</html>