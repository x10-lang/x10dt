<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>Overview of X10</title>
<a href="#tth_chAp1">Overview of X10</a> <br/>
<ul>
<li><a href="#tth_sEc1">Object-oriented features</a> <br/>
<li><a href="#tth_sEc2">The sequential core of X10</a> <br/>
<li><a href="#tth_sEc3">Places and activities</a> <br/>
<li><a href="#tth_sEc4">Clocks</a> <br/>
<li><a href="#tth_sEc5">Arrays, regions and distributions</a> <br/>
<li><a href="#tth_sEc6">Annotations</a> <br/>
<li><a href="#tth_sEc7">Translating MPI programs to X10</a> <br/>
<li><a href="#tth_sEc8">Summary and future work</a> <br/>
</ul>

<div class="p"><!----></div>
 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 2 </a><br />Overview of X10</h1>

<div class="p"><!----></div>
X10 is a statically typed object-oriented language, extending a sequential
core language with <em>places</em>, <em>activities</em>, <em>clocks</em>,
(distributed, multi-dimensional) <em>arrays</em> and <em>struct</em> types. All
these changes are motivated by the desire to use the new language for
high-end, high-performance, high-productivity computing.

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Object-oriented features</h2>

<div class="p"><!----></div>
The sequential core of X10 is a <em>container-based</em> object-oriented language
similar to Java and C++, and more recent languages such as Scala.  
Programmers write X10 code by defining containers for data and behavior
called 
<em>classes</em>
(&#167;) and
<em>structs</em>
(&#167;), 
often abstracted as 
<em>interfaces</em>
(&#167;).
X10 provides inheritance and subtyping in fairly traditional ways. 

<div class="p"><!----></div>
<b>Normed</b> describes entities with a <b>norm()</b> method. <b>Normed</b> is
intended to be used for entities with a position in some coordinate system,
and <b>norm()</b> gives the distance between the entity and the origin. A
<b>Slider</b> is an object which can be moved around on a line; a
<b>PlanePoint</b> is a fixed position in a plane. Both <b>Slider</b>s and
<b>PlanePoint</b>s have a sensible <b>norm()</b> method, and implement
<b>Normed</b>.

<div class="p"><!----></div>
<pre>
interface Normed {
  def norm():Double;
}
class Slider implements Normed {
  var x : Double = 0;
  public def norm() = Math.abs(x);
  public def move(dx:Double) { x += dx; }
}
struct PlanePoint implements Normed {
  val x : Double, y:Double;
  public def this(x:Double, y:Double) {
    this.x = x; this.y = y;
  }
  public def norm() = Math.sqrt(x*x+y*y);
}
</pre>


<div class="p"><!----></div>

<b>Interfaces&nbsp;&nbsp;</b>

<div class="p"><!----></div>
An X10 interface specifies a collection of abstract methods; <b>Normed</b>
specifies just <b>norm()</b>. Classes and
structs can be specified to <em>implement</em> interfaces, as <b>Slider</b> and
<b>PlanePoint</b> implement <b>Normed</b>, and, when they do so, must provide
all the methods that the interface demands.

<div class="p"><!----></div>
Interfaces are
purely abstract. Every value of type <b>Normed</b> must be an instance of some
class like <b>Slider</b> or some struct like <b>PlanePoint</b> which implements
<b>Normed</b>; no value can be <b>Normed</b> and nothing else. 

<div class="p"><!----></div>

<b>Classes and Structs&nbsp;&nbsp;</b>

<div class="p"><!----></div>
There are two kinds of containers: <em>classes</em>
(&#167;) and <em>structs</em> (&#167;). Containers hold
data in <em>fields</em>, and give concrete implementations of 
methods, as <b>Slider</b> and <b>PlainPoint</b> above.

<div class="p"><!----></div>
Classes are organized in a single-inheritance tree: a class may have only a
single parent class, though it may implement many interfaces and have many
subclasses. Classes may have mutable fields, as <b>Slider</b> does.

<div class="p"><!----></div>
In contrast, structs are headerless values, lacking the internal organs
which give objects their intricate behavior.  This makes them less powerful
than objects (<em>e.g.</em>, structs cannot inherit methods, though objects can), but also
cheaper (<em>e.g.</em>, they can be inlined, and they require less space than objects).  
Structs are immutable, though their fields may be immutably set to objects
which are themselves mutable.  They behave like objects in all ways consistent
with these limitations; <em>e.g.</em>, while they cannot <em>inherit</em> methods, they can
have them - as <b>PlanePoint</b> does.

<div class="p"><!----></div>
X10 has no primitive classes per se. However, the standard library
<b>x10.lang</b> supplies structs and objects <b>Boolean</b>, <b>Byte</b>,
<b>Short</b>, <b>Char</b>, <b>Int</b>, <b>Long</b>, <b>Float</b>, <b>Double</b>,
<b>Complex</b> and <b>String</b>. The user may defined additional arithmetic
structs using the facilities of the language.

<div class="p"><!----></div>

<b>Functions.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
X10 provides functions (&#167;) to allow code to be used
as values.  Functions are first-class data: they can be stored in lists,
passed between activities, and so on.  <b>square</b>, below, is a function
which squares an <b>Int</b>.  <b>of4</b> takes an <b>Int</b>-to-<b>Int</b>
function and applies it to the number <b>4</b>.  So, <b>fourSquared</b> computes
<b>of4(square)</b>, which is <b>square(4)</b>, which is 16, in a fairly
complicated way.
<pre>
  val square = (i:Int) =&#62; i*i;
  val of4 = (f: (Int)=&#62;Int) =&#62; f(4);
  val fourSquared = of4(square);
</pre>

<div class="p"><!----></div>
Functions are used extensively in X10
programs.  For example, a common way to construct and initialize an <b>Array[Int](1)</b> -
that is, a fixed-length one-dimensional array of numbers, like an <b>int[]</b> in Java - is to
pass two arguments to a factory method: the first argument being the length of
the array, and the second being a function which computes the initial value of
the <b>i</b><sup>th</sup> element.  The following code constructs a 1-dimensional
array 
initialized to the squares of 0,1,...,9: <b>r(0) == 0</b>, <b>r(5)==25</b>, etc. 
<pre>
  val r : Array[Int](1) = new Array[Int](10, square);
</pre>

<div class="p"><!----></div>

<b>Constrained Types&nbsp;&nbsp;</b>

<div class="p"><!----></div>
X10 containers may declare <em>properties</em>, which are fields bound immutably
at the creation of the container.  The static analysis system understands
properties, and can work with them logically.   

<div class="p"><!----></div>
For example, an implementation of matrices <b>Mat</b> might have the numbers of
rows and columns as properties.  A little bit of care in definitions allows
the definition of a <b>+</b> operation that works on matrices of the same
shape, and <b>*</b> that works on matrices with appropriately matching shapes.
<pre>
abstract class Mat(rows:Int, cols:Int) {
 static type Mat(r:Int, c:Int) = Mat{rows==r&amp;&amp;cols==c};
 abstract operator this + (y:Mat(this.rows,this.cols))
                 :Mat(this.rows, this.cols);
 abstract operator this * (y:Mat) {this.cols == y.rows} 
                 :Mat(this.rows, y.cols);
</pre>

<div class="p"><!----></div>
The following code typechecks (assuming that <b>makeMat(m,n)</b> is a function
which creates an "m&times;n" matrix).
However, an attempt to compute <b>axb1 + bxc</b> or
<b>bxc * axb1</b> would result in a compile-time type error:
<pre>
  static def example(a:Int, b:Int, c:Int) {
    val axb1 : Mat(a,b) = makeMat(a,b);
    val axb2 : Mat(a,b) = makeMat(a,b);
    val bxc  : Mat(b,c) = makeMat(b,c);
    val axc  : Mat(a,c) = (axb1 +axb2) * bxc;
    //ERROR: val wrong1 = axb1 + bxc;
    //ERROR: val wrong2 = bxc * axb1;
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
The "little bit of care" shows off many of the features of constrained
types.    
The <b>(rows:Int, cols:Int)</b> in the class definition declares two
properties, <b>rows</b> and <b>cols</b>.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>  

<div class="p"><!----></div>
A constrained type looks like <b>Mat{rows==r &amp;&amp; cols==c}</b>: a type
name, followed by a Boolean expression in braces.  
The <b>type</b> declaration on the second line makes
<b>Mat(r,c)</b> be a synonym for <b>Mat{rows==r &amp;&amp; cols==c}</b>,
allowing for compact types in many places.

<div class="p"><!----></div>
Functions can return constrained types.  
The <b>makeMat(r,c)</b> method returns a <b>Mat(r,c)</b> - a matrix whose shape
is given by the arguments to the method.    In
particular, constructors can have constrained return types to provide specific
information about the constructed values.

<div class="p"><!----></div>
The arguments of methods can have type constraints as well.  The 
<b>operator this +</b> line lets <b>A+B</b> add two matrices.  The type of the
second argument <b>y</b> is constrained to have the same number of rows and
columns as the first argument <b>this</b>. Attempts to add mismatched matrices
will be flagged as type errors at compilation.

<div class="p"><!----></div>
At times it is more convenient to put the constraint on the method as a whole,
as seen in the <b>operator this *</b> line. Unlike for <b>+</b>, there is no
need to constrain both dimensions; we simply need to check that the columns of
the left factor match the rows of the right. This constraint is written in
<b>{...}</b> after the argument list.  The shape of the result is computed from
the shapes of the arguments.

<div class="p"><!----></div>
And that is all that is necessary for a user-defined class of matrices to have
shape-checking for matrix addition and multiplication.  The <b>example</b>
method compiles under those definitions.

<div class="p"><!----></div>

<b>Generic types&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Containers may have type parameters, permitting the definition of
<em>generic types</em>.  Type parameters may be instantiated by any X10 type.  It
is thus possible to make a list of integers <b>List[Int]</b>, a list of
non-zero integers <b>List[Int{self != 0}]</b>, or a list of people
<b>List[Person]</b>.  In the definition of <b>List</b>, <b>T</b> is a type
parameter; it can be instantiated with any type.
<pre>
class List[T] {
    var head: T;
    var tail: List[T];
    def this(h: T, t: List[T]) { head = h; tail = t; }
    def add(x: T) {
        if (this.tail == null)
            this.tail = new List[T](x, null);
        else
            this.tail.add(x);
    }
}
</pre>
The constructor (<b>def this</b>) initializes the fields of the new object.
The <b>add</b> method appends an element to the list.
<b>List</b> is a generic type.  When  instances of <b>List</b> are
allocated, the type parameter <b>T</b> must be bound to a concrete
type.  <b>List[Int]</b> is the type of lists of element type
<b>Int</b>, <b>List[List[String]]</b> is the type of lists whose elements are
themselves lists of string, and so on.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;The sequential core of X10</h2>

<div class="p"><!----></div>
The sequential aspects of X10 are mostly familiar from C and its progeny.
X10 enjoys the familiar control flow constructs: <b>if</b> statements,
<b>while</b> loops, <b>for</b> loops, <b>switch</b> statements, <b>throw</b> to
raise exceptions and <b>try...catch</b> to handle them, and so on.

<div class="p"><!----></div>
X10 has both implicit coercions and explicit conversions, and both can be
defined on user-defined types.  Explicit conversions are written with the
<b>as</b> operation: <b>n as Int</b>.  The types can be constrained: 
<b>n as Int{self != 0}</b> converts <b>n</b> to a non-zero integer, and throws a
runtime exception if its value as an integer is zero.

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Places and activities</h2>

<div class="p"><!----></div>
The full power of X10 starts to emerge with concurrency.
An X10 program is intended to run on a wide range of computers,
from uniprocessors to large clusters of parallel processors supporting
millions of concurrent operations. To support this scale, X10
introduces the central concept of <em>place</em> (&#167;).
A place can be thought of as a virtual shared-memory multi-processor:
a computational unit with a finite (though perhaps changing) number of
hardware threads and a bounded amount of shared memory, uniformly
accessible by all threads.

<div class="p"><!----></div>
An X10 computation acts on <em>values</em>(&#167;) through
the execution of lightweight threads called
<em>activities</em>(&#167;). 
An <em>object</em>
 has a small, statically fixed set of fields, each of
which has a distinct name. A scalar object is located at a single place and
stays at that place throughout its lifetime. An <em>aggregate</em> object has
many fields (the number may be known only when the object is created),
uniformly accessed through an index (<em>e.g.</em>, an integer) and may be distributed
across many places. The distribution of an aggregate object remains unchanged
throughout the computation, thought different aggregates may be distributed
differently. Objects are garbage-collected when no longer useable; there are
no operations in the language to allow a programmer to explicitly release
memory.

<div class="p"><!----></div>
X10 has a <em>unified</em> or <em>global address space</em>. This means that
an activity can reference objects at other places. However, an activity may
synchronously access data items only in the current place, the place in which
it is running. It may atomically update one or more data items, but only in
the current place.   If it becomes necessary to read or modify an object at
some other place <b>q</b>, the <em>place-shifting</em> operation <b>at(q;F)</b> can
be used, to move part of the activity to <b>q</b>.  <b>F</b> is a specification
of what information will be sent to <b>q</b> for use by that part of the
computation. 
It is easy to compute
across multiple places, but the expensive operations (<em>e.g.</em>, those which require
communication) are readily visible in the code. 

<div class="p"><!----></div>

<b>Atomic blocks.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
X10 has a control construct <b>atomic S</b> where <b>S</b> is a statement with
certain restrictions. <b>S</b> will be executed atomically, without
interruption by other activities. This is a common primitive used in
concurrent algorithms, though rarely provided in this degree of generality by
concurrent programming languages.

<div class="p"><!----></div>
More powerfully - and more expensively - X10 allows conditional atomic
blocks, <b>when(B)S</b>, which are executed atomically at some point when
<b>B</b> is true.  Conditional atomic blocks are one of the strongest
primitives used in concurrent algorithms, and one of the least-often
available. 

<div class="p"><!----></div>

<b>Asynchronous activities.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
An asynchronous activity is created by a statement <b>async S</b>, which starts
up a new activity running <b>S</b>.  It does not wait for the new activity to
finish; there is a separate statement (<b>finish</b>) to do that.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Clocks</h2>
The MPI style of coordinating the activity of multiple processes with
a single barrier is not suitable for the dynamic network of heterogeneous
activities in an X10 computation.  
X10 allows multiple barriers in a form that supports determinate,
deadlock-free parallel computation, via the <b>Clock</b> type.

<div class="p"><!----></div>
A single <b>Clock</b> represents a computation that occurs in phases.
At any given time, an activity is <em>registered</em> with zero or more clocks.
The X10 statement <b>next</b> tells all of an activity's registered clocks that
the activity has finished the current phase, and causes it to wait for the
next phase.  Other operations allow waiting on a single clock, starting
new clocks or new activities registered on an extant clock, and so on. 

<div class="p"><!----></div>

<div class="p"><!----></div>
Clocks act as barriers for a dynamically varying collection of activities.
They generalize the barriers found in MPI style program in that an activity
may use multiple clocks simultaneously. Yet programs using clocks properly are
guaranteed not to suffer from deadlock.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Arrays, regions and distributions</h2>

<div class="p"><!----></div>
X10 provides <b>DistArray</b>s, <em>distributed arrays</em>, which spread data
across many places. An underlying <b>Dist</b> object provides the <em>
distribution</em>, telling which elements of the <b>DistArray</b> go in which
place. <b>Dist</b> uses subsidiary <b>Region</b> objects to abstract over the
shape and even the dimensionality of arrays.
Specialized X10 control statements such as <b>ateach</b> provide efficient
parallel iteration over distributed arrays.

<div class="p"><!----></div>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Annotations</h2>

<div class="p"><!----></div>
X10 supports annotations on classes and interfaces, methods
and constructors,
variables, types, expressions and statements.
These annotations may be processed by compiler plugins.

<div class="p"><!----></div>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Translating MPI programs to X10</h2>

<div class="p"><!----></div>
While X10 permits considerably greater flexibility in writing
distributed programs and data structures than MPI, it is instructive
to examine how to translate MPI programs to X10.

<div class="p"><!----></div>
Each separate MPI process can be translated into an X10
place. Async activities may be used to read and write variables
located at different processes. A single clock may be used for barrier
synchronization between multiple MPI processes. X10 collective
operations may be used to implement MPI collective operations.
X10 is more general than MPI in (a)&#241;ot requiring synchronization
between two processes in order to enable one to read and write the
other's values, (b)&#126;permitting the use of high-level atomic blocks
within a process to obtain mutual exclusion between multiple
activities running in the same node (c)&#126;permitting the use of multiple
clocks to combine the expression of different physics (e.g.,
computations modeling blood coagulation together with computations
involving the flow of blood), (d)&#241;ot requiring an SPMD style of
computation.

<div class="p"><!----></div>

 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Summary and future work</h2>

     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Design for scalability</h3>
X10 is designed for scalability, by encouraging working with local data,
and limiting the ability of events at one place to delay those at another. For
example, an activity may atomically access only multiple locations in the
current place. Unconditional atomic blocks are dynamically guaranteed to be
non-blocking, and may be implemented using non-blocking techniques that avoid
mutual exclusion bottlenecks. 
Data-flow synchronization permits point-to-point
coordination between reader/writer activities, obviating the need for
barrier-based or lock-based synchronization in many cases.

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Design for productivity</h3>
X10 is designed for productivity.

<div class="p"><!----></div>

<b>Safety and correctness.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Programs written in X10 are guaranteed to be statically
<em>type safe</em>, <em>memory safe</em> and <em>pointer safe</em>. 

<div class="p"><!----></div>
Static type safety guarantees that every location contains only values whose
dynamic type agrees with the location's static type. The compiler allows a
choice of how to handle method calls. In strict mode, method calls are
statically checked to be permitted by the static types of operands. In lax
mode, dynamic checks are inserted when calls may or may not be correct,
providing weaker static correctness guarantees but more programming
convenience. 

<div class="p"><!----></div>
Memory safety guarantees that an object may only access memory within its
representation, and other objects it has a reference to. X10 does not
permit 
pointer arithmetic, and bound-checks array accesses dynamically if necessary.
X10 uses garbage collection to collect objects no longer referenced by any
activity. X10 guarantees that no object can retain a reference to an
object whose memory has been reclaimed. Further, X10 guarantees that every
location is initialized at run time before it is read, and every value read
from a word of memory has previously been written into that word.

<div class="p"><!----></div>

<div class="p"><!----></div>
Because places are reflected in the type system, static type safety
also implies <em>place safety</em>. All operations that need to be performed
locally are, in fact, performed locally.  All data which is declared to be
stored locally are, in fact, stored locally.

<div class="p"><!----></div>
X10 programs that use only clocks and unconditional atomic
blocks are guaranteed not to deadlock. Unconditional atomic blocks
are non-blocking, hence cannot introduce deadlocks.
Many concurrent programs can be shown to be determinate (hence
race-free) statically.

<div class="p"><!----></div>

<b>Integration.&nbsp;&nbsp;</b>
A key issue for any new programming language is how well it can be
integrated with existing (external) languages, system environments,
libraries and tools.

<div class="p"><!----></div>
We believe that X10, like Java, will be able to support a large
number of libraries and tools. An area where we expect future versions
of X10 to improve on Java like languages is <em>native
integration</em> (&#167;). Specifically, X10 will
permit multi-dimensional local arrays to be operated on natively by
native code.

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;Conclusion</h3>
X10 is considerably higher-level than thread-based languages in
that it supports dynamically spawning lightweight activities, the
use of atomic operations for mutual exclusion, and the use of clocks
for repeated quiescence detection.

<div class="p"><!----></div>
Yet it is much more concrete than languages like HPF in that it forces
the programmer to explicitly deal with distribution of data
objects. In this the language reflects the designers' belief that
issues of locality and distribution cannot be hidden from the
programmer of high-performance code in high-end computing.  A
performance model that distinguishes between computation and
communication must be made explicit and transparent.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>
At the same time we believe that the place-based type system and
support for generic programming will allow the X10 programmer to
be highly productive; many of the tedious details of
distribution-specific code can be handled in a generic fashion.
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>The class is officially declared
abstract to allow for multiple implementations, like sparse and band matrices,
but in fact is abstract to avoid having to write the actual definitions of
<b>+</b> and <b>*</b>.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>In this
X10 is similar to more modern languages such as ZPL [].
<br /><br />
</html>
