<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Method resolution</title>
</head>

<body>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Method Resolution</h2>


<a name="sect:MethodResolution">
</a>

<div class="p"><!----></div>
Method resolution is the problem of determining, statically, which method (or
constructor or operator)
should be invoked, when there are several choices that could be invoked.  For
example, the following class has two overloaded <b>zap</b> methods, one taking
an <b>Object</b>, and the other a <b>Resolve</b>.  Method resolution will figure
out that the call <b>zap(1..4)</b> should call <b>zap(Object)</b>, and
<b>zap(new Resolve())</b> should call <b>zap(Resolve)</b>.  

<div class="p"><!----></div>
<pre>
class Res {
  public static interface Surface {}
  public static interface Deface {}

<div class="p"><!----></div>
  public static class Ace implements Surface {
    public static operator (Boolean) : Ace = new Ace();
    public static operator (Place) : Ace = new Ace();
  }
  public static class Face implements Surface, Deface{}

<div class="p"><!----></div>
  public static class A {}
  public static class B extends A {}
  public static class C extends B {}

<div class="p"><!----></div>
  def m(x:A) = 0;
  def m(x:Int) = 1;
  def m(x:Boolean) = 2;
  def m(x:Surface) = 3;
  def m(x:Deface) = 4; 

<div class="p"><!----></div>
  def example() {
     assert m(100) == 1 : &#207;nt"; 
     assert m(new C()) == 0 : "C";
     // An Ace is a Surface, unambiguous best choice
     assert m(new Ace()) == 3 : &#196;ce";
     // ERROR: m(new Face());

<div class="p"><!----></div>
     // Boolean could be handled directly, or by 
     // implicit coercion Boolean -&#62; Ace.
     // Direct matches always win.
     assert m(here) == 3 : "Place";
     assert m(true) == 2 : "Boolean"; 

<div class="p"><!----></div>
  }
</pre>

<div class="p"><!----></div>
In the <b>&#207;nt"</b> line, there is a very close match.  <b>100</b> is an
<b>Int</b>.  In fact, <b>100</b> is an <b>Intself==100</b>, so even in this
case the type of the actual parameter is not <em>precisely</em> equal to the type
of the method.

<div class="p"><!----></div>
In the <b>"C"</b> line of the example, <b>new C()</b> is an instance of <b>C</b>,
which is a subtype of <b>A</b>, so the <b>A</b> method applies.  No other method
does, and so the <b>A</b> method will be invoked.

<div class="p"><!----></div>
Similarly, in the <b>&#196;ce"</b> line, the <b>Ace</b> class implements
<b>Surface</b>, and so <b>new Ace()</b> matches the <b>Surface</b> method. 

<div class="p"><!----></div>
However, a <b>Face</b> is both a <b>Surface</b> and a <b>Deface</b>, so there is
no unique best match for the invocation <b>m(new Face())</b>.  This invocation
would be forbidden, and a compile-time error issued.

<div class="p"><!----></div>
None of the defined methods match <b>Place</b>. However, there is an implicit
coercion (&#167;<a href="#sect:ImplicitCoercion">7.4</a>) from <b>Place</b> to <b>Ace</b>.  So, 
the <b>Ace</b> method will be called for <b>m(here)</b> - with the implicit
coercion applied to <b>here</b> before the method call.
(<b>Limitation: </b>: this does not currently compile in all cases.)

<div class="p"><!----></div>
For <b>m(true)</b>, both the <b>Boolean</b> and, with the implicit coercion,
<b>Ace</b> methods could apply.  Since the <b>Boolean</b> method applies
directly, and the <b>Ace</b> method requires an implicit coercion, this call
resolves to the <b>Boolean</b> method, without an error.

<div class="p"><!----></div>
The basic concept of method resolution is:

<ol type="1">
<li> List all the methods that could possibly be used, inferring generic
      types but not performing implicit coercions.    If the
      <b>STATIC_CALLS</b> compiler flag is specified, the constraints must
      match exactly at this step; if not, they do not, but run-time tests will
      be generated if necessary.
<div class="p"><!----></div>
</li>

<li> If one possible method is more specific than all the others, that one 
      is the desired method.
<div class="p"><!----></div>
</li>

<li> If there are two or more methods neither of which is more specific than
      the others, then the method invocation is ambiguous.  Method resolution
      fails and reports an error.
<div class="p"><!----></div>
</li>

<li> Otherwise, no possible methods were found without implicit coercions.
      Try the preceding steps again, but with coercions allowed.  If a single
      most specific method is found with coercions, it is the desired method.
      If there are several, the invocation is ambiguous and erronious.
<div class="p"><!----></div>
</li>

<li> If no methods were found even with coercions, then the method invocation
      is undetermined.  Method resolution fails and reports an error.
<div class="p"><!----></div>
</li>
</ol>

In the presence of X10's highly-detailed type system, some subtleties arise. 
One point, at least, is <em>not</em> subtle. The same procedure is used, <em>
mutatis mutandis</em> for method, constructor, and operator resolution.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Space of Methods</h3>

<div class="p"><!----></div>
X10 allows some constructs, particularly <b>operator</b>s, to be defined in a
number of ways, and invoked in a number of ways. This section specifies which
forms of definition could correspond to a given definiendum, and (redundantly)
the syntax for invoking that definition unambiguously.  

<div class="p"><!----></div>
Method invocations <b>a.m(b)</b>, where <b>a</b> is an expression, can be either
of the following forms.  There may be any number of arguments.

<ul>
<li> An instance method on <b>a</b>, of the form <b>def m(B)</b>, so that the
      invocation is <b>a.m(b)</b>;
<div class="p"><!----></div>
</li>

<li> A static method on <b>a</b>'s class, of the form <b>static def m(B)</b>, 
      so that the invocation is <b>A.m(b)</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Static method invocations, <b>A.m(b)</b>, where <b>A</b> is a container name,
can only be static.  There may be any number of arguments.

<ul>
<li> A static method on <b>A</b>, of the form <b>static def m(B)</b>, so that
      the invocation is <b>A.m(b)</b>;
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Constructor invocations, <b>new A(b)</b>, must invoke constructors. There may
be any number of arguments. 

<ul>
<li> A constructor on <b>A</b>, of the form <b>def this(B)</b>, so that the
      invocation is <b>new A(b)</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
A unary operator "&#8727; a" may be defined as: 

<ul>
<li> An instance operator on <b>A</b>, defined as 
      &#246;perator &#8727; this()", 
      so that the invocation is 
      &#228;.operator &#8727;()"; or
<div class="p"><!----></div>
</li>

<li> A static operator on <b>A</b>, defined as 
      &#246;perator &#8727;(a:A)"
      so that the invocation is 
      &#196;.operator &#8727;(a)"
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
A binary operator &#228; &#8727; b" may be defined as: 

<ul>
<li> An instance operator on <b>A</b>, defined as 
      &#246;perator this &#8727;(b:B)"; 
      so that the invocation is &#228;.operator &#8727;(b)", 
or
<div class="p"><!----></div>
</li>

<li> A right-hand operator on <b>B</b>, defined as
      &#246;perator (a:A) &#8727; this", 
      so that the invocation is "b.operator ()&#8727;(b)"; or
<div class="p"><!----></div>
</li>

<li> A static operator on <b>A</b>, defined as
      &#246;perator (a:A) &#8727; (b:B)", 
      so that the invocation is &#196;.operator &#8727;(a,b)"
; or
<div class="p"><!----></div>
</li>

<li> A static operator on <b>B</b>, if <b>A</b> and <b>B</b> are different
      classes, defined as
      &#246;perator (a:A) &#8727; (b:B)", so that the invocation is 
      "B.operator &#8727;(a,b)".
<div class="p"><!----></div>
</li>
</ul>

If none of those resolve to a method, then either operand may be cast to the
other. 
The following alternate calls are attempted: 

<ul>
<li> "(a as B).operator&#8727;(b)"
<div class="p"><!----></div>
</li>

<li> "(b as A).operator () &#8727;(a)"
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
An application <b>a(b)</b>, for any number of arguments, can only come from an
application definition: 

<ul>
<li> <b>operator this(b:B)</b>, so that the 
invocation is <b>a.operator()(b)</b>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
An indexed assignment, <b>a(b)=c</b>, for any number of <b>b</b>'s, can only
come from an indexed assignment definition: 

<ul>
<li> <b>operator this(b:B)=(c:C) {...}</b>, 
      so that the invocation is <b>a.operator()=(b,c)</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
An implicit coercion, as in 
<pre>
val a:A = ...;
... a as B ...
</pre>
can come from one of two places: an implicit coercion operation defined on
<b>B</b>, or, failing that, one defined on <b>A</b>:

<ol type="1">
<li> an implicit coercion in <b>B</b>:
      <b>static operator (a:A):B</b>, 
      so that the coercion is <b>B.operator[B](a)</b>;
<div class="p"><!----></div>
</li>

<li> or, failing that, an implicit coercion in <b>A</b>:
      <b>static operator this():B</b>,
      so that the coercion is <b>A.operator[B](a)</b>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
An explicit conversion <b>a as B</b> can come from an explicit conversion
operator, or an implicit coercion operator.  X10 tries three things, in order,
only checking 2 if 1 fails, and 3 if 2 fails: 

<ol type="1">
<li> An <b>as</b> operator in <b>B</b>: 
      &#223;tatic operator (a:A) as B", 
      so that the conversion is <b>B.operator as[B](a)</b>
;
<div class="p"><!----></div>
</li>

<li> or, failing that, an implicit coercion in <b>B</b>:
      <b>static operator (a:A):B</b>, so that the conversion is 
      <b>B.operator[B](a)</b>;
<div class="p"><!----></div>
</li>

<li> or, failing that, an implicit coercion in <b>A</b>:
      <b>static operator this():B</b>, so that the conversion is 
      <b>A.operator[B](a)</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;Possible Methods</h3>

<div class="p"><!----></div>
This section describes what it means for a method to be a <em>possible</em>
resolution of a method invocation.  

<div class="p"><!----></div>
Generics introduce several subtleties, especially with the inference of
generic types. 
For the purposes of method resolution, all that matters about a method,
constructor, or operator <b>M</b> - we use the word "method" to include all
three choices for this section - is its signature, plus which method it is.
So, a typical <b>M</b> might look like 
"def m[G<sub>1</sub>,&#8230;, G<sub>g</sub>](x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>){c} =...".  The code body <b>...</b> is irrelevant for the purpose of whether a
given method call means <b>M</b> or not, so we ignore it for this section.

<div class="p"><!----></div>
All that matters about a method definition, for the purposes of method
resolution, is: 

<ol type="1">
<li> The method name <b>m</b>;
<div class="p"><!----></div>
</li>

<li> The generic type parameters of the method <b>m</b>,  "G<sub>1</sub>,&#8230;, G<sub>g</sub>".  If there
      are no generic type parameters, g=0.
<div class="p"><!----></div>
</li>

<li> The types "x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>" of the formal parameters.  If
      there are no formal parameters, f=0. In the case of an instance
      method, the receiver will be the first formal parameter.<a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>
<div class="p"><!----></div>
</li>

<li> The constraint <b>c</b> of the method <b>M</b>. If no constraint is specified, <b>c</b> is
      <b>true</b>.
<div class="p"><!----></div>
</li>

<li> A <em>unique identifier</em> <b>id</b>, sufficient to tell the compiler
      which method body is intended.  A file name and position in that file
      would suffice.  The details of the identifier are not relevant.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
For the purposes of understanding method resolution, we assume that all the
actual parameters of an invocation are simply variables: <b>x1.meth(x2,x3)</b>.
This is done routinely by the compiler in any case; the code 
<b>tbl(i).meth(true, a+1)</b> would be treated roughly as 
<pre>
val x1 = tbl(i);
val x2 = true;
val x3 = a+1;
x1.meth(x2,x3);
</pre>

<div class="p"><!----></div>
All that matters about an invocation <b>I</b> is: 

<ol type="1">
<li> The method name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> The generic type parameters "G&#8242;<sub>1</sub>,&#8230;, G&#8242;<sub>g</sub>".  If there
      are no generic type parameters, g=0.
<div class="p"><!----></div>
</li>

<li> The names and types "x<sub>1</sub>:T&#8242;<sub>1</sub>,&#8230;, x<sub>f</sub>:T&#8242;<sub>f</sub>" of the
      actual parameters.
      If
      there are no actual parameters, f=0. In the case of an instance
      method, the receiver is the first actual parameter.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The signature of the method resolution procedure is: 
<b>resolve(invo : Invocation, context: Set[Method]) : MethodID</b>.  
Given a particular invocation and the set <b>context</b> of all methods
which could be called at that point of code, method resolution either returns
the unique identifier of the method that should be called, or (conceptually)
throws an exception if the call cannot be resolved.

<div class="p"><!----></div>
The procedure for computing <b>resolve(invo, context)</b> is: 

<ol type="1">
<li> Eliminate from <b>context</b> those methods which are not <em>
      acceptable</em>; <em>viz</em>, those whose name, type parameters, formal parameters,
      and constraint do not suitably match <b>invo</b>.  In more detail:
      
<ul>
<li> The method name <b>m</b> must simply equal the invocation name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> X10 infers type parameters, by an algorithm given in &#167;.
<div class="p"><!----></div>
</li>

<li> The method's type parameters are bound to the invocation's for the
            remainder of the acceptability test.
<div class="p"><!----></div>
</li>

<li> The actual parameter types must be subtypes of the formal
            parameter types, or be coercible to such subtypes.  Parameter i
            is a subtype if "T&#8242;<sub>i</sub> &lt;: T<sub>i</sub>".  It is implicitly
            coercible to a subtype if there is an implicit coercion operator
            defined from "T&#8242;<sub>i</sub>" to some type <b>U</b>, and 
            &#220; &lt;: T<sub>i</sub>".  .  If coercions are
            used to resolve the method, they will be called on the arguments
            before the method is invoked.
<div class="p"><!----></div>
</li>

<li> The formal constraint <b>c</b> must be satisfied in the invoking
            context.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Eliminate from <b>context</b> those methods which are not <em>
      available</em>; <em>viz</em>, those which cannot be called due to visibility
      constraints, such as methods from other classes marked <b>private</b>.
      The remaining methods are both acceptable and available; they might be
      the one that is intended.
<div class="p"><!----></div>
</li>

<li> From the remaining methods, find the unique <b>ms</b> which is more specific than all the
      others, <em>viz</em>, for which <b>specific(ms,mo) = true</b> for all other
      methods <b>mo</b>.
      The specificity test <b>specific</b> is given next.
      
<ul>
<li> If there is a unique such <b>ms</b>, then
            <b>resolve(invo,context)</b> returns the <b>id</b> of <b>ms</b>.
<div class="p"><!----></div>
</li>

<li> If there is not a unique such <b>ms</b>, then <b>resolve</b> reports
            an error.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The subsidiary procedure <b>specific(m1, m2)</b> determines whether method
<b>m1</b> is equally or more specific than <b>m2</b>.  <b>specific</b> is not a
total order: is is possible for each one to be considered more specific than
the other, or either to be more specific.  <b>specific</b> is computed as: 

<ol type="1">
<li> Construct an invocation <b>invo1</b> based on <b>m1</b>: 
      
<ul>
<li> <b>invo1</b>'s method name is <b>m1</b>'s method name;
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s generic parameters are those of <b>m1</b>- simply
            some type variables.
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s parameters are those of <b>m1</b>.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> If <b>m2</b> is acceptable for the invocation <b>invo1</b>,
      <b>specific(m1,m2)</b> returns true;
<div class="p"><!----></div>
</li>

<li> Construct an invocation <b>invo2p</b>, which is <b>invo1</b> with the
      generic parameters erased.  Let <b>invo2</b> be <b>invo2p</b> with generic
      parameters as inferred by X10's type inference algorithm.  If type
      inference fails, <b>specific(m1,m2)</b> returns false.
<div class="p"><!----></div>
</li>

<li> If <b>m2</b> is acceptable for the invocation <b>invo2</b>,
      <b>specific(m1,m2)</b> returns true;
<div class="p"><!----></div>
</li>

<li> Otherwise, <b>specific(m1,m2)</b> returns false.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.3">
9.3</a>&nbsp;&nbsp;Other Disambiguations</h3>
<a name="sect:disambiguations">
</a>

<div class="p"><!----></div>
It is possible to have a field of the same name as a method.
Indeed, it is a common pattern to have private field and a public
method of the same name to access it:

<pre>
class Xhaver {
  private var x: Int = 0;
  public def x() = x;
  public def bumpX() { x ++; }
}
</pre>


<div class="p"><!----></div>
However, this can lead to syntactic ambiguity in the case where the field
<b>f</b> of object <b>a</b> is a
function, array, list, or the like, and where <b>a</b> has a method also named
<b>f</b>.  The term <b>a.f(b)</b> could either mean "call method <b>f</b> of <b>a</b> upon
<b>b</b>", or apply the function <b>a.f</b> to argument <b>b</b>".  

<div class="p"><!----></div>
<pre>
class Ambig {
  public val f : (Int)=&#62;Int =  (x:Int) =&#62; x*x;
  public def f(y:int) = y+1;
  public def example() {
      val v = this.f(10);
      // is v 100, or 11?
  }
}
</pre>


<div class="p"><!----></div>
In the case where a syntactic form &#203;.m(F<sub>1</sub>, &#8230;, F<sub>n</sub>)" could
be resolved as either a method call, or the application of a field <b>E.m</b>
to some arguments, it will be treated as a method call.  
The application of <b>E.m</b> to some arguments can be specified by adding
parentheses:  "(E.m)(F<sub>1</sub>, &#8230;, F<sub>n</sub>)".

<div class="p"><!----></div>
<pre>
class Disambig {
  public val f : (Int)=&#62;Int =  (x:Int) =&#62; x*x;
  public def f(y:int) = y+1;
  public def example() {
      assert(  this.f(10)  == 11  );
      assert( (this.f)(10) == 100 );
  }
}
</pre>

<div class="p"><!----></div>
Similarly, it is possible to have a method with the same name as a struct, say
<b>ambig</b>, giving an ambiguity as to whether <b>ambig()</b> is a struct
constructor invocation or a method invocation.  This ambiguity is resolved by
treating it as a method invocation.  If the constructor invocation is desired,
it can be achieved by including the optional <b>new</b>.  That is, 
<b>new ambig()</b> is struct constructor invocation; <b>ambig()</b> is a 
method invocation.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>

</body>
</html>