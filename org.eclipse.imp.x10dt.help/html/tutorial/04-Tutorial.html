<html>
<head>
<link rel="stylesheet" type="text/css" href="./x10tutorial.css" />
</head>

<body>

<h1>Guards and Dependent Types</h1>

<p>
This is where the magic happens -- or some of it, anyhow.
</p>

<p>
The X10 compiler knows -- or <i>can</i> know -- a lot more about your data
than most compilers do.  We've seen a taste of that
already, <a href="01-Tutorial.html#intro-bang"> when we met types with
exclamation points in them</a>.    There's a lot more, though.
</p>

<p>
Suppose we want to define a few basic vector operations: sum, dot product,
cross product. The mathematics is pretty familiar. For now, let's
use <kbd>Rail[Double]</kbd> to represent vectors. Since
a <kbd>Rail[Double]</kbd> is a one-dimensional collection of double-precision
floating-point numbers, this is pretty natural as a first version.
</p>

<p>
(In a later version -- and later section of the tutorial -- we'll see another
way to do it: to define it as a class.  Using a class has a number of
advantages, one of which is that we can define <kbd>v+w</kbd>
and <kbd>v*w</kbd> for sum and dot product.) 
</p>


<table border="1">


<tr>
  <td><b>Concept</b></td>
  <td><b>Mathematical Notation</b></td>
  <td><b>Our X10 Notation</b></td>
  <td><b>Requires</b></td>
</tr>


<tr>
  <td>Vector</td>
  <td><i>v</i></td>
  <td><kbd>v</kbd>, or other variable name as desired</td>
  <td>&nbsp;</td>
</tr>

<tr>
  <td>i<sup>th</sup> element</td>
  <td><i>v<sub>i</sub></i></td>
  <td><kbd>v(i)</kbd></td>
  <td>&nbsp;</td>
</tr>


<tr>
  <td>Vector of length N</td>
  <td><i>v &#8714; &#8477;<sup>N</sup></i></td>
  <td><kbd>v.length == N</kbd></td>
  <td>&nbsp;</td>
</tr>


<tr>
  <td>Vector sum</td>
  <td><i>v + w</i></td>
  <td><kbd>sum(v,w)</kbd></td>
  <td><kbd>v.length == w.length</kbd></td>
</tr>


<tr>
  <td>Dot Product</td>
  <td><i>v &bull; w</i></td>
  <td><kbd>dot(v,w)</kbd></td>
  <td><kbd>v.length == w.length</kbd></td>
</tr>


<tr>
  <td>Cross Product</td>
  <td><i>v <b>&times;</b> w</i></td>
  <td><kbd>cross(v,w)</kbd></td>
  <td><kbd>v.length == w.length == 3</kbd></td>
</tr>

</table>

<p>
Notice that the vector operations don't work on arbitrary vectors.  You can't
add or dot a two-element vector to a three-element one; the lengths have to
match.  You can't cross two two-element vectors; that operation is only
defined on vectors of length three.
(Or <a href="http://en.wikipedia.org/wiki/Seven-dimensional_cross_product">seven</a>,
oddly enough, but we won't be doing that version.)
</p>

<p>
In a lot of modern programming languages -- Java in particular -- the compiler
doesn't know how long Java's equivalent of a <kbd>Rail[Double]</kbd> is.  So,
you need to write code that checks at <i>runtime</i> rather than <i>compile
time</i>.  It looks sort of like this pseudocode
</p>
<pre>
// Pseudocode in the spirit of Java
// But keeping to X10-ish syntax
static sum (v: Rail[Double], w : Rail[Double]) : Rail[Double]  {
  if (v.length != w.length) {
     throw new RuntimeException("Can't add vectors of different lengths");
  }
  else {
     ... do vector sum ... 
  }
}
</pre>

<p>
This is actually a problem for Java code.  You can never be quite sure that
your vector arithmetic won't throw that <kbd>RuntimeException</kbd> about the
lengths not matching.  If you're doing everything right, it won't, but even
the best programmers occasionally make mistakes.  You will never get all the
way to adding wrong-sized vectors, but you might lose your work halfway
through to a surprise exception.
</p>

<p>
X10 lets you explain these requirements <i>statically</i> -- at compile time.
In X10, if you try to add a two-element vector to a three-element vector, your
program won't even compile. You'll get a compilation error, just as if you
tried to add a number to a Boolean.  
</p>

<p>
In fact, if you try to add a vector of length three to one of unknown size,
you'll get that compiler error.  X10 insists that you prove to its
satisfaction that the vectors have the same length.    (There are several ways
to do this, ranging from trivial to easy.)
</p>

<p>
And that's the right thing to do.  If you want your program to be correct, and
not to blow up with a runtime exception during your expensive time-slot on the
supercomputer and waste the whole run, keeping that kind of error is pretty
important.   (X10 can't deal with  <i>every</i> kind of error this way, and
there are plenty of opportunities to put bugs in your program, but it can deal
with <i>more</i> kinds of errors than Java or C++.)
</p>

<a name="guards"></a>
<h2>Guards</h2>

<p>
X10 lets you attach <i>guards</i> to certain parts of your program, including
methods. Guards are Boolean expressions written in braces that say that
something has to be true at that point -- and that the compiler has to be able
to confirm, at compile time, that it's true.  For example, <kbd>{v.length ==
    w.length}</kbd> is a guard that says that <kbd>v</kbd> and <kbd>w</kbd>
have the same length. 
</p>

<p>
Only certain kinds of expressions can be guards. You can't, in X10 v2.0, even
do addition, or compute the length of a string, in a guard. These restrictions
may get relaxed in later versions of X10.  (They'll never get relaxed all the
way though, or anywhere close.  Too relaxed, and some basic questions quickly
get impossible to compute -- like, "Is this a valid type?" or "Does this
expression have the type that the programmer said it did?".  That would make
X10 unusable.)
</p>


<p>
Fortunately, the length of a rail (<kbd>v.length</kbd>) and integer equality
(<kbd>==</kbd>) are both allowed in guards.  
So, we can write a guard that says that <kbd>v</kbd> and <kbd>w</kbd> have the
same length: <kbd>{v.length == w.length}</kbd>.  
That is enough to write 
a <kbd>dot</kbd> method which takes two vectors of the same length:
</p>


<!--
public class Vec1 {
  public static def main(argv:Rail[String]!) {
    val v = [1.0, 2.0, 3.0];
    x10.io.Console.OUT.println("v*v = " + dot(v,v));
  }
  static def dot(v: ValRail[Double], w: ValRail[Double]){v.length == w.length}  = {
    var s : Double = 0.0;
    for((i) in 0 .. v.length - 1) {
      s += v(i) * w(i);
    }
    return s;
  }
}

-->
<table class="ex">
<a name="src-vec1-1"/>
<tr class="ex"><td><a href="#vec1-1" class="ex">1</a></td><td class="ex"><code>public class Vec1 {</code></td></tr>
<a name="src-vec1-2"/>
<tr class="ex"><td><a href="#vec1-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;public static def main(argv:Rail[String]!) {</code></td></tr>
<a name="src-vec1-3"/>
<tr class="ex"><td><a href="#vec1-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val v = [1.0, 2.0, 3.0];</code></td></tr>
<a name="src-vec1-4"/>
<tr class="ex"><td><a href="#vec1-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("v*v = " + dot(v,v));</code></td></tr>
<a name="src-vec1-5"/>
<tr class="ex"><td><a href="#vec1-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec1-6"/>
<tr class="ex"><td><a href="#vec1-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;static def dot(v: ValRail[Double], w: ValRail[Double]){v.length == w.length}  = {</code></td></tr>
<a name="src-vec1-7"/>
<tr class="ex"><td><a href="#vec1-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;var s : Double = 0.0;</code></td></tr>
<a name="src-vec1-8"/>
<tr class="ex"><td><a href="#vec1-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for((i) in 0 .. v.length - 1) {</code></td></tr>
<a name="src-vec1-9"/>
<tr class="ex"><td><a href="#vec1-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += v(i) * w(i);</code></td></tr>
<a name="src-vec1-10"/>
<tr class="ex"><td><a href="#vec1-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec1-11"/>
<tr class="ex"><td><a href="#vec1-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;return s;</code></td></tr>
<a name="src-vec1-12"/>
<tr class="ex"><td><a href="#vec1-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec1-13"/>
<tr class="ex"><td><a href="#vec1-13" class="ex">13</a></td><td class="ex"><code>}</code></td></tr>
</table>

<a name="vec1-1"/>
<!--<p>  <a href="#src-vec1-1">line 1: </a><kbd class="ex">public class Vec1 {</kbd><br/></p>-->
<a name="vec1-2"/>
<!--<p>  <a href="#src-vec1-2">line 2: </a><kbd class="ex">  public static def main(argv:Rail[String]!) {</kbd><br/></p>-->
<a name="vec1-3"/>
<!--<p>  <a href="#src-vec1-3">line 3: </a><kbd class="ex">    val v = [1.0, 2.0, 3.0];</kbd><br/></p>-->
<a name="vec1-4"/>
<!--<p>  <a href="#src-vec1-4">line 4: </a><kbd class="ex">    x10.io.Console.OUT.println("v*v = " + dot(v,v));</kbd><br/></p>-->
<a name="vec1-5"/>
<!--<p>  <a href="#src-vec1-5">line 5: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="vec1-6"/>
<p>  <a href="#src-vec1-6">line 6: </a><kbd class="ex">  static def dot(v:
    ValRail[Double], w: ValRail[Double]){v.length == w.length}  = {</kbd><br/>
Here's where we use the guard.  The braced expression right after
    the <kbd>)</kbd> is the guard.  The body of the method follows
    the <kbd>=</kbd>. 
</p>
<a name="vec1-7"/>
<p> <a href="#src-vec1-7">line 7: </a><kbd class="ex"> var s : Double =
    0.0;</kbd><br/> This creates a variable <kbd>s</kbd> -- a <kbd>var</kbd>
    variable, which means that we're allowed to update it. The initial value
    of this variable is <kbd>0.0</kbd>.  We'll use this for the accumulator of
    the sum.
</p>
<a name="vec1-8"/>
<!--<p>  <a href="#src-vec1-8">line 8: </a><kbd class="ex">    for((i) in 0 .. v.length - 1) {</kbd><br/></p>-->
<a name="vec1-9"/>
<!--<p>  <a href="#src-vec1-9">line 9: </a><kbd class="ex">      s += v(i) * w(i);</kbd><br/></p>-->
<a name="vec1-10"/>
<!--<p>  <a href="#src-vec1-10">line 10: </a><kbd class="ex">    }</kbd><br/></p>-->
<a name="vec1-11"/>
<!--<p>  <a href="#src-vec1-11">line 11: </a><kbd class="ex">    return s;</kbd><br/></p>-->
<a name="vec1-12"/>
<!--<p>  <a href="#src-vec1-12">line 12: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="vec1-13"/>
<!--<p>  <a href="#src-vec1-13">line 13: </a><kbd class="ex">}</kbd><br/></p>-->

<h3>Sum -- Constrained Return Type</h3>

<p>
One part of <kbd>dot</kbd>'s type was particularly easy: the result
of <kbd>dot</kbd> is a <kbd>Double</kbd>, and we don't need to say anything
more about it.
</p>

<p>
For vector sum, <kbd>sum</kbd>, there's more to say.  The sum of two
3-dimensional vectors is also a 3-dimensional vector (for any value of 3).
</p>

<p>
We <i>could</i> simply return <kbd>Rail[Double]</kbd>.  This would be a
correct type, though it would forget about the length.  For some purposes, it
would be OK.  The example code below would still compile and do the right
thing.  However, if we didn't return the length, we couldn't
write <kbd>sum(a,sum(b,c))</kbd>, even if we knew
that <kbd>a</kbd>, <kbd>b</kbd>, and <kbd>c</kbd> were all three-dimensional
vectors.  X10 wouldn't be sure that <kbd>sum(b,c)</kbd> was three-dimensional. 
</p>

<p>
The way to say "<i>The result is the same length as <kbd>v</kbd></i>" is to
give the return type of the function as <kbd>Rail[Double]{length ==
v.length}</kbd>.    Variable names like <kbd>length</kbd> appearing in
constraints on a type can refer to properties of the value of that type --
so <kbd>length</kbd> means "<i>the length of the Rail[Double] we're talking
    about here"</i>.  (<i>Properties</i> are a kind of field of an object
which are known at compile time.  We'll see how to define and use properties
in <span class="todo">a later section</span>.)
</p>



<!--
public class Vec2 {
  public static def main(argv:Rail[String]!) {
    val v = [1.0, 2.0, 3.0];
    x10.io.Console.OUT.println("v+v = " + str(sum(v,v)));
  }
  static def str(v: ValRail[Double]):String = {
    var s : String = "";
    for( (i) in 0 .. v.length - 1) {
      s += v(i);
      if (i < v.length - 1) s += ", ";
    }
    return s;
  }  
  static def sum(v: ValRail[Double], w: ValRail[Double]) 
     {v.length == w.length} 
     :ValRail[Double]{length == v.length}  
     = {
       return Rail.make[Double](
                        v.length, 
                        (i:Int) => v(i) + w(i) 
        );
     }
}

-->
<table class="ex">
<a name="src-vec2-1"/>
<tr class="ex"><td><a href="#vec2-1" class="ex">1</a></td><td class="ex"><code>public class Vec2 {</code></td></tr>
<a name="src-vec2-2"/>
<tr class="ex"><td><a href="#vec2-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;public static def main(argv:Rail[String]!) {</code></td></tr>
<a name="src-vec2-3"/>
<tr class="ex"><td><a href="#vec2-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val v = [1.0, 2.0, 3.0];</code></td></tr>
<a name="src-vec2-4"/>
<tr class="ex"><td><a href="#vec2-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("v+v = " + str(sum(v,v)));</code></td></tr>
<a name="src-vec2-5"/>
<tr class="ex"><td><a href="#vec2-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec2-6"/>
<tr class="ex"><td><a href="#vec2-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;static def str(v: ValRail[Double]):String = {</code></td></tr>
<a name="src-vec2-7"/>
<tr class="ex"><td><a href="#vec2-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;var s : String = "";</code></td></tr>
<a name="src-vec2-8"/>
<tr class="ex"><td><a href="#vec2-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for( (i) in 0 .. v.length - 1) {</code></td></tr>
<a name="src-vec2-9"/>
<tr class="ex"><td><a href="#vec2-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += v(i);</code></td></tr>
<a name="src-vec2-10"/>
<tr class="ex"><td><a href="#vec2-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i < v.length - 1) s += ", ";</code></td></tr>
<a name="src-vec2-11"/>
<tr class="ex"><td><a href="#vec2-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec2-12"/>
<tr class="ex"><td><a href="#vec2-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;return s;</code></td></tr>
<a name="src-vec2-13"/>
<tr class="ex"><td><a href="#vec2-13" class="ex">13</a></td><td class="ex"><code>&nbsp;&nbsp;}  </code></td></tr>
<a name="src-vec2-14"/>
<tr class="ex"><td><a href="#vec2-14" class="ex">14</a></td><td class="ex"><code>&nbsp;&nbsp;static def sum(v: ValRail[Double], w: ValRail[Double]) </code></td></tr>
<a name="src-vec2-15"/>
<tr class="ex"><td><a href="#vec2-15" class="ex">15</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{v.length == w.length} </code></td></tr>
<a name="src-vec2-16"/>
<tr class="ex"><td><a href="#vec2-16" class="ex">16</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ValRail[Double]{length == v.length}  </code></td></tr>
<a name="src-vec2-17"/>
<tr class="ex"><td><a href="#vec2-17" class="ex">17</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= {</code></td></tr>
<a name="src-vec2-18"/>
<tr class="ex"><td><a href="#vec2-18" class="ex">18</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Rail.make[Double](</code></td></tr>
<a name="src-vec2-19"/>
<tr class="ex"><td><a href="#vec2-19" class="ex">19</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.length, </code></td></tr>
<a name="src-vec2-20"/>
<tr class="ex"><td><a href="#vec2-20" class="ex">20</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i:Int) => v(i) + w(i) </code></td></tr>
<a name="src-vec2-21"/>
<tr class="ex"><td><a href="#vec2-21" class="ex">21</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</code></td></tr>
<a name="src-vec2-22"/>
<tr class="ex"><td><a href="#vec2-22" class="ex">22</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec2-23"/>
<tr class="ex"><td><a href="#vec2-23" class="ex">23</a></td><td class="ex"><code>}</code></td></tr>
</table>

<a name="vec2-1"/>
<!--<p>  <a href="#src-vec2-1">line 1: </a><kbd class="ex">public class Vec2 {</kbd><br/></p>-->
<a name="vec2-2"/>
<!--<p>  <a href="#src-vec2-2">line 2: </a><kbd class="ex">  public static def main(argv:Rail[String]!) {</kbd><br/></p>-->
<a name="vec2-3"/>
<!--<p>  <a href="#src-vec2-3">line 3: </a><kbd class="ex">    val v = [1.0, 2.0, 3.0];</kbd><br/></p>-->
<a name="vec2-4"/>
<p>  <a href="#src-vec2-4">line 4: </a><kbd class="ex">
    x10.io.Console.OUT.println("v+v = " + str(sum(v,v)));</kbd><br/>
If you simply print a Rail, you'll get a clue about the Rail's address in
    memory. This can be useful when you're trying to see if two Rails are the
    same object.  Here, we want to print the components of the vector, so
    we'll write and call a function <kbd>str</kbd>.
</p>
<a name="vec2-5"/>
<!--<p>  <a href="#src-vec2-5">line 5: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="vec2-6"/>
<p>  <a href="#src-vec2-6">line 6: </a><kbd class="ex">  static def str(v:
    ValRail[Double]):String = {</kbd><br/>
<kbd>str</kbd> is a function taking a <kbd>ValRail</kbd> and returning
a <kbd>String</kbd>.
Specifically, we'll turn each of the numbers in <kbd>v</kbd> to strings, and
put commas between them.
</p>
<a name="vec2-7"/>
<!--<p>  <a href="#src-vec2-7">line 7: </a><kbd class="ex">    var s : String = "";</kbd><br/></p>-->
<a name="vec2-8"/>
<!--<p>  <a href="#src-vec2-8">line 8: </a><kbd class="ex">    for( (i) in 0 .. v.length - 1) {</kbd><br/></p>-->
<a name="vec2-9"/>
<p>  <a href="#src-vec2-9">line 9: </a><kbd class="ex">      s +=
    v(i);</kbd><br/>
Adding a number to a string (even with <kbd>+=</kbd>) converts the number to a
    string in a sensible way, and concatenates it.
</p>
<a name="vec2-10"/>
<p>  <a href="#src-vec2-10">line 10: </a><kbd class="ex">      if (i < v.length - 1) s += ", ";</kbd><br/>
Here's where we add the commas between pairs of numbers.  But we don't want to
add a comma after the last number.
</p>
<a name="vec2-11"/>
<!--<p>  <a href="#src-vec2-11">line 11: </a><kbd class="ex">    }</kbd><br/></p>-->
<a name="vec2-12"/>
<!--<p>  <a href="#src-vec2-12">line 12: </a><kbd class="ex">    return s;</kbd><br/></p>-->
<a name="vec2-13"/>
<!--<p>  <a href="#src-vec2-13">line 13: </a><kbd class="ex">  }  </kbd><br/></p>-->
<a name="vec2-14"/>
<p>  <a href="#src-vec2-14">line 14: </a><kbd class="ex">  static def sum(v:
    ValRail[Double], w: ValRail[Double]) </kbd><br/>
Since we've got both an input constraint on <kbd>sum</kbd> (saying
    that <kbd>v</kbd> and <kbd>w</kbd> have the same length)
and an output constraint (saying that the result also has that length), 
we'll write the parts of this function's signature on different lines 
to make it easier to read.
There's no need to do that unless you're writing a tutorial, or 
the constraints are too long to fit on one line.
</p>
<a name="vec2-15"/>
<p>  <a href="#src-vec2-15">line 15: </a><kbd class="ex">     {v.length ==
    w.length} </kbd><br/>
This is the guard on calling the method, the one that says that the inputs are
    the same length.
</p>
<a name="vec2-16"/>
<p>  <a href="#src-vec2-16">line 16: </a><kbd class="ex">
    :ValRail[Double]{length == v.length}  </kbd><br/>
This is the guard on the result.  
Specifically, it just says what <i>type</i> the output has: the output is a
    ValRail of the proper length.  
The colon "<kbd>:</kbd>" in front of it is the usual X10 notation for giving
    the return type of a method -- the same thing we
  used <a href="#src-vec2-6">for the <kbd>str</kbd> method</a> too.
</p>
<a name="vec2-17"/>
<!--<p>  <a href="#src-vec2-17">line 17: </a><kbd class="ex">     = {</kbd><br/></p>-->
<a name="vec2-18"/>
<p>  <a href="#src-vec2-18">line 18: </a><kbd class="ex">       return
    Rail.make[Double](</kbd><br/>
<kbd>ValRail</kbd>s can't be changed once they're created.  So the way to make
one whose contents are computed at runtime is with the <kbd>Rail.make</kbd>
method.  That takes two arguments: 
</p>
<a name="vec2-19"/>
<p>  <a href="#src-vec2-19">line 19: </a><kbd class="ex">
    v.length, </kbd><br/>
The first argument is the length of the desired ValRail.  
In this case, the length of the sum is the same length as the summand.
</p>
<a name="vec2-20"/>
<p>  <a href="#src-vec2-20">line 20: </a><kbd class="ex">
    (i:Int) => v(i) + w(i) </kbd><br/>
The second argument is a function taking an index <kbd>i</kbd> and returning
    the desired value of the <kbd>i</kbd><sup>th</sup> element.  In this case,
    the  <kbd>i</kbd><sup>th</sup> element should be the sum of
    the  <kbd>i</kbd><sup>th</sup> elements of <kbd>v</kbd> and <kbd>w</kbd>
    -- which is written as <kbd>v(i) + w(i)</kbd>.  
</p>
<a name="vec2-21"/>
<!--<p>  <a href="#src-vec2-21">line 21: </a><kbd class="ex">        );</kbd><br/></p>-->
<a name="vec2-22"/>
<!--<p>  <a href="#src-vec2-22">line 22: </a><kbd class="ex">     }</kbd><br/></p>-->
<a name="vec2-23"/>
<!--<p>  <a href="#src-vec2-23">line 23: </a><kbd class="ex">}</kbd><br/></p>-->

<p>
With this definition, you can add vectors of the same size, but get a
compile-time error if you try to add vectors of different sizes.  As always,
"size" is what X10 thinks the size is at <i>compile</i> time.
</p>

<a name="cross"></a>
<h3>Cross: Only For 3-dimensional vectors</h3>


<p>
To take care of cross products, we need to say that the length of a ValRail is
three.  The precondition of <kbd>cross</kbd> is <kbd>{v.length == 3
    &amp;&amp; w.length == 3</kbd>.  (Fortunately, <kbd>3</kbd> and <kbd>
    &amp;&amp; </kbd> are both allowed in guards.)  The return type
is <kbd>ValRail[Double]{length==3}</kbd> -- that is, the type of
three-dimensional vectors. 
</p>


<!--
public class Vec3 {
  public static def main(argv:Rail[String]!) {
    val v = [1.0, 2.0, 3.0];
    x10.io.Console.OUT.println("v+v = " + str(cross(v,v)));
    x10.io.Console.OUT.println("v+v = " + str(cross(v,[3.0, 2.0, 1.0])));
    x10.io.Console.OUT.println("v+v = " + str(cross([2.0, 1.0, -1.0], [-3.0, 4.0, 1.0])));
  }
  static def str(v: ValRail[Double]):String = {
    var s : String = "";
    for( (i) in 0 .. v.length - 1) {
      s += v(i);
      if (i < v.length - 1) s += ", ";
    }
    return s;
  }  
  static def cross(v: ValRail[Double], w: ValRail[Double]) 
     {v.length == 3 && w.length == 3} 
     :ValRail[Double]{length == 3}  
     = [
         v(1)*w(2) - v(2)*w(1), // component 0
         v(2)*w(0) - v(0)*w(2), // component 1
         v(0)*w(1) - v(1)*w(0)  // component 2
       ];
}

-->
<table class="ex">
<a name="src--1"/>
<tr class="ex"><td><a href="#-1" class="ex">1</a></td><td class="ex"><code>public class Vec3 {</code></td></tr>
<a name="src--2"/>
<tr class="ex"><td><a href="#-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;public static def main(argv:Rail[String]!) {</code></td></tr>
<a name="src--3"/>
<tr class="ex"><td><a href="#-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val v = [1.0, 2.0, 3.0];</code></td></tr>
<a name="src--4"/>
<tr class="ex"><td><a href="#-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("v+v = " + str(cross(v,v)));</code></td></tr>
<a name="src--5"/>
<tr class="ex"><td><a href="#-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("v+v = " + str(cross(v,[3.0, 2.0, 1.0])));</code></td></tr>
<a name="src--6"/>
<tr class="ex"><td><a href="#-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("v+v = " + str(cross([2.0, 1.0, -1.0], [-3.0, 4.0, 1.0])));</code></td></tr>
<a name="src--7"/>
<tr class="ex"><td><a href="#-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src--8"/>
<tr class="ex"><td><a href="#-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;static def str(v: ValRail[Double]):String = {</code></td></tr>
<a name="src--9"/>
<tr class="ex"><td><a href="#-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;var s : String = "";</code></td></tr>
<a name="src--10"/>
<tr class="ex"><td><a href="#-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for( (i) in 0 .. v.length - 1) {</code></td></tr>
<a name="src--11"/>
<tr class="ex"><td><a href="#-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += v(i);</code></td></tr>
<a name="src--12"/>
<tr class="ex"><td><a href="#-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i < v.length - 1) s += ", ";</code></td></tr>
<a name="src--13"/>
<tr class="ex"><td><a href="#-13" class="ex">13</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src--14"/>
<tr class="ex"><td><a href="#-14" class="ex">14</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;return s;</code></td></tr>
<a name="src--15"/>
<tr class="ex"><td><a href="#-15" class="ex">15</a></td><td class="ex"><code>&nbsp;&nbsp;}  </code></td></tr>
<a name="src--16"/>
<tr class="ex"><td><a href="#-16" class="ex">16</a></td><td class="ex"><code>&nbsp;&nbsp;static def cross(v: ValRail[Double], w: ValRail[Double]) </code></td></tr>
<a name="src--17"/>
<tr class="ex"><td><a href="#-17" class="ex">17</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{v.length == 3 && w.length == 3} </code></td></tr>
<a name="src--18"/>
<tr class="ex"><td><a href="#-18" class="ex">18</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ValRail[Double]{length == 3}  </code></td></tr>
<a name="src--19"/>
<tr class="ex"><td><a href="#-19" class="ex">19</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [</code></td></tr>
<a name="src--20"/>
<tr class="ex"><td><a href="#-20" class="ex">20</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(1)*w(2) - v(2)*w(1), // component 0</code></td></tr>
<a name="src--21"/>
<tr class="ex"><td><a href="#-21" class="ex">21</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(2)*w(0) - v(0)*w(2), // component 1</code></td></tr>
<a name="src--22"/>
<tr class="ex"><td><a href="#-22" class="ex">22</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(0)*w(1) - v(1)*w(0)  // component 2</code></td></tr>
<a name="src--23"/>
<tr class="ex"><td><a href="#-23" class="ex">23</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;];</code></td></tr>
<a name="src--24"/>
<tr class="ex"><td><a href="#-24" class="ex">24</a></td><td class="ex"><code>}</code></td></tr>
</table>

<a name="-1"/>
<!--<p>  <a href="#src--1">line 1: </a><kbd class="ex">public class Vec3 {</kbd><br/></p>-->
<a name="-2"/>
<!--<p>  <a href="#src--2">line 2: </a><kbd class="ex">  public static def main(argv:Rail[String]!) {</kbd><br/></p>-->
<a name="-3"/>
<!--<p>  <a href="#src--3">line 3: </a><kbd class="ex">    val v = [1.0, 2.0, 3.0];</kbd><br/></p>-->
<a name="-4"/>
<!--<p>  <a href="#src--4">line 4: </a><kbd class="ex">    x10.io.Console.OUT.println("v+v = " + str(cross(v,v)));</kbd><br/></p>-->
<a name="-5"/>
<!--<p>  <a href="#src--5">line 5: </a><kbd class="ex">    x10.io.Console.OUT.println("v+v = " + str(cross(v,[3.0, 2.0, 1.0])));</kbd><br/></p>-->
<a name="-6"/>
<!--<p>  <a href="#src--6">line 6: </a><kbd class="ex">    x10.io.Console.OUT.println("v+v = " + str(cross([2.0, 1.0, -1.0], [-3.0, 4.0, 1.0])));</kbd><br/></p>-->
<a name="-7"/>
<!--<p>  <a href="#src--7">line 7: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="-8"/>
<!--<p>  <a href="#src--8">line 8: </a><kbd class="ex">  static def str(v: ValRail[Double]):String = {</kbd><br/></p>-->
<a name="-9"/>
<!--<p>  <a href="#src--9">line 9: </a><kbd class="ex">    var s : String = "";</kbd><br/></p>-->
<a name="-10"/>
<!--<p>  <a href="#src--10">line 10: </a><kbd class="ex">    for( (i) in 0 .. v.length - 1) {</kbd><br/></p>-->
<a name="-11"/>
<!--<p>  <a href="#src--11">line 11: </a><kbd class="ex">      s += v(i);</kbd><br/></p>-->
<a name="-12"/>
<!--<p>  <a href="#src--12">line 12: </a><kbd class="ex">      if (i < v.length - 1) s += ", ";</kbd><br/></p>-->
<a name="-13"/>
<!--<p>  <a href="#src--13">line 13: </a><kbd class="ex">    }</kbd><br/></p>-->
<a name="-14"/>
<!--<p>  <a href="#src--14">line 14: </a><kbd class="ex">    return s;</kbd><br/></p>-->
<a name="-15"/>
<!--<p>  <a href="#src--15">line 15: </a><kbd class="ex">  }  </kbd><br/></p>-->
<a name="-16"/>
<!--<p>  <a href="#src--16">line 16: </a><kbd class="ex">  static def cross(v: ValRail[Double], w: ValRail[Double]) </kbd><br/></p>-->
<a name="-17"/>
<p>  <a href="#src--17">line 17: </a><kbd class="ex">     {v.length == 3 &&
    w.length == 3} </kbd><br/>
This is one way to say that <kbd>v</kbd> and <kbd>w</kbd> both have length
    three.   There are other ways, which we will see
    in <a href="#vector3">a later section.</a>
</p>
<a name="-18"/>
<p>  <a href="#src--18">line 18: </a><kbd class="ex">
    :ValRail[Double]{length == 3}  </kbd><br/>
The result has to be length-3 as well.
</p>
<a name="-19"/>
<p>  <a href="#src--19">line 19: </a><kbd class="ex">     = [</kbd><br/></p>
<a name="-20"/>
<p>  <a href="#src--20">line 20: </a><kbd class="ex">         v(1)*w(2) - v(2)*w(1), // component 0</kbd><br/></p>
<a name="-21"/>
<p>  <a href="#src--21">line 21: </a><kbd class="ex">         v(2)*w(0) - v(0)*w(2), // component 1</kbd><br/></p>
<a name="-22"/>
<p>  <a href="#src--22">line 22: </a><kbd class="ex">         v(0)*w(1) - v(1)*w(0)  // component 2</kbd><br/></p>
<a name="-23"/>
<p>  <a href="#src--23">line 23: </a><kbd class="ex">       ];</kbd><br/>
The <kbd>[...]</kbd> notation for ValRails works fine if you put expressions
  in it -- not just constants, as some languages require. It will create a new
  ValRail each time it is executed, with suitable cross-product contents.  
</p>
<a name="-24"/>
<!--<p>  <a href="#src--24">line 24: </a><kbd class="ex">}</kbd><br/></p>-->

<a name="vector3"></a>
<h3><kbd>type</kbd>: Three-Dimensional Vectors</h3>

<p>
If we're writing this vector arithmetic stuff, we're probably expecting to do
a lot of computation with vectors in 3-space.  It would be very convenient to
have a type for these vectors -- both because we'll be writing that type a
lot, and because the type itself is pretty long.  Here's how to phrase that in
X10: 
</p>

<pre>
static type Vector3 = ValRail[Double]{length == 3};
</pre>

<p>
Which lets us use <kbd>Vector3</kbd> anywhere we want a three-dimensional vector.
</p>

<p>
In general, <kbd>type T = SomeLongTypeExpression;</kbd> lets you give a 
short name <kbd>T</kbd> for a long type expression.
</p>

<p>
The code using this is nearly the same as <a href="#cross">the previous
    example</a>; we just use <kbd>Vector3</kbd> at every opportunity.
</p>

<!--
public class Vec4 {
  static type Vector3 = ValRail[Double]{length == 3};       
  public static def main(argv:Rail[String]!) {
     val a : Vector3 = [1.0, 2.0, 3.0];
     val b : Vector3 = [4.0, 5.0, 6.0];
     val c : Vector3 = cross(a,b);
     x10.io.Console.OUT.println("c = " + str(c));
  }
    static def str(v: ValRail[Double]):String = {
    var s : String = "";
    for( (i) in 0 .. v.length - 1) {
      s += v(i);
      if (i < v.length - 1) s += ", ";
    }
    return s;
  }  
  static def cross(v: Vector3, w:Vector3): Vector3 
     = [
         v(1)*w(2) - v(2)*w(1), // component 0
         v(2)*w(0) - v(0)*w(2), // component 1
         v(0)*w(1) - v(1)*w(0)  // component 2
       ];
}

-->
<table class="ex">
<a name="src-vec4-1"/>
<tr class="ex"><td><a href="#vec4-1" class="ex">1</a></td><td class="ex"><code>public class Vec4 {</code></td></tr>
<a name="src-vec4-2"/>
<tr class="ex"><td><a href="#vec4-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;static type Vector3 = ValRail[Double]{length == 3};       </code></td></tr>
<a name="src-vec4-3"/>
<tr class="ex"><td><a href="#vec4-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;public static def main(argv:Rail[String]!) {</code></td></tr>
<a name="src-vec4-4"/>
<tr class="ex"><td><a href="#vec4-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val a : Vector3 = [1.0, 2.0, 3.0];</code></td></tr>
<a name="src-vec4-5"/>
<tr class="ex"><td><a href="#vec4-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val b : Vector3 = [4.0, 5.0, 6.0];</code></td></tr>
<a name="src-vec4-6"/>
<tr class="ex"><td><a href="#vec4-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val c : Vector3 = cross(a,b);</code></td></tr>
<a name="src-vec4-7"/>
<tr class="ex"><td><a href="#vec4-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("c = " + str(c));</code></td></tr>
<a name="src-vec4-8"/>
<tr class="ex"><td><a href="#vec4-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec4-9"/>
<tr class="ex"><td><a href="#vec4-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;static def str(v: ValRail[Double]):String = {</code></td></tr>
<a name="src-vec4-10"/>
<tr class="ex"><td><a href="#vec4-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;var s : String = "";</code></td></tr>
<a name="src-vec4-11"/>
<tr class="ex"><td><a href="#vec4-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for( (i) in 0 .. v.length - 1) {</code></td></tr>
<a name="src-vec4-12"/>
<tr class="ex"><td><a href="#vec4-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += v(i);</code></td></tr>
<a name="src-vec4-13"/>
<tr class="ex"><td><a href="#vec4-13" class="ex">13</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i < v.length - 1) s += ", ";</code></td></tr>
<a name="src-vec4-14"/>
<tr class="ex"><td><a href="#vec4-14" class="ex">14</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec4-15"/>
<tr class="ex"><td><a href="#vec4-15" class="ex">15</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;return s;</code></td></tr>
<a name="src-vec4-16"/>
<tr class="ex"><td><a href="#vec4-16" class="ex">16</a></td><td class="ex"><code>&nbsp;&nbsp;}  </code></td></tr>
<a name="src-vec4-17"/>
<tr class="ex"><td><a href="#vec4-17" class="ex">17</a></td><td class="ex"><code>&nbsp;&nbsp;static def cross(v: Vector3, w:Vector3): Vector3 </code></td></tr>
<a name="src-vec4-18"/>
<tr class="ex"><td><a href="#vec4-18" class="ex">18</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [</code></td></tr>
<a name="src-vec4-19"/>
<tr class="ex"><td><a href="#vec4-19" class="ex">19</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(1)*w(2) - v(2)*w(1), // component 0</code></td></tr>
<a name="src-vec4-20"/>
<tr class="ex"><td><a href="#vec4-20" class="ex">20</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(2)*w(0) - v(0)*w(2), // component 1</code></td></tr>
<a name="src-vec4-21"/>
<tr class="ex"><td><a href="#vec4-21" class="ex">21</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v(0)*w(1) - v(1)*w(0)  // component 2</code></td></tr>
<a name="src-vec4-22"/>
<tr class="ex"><td><a href="#vec4-22" class="ex">22</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;];</code></td></tr>
<a name="src-vec4-23"/>
<tr class="ex"><td><a href="#vec4-23" class="ex">23</a></td><td class="ex"><code>}</code></td></tr>
</table>

<a name="vec4-1"/>
<!--<p>  <a href="#src-vec4-1">line 1: </a><kbd class="ex">public class Vec4 {</kbd><br/></p>-->
<a name="vec4-2"/>
<p>  <a href="#src-vec4-2">line 2: </a><kbd class="ex">  static type Vector3 =
    ValRail[Double]{length == 3};       </kbd><br/>

Here's where we declare the type <kbd>Vector3</kbd>.  Note that we're putting
  it as a static member of the class <kbd>Vec4</kbd>.  If we wanted other,
  distant code to be able to use it, we could declare it <kbd>public</kbd>.  
</p>
<a name="vec4-3"/>
<!--<p>  <a href="#src-vec4-3">line 3: </a><kbd class="ex">  public static def main(argv:Rail[String]!) {</kbd><br/></p>-->
<a name="vec4-4"/>
<p>  <a href="#src-vec4-4">line 4: </a><kbd class="ex">     val a : Vector3 =
    [1.0, 2.0, 3.0];</kbd><br/>

<kbd>Vector3</kbd> is just another name
for <kbd>ValRail[Double]{length==3}</kbd>.  That means we can use any X10
features that involve suitable <kbd>ValRail</kbd>s with <kbd>Vector3</kbd>.
In this line, we use the usual <kbd>[...]</kbd> syntax for
a <kbd>ValRail</kbd> constructor to make a value of type <kbd>Vector3</kbd>.  
</p>


<a name="vec4-5"/>
<!--<p>  <a href="#src-vec4-5">line 5: </a><kbd class="ex">     val b : Vector3 = [4.0, 5.0, 6.0];</kbd><br/></p>-->
<a name="vec4-6"/>
<!--<p>  <a href="#src-vec4-6">line 6: </a><kbd class="ex">     val c : Vector3 = cross(a,b);</kbd><br/></p>-->
<a name="vec4-7"/>
<p>  <a href="#src-vec4-7">line 7: </a><kbd class="ex">
    x10.io.Console.OUT.println("c = " + str(c));</kbd><br/>
The function <kbd>str</kbd> is defined on <kbd>ValRail[Double]</kbd>s of all
    lengths.  There's no problem calling <kbd>str(c)</kbd>, even
    though <kbd>c</kbd> is declared to be a <kbd>Vector3</kbd>.  That's
    because <kbd>Vector3</kbd> means the same
    as <kbd>ValRail[Double]{length==3}</kbd>, and every 
     <kbd>ValRail[Double]{length==3}</kbd> is also a
     just-plain-<kbd>ValRail[Double]</kbd>.  
</p>
<a name="vec4-8"/>
<!--<p>  <a href="#src-vec4-8">line 8: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="vec4-9"/>
<!--<p>  <a href="#src-vec4-9">line 9: </a><kbd class="ex">    static def str(v: ValRail[Double]):String = {</kbd><br/></p>-->
<a name="vec4-10"/>
<!--<p>  <a href="#src-vec4-10">line 10: </a><kbd class="ex">    var s : String = "";</kbd><br/></p>-->
<a name="vec4-11"/>
<!--<p>  <a href="#src-vec4-11">line 11: </a><kbd class="ex">    for( (i) in 0 .. v.length - 1) {</kbd><br/></p>-->
<a name="vec4-12"/>
<!--<p>  <a href="#src-vec4-12">line 12: </a><kbd class="ex">      s += v(i);</kbd><br/></p>-->
<a name="vec4-13"/>
<!--<p>  <a href="#src-vec4-13">line 13: </a><kbd class="ex">      if (i < v.length - 1) s += ", ";</kbd><br/></p>-->
<a name="vec4-14"/>
<!--<p>  <a href="#src-vec4-14">line 14: </a><kbd class="ex">    }</kbd><br/></p>-->
<a name="vec4-15"/>
<!--<p>  <a href="#src-vec4-15">line 15: </a><kbd class="ex">    return s;</kbd><br/></p>-->
<a name="vec4-16"/>
<!--<p>  <a href="#src-vec4-16">line 16: </a><kbd class="ex">  }  </kbd><br/></p>-->
<a name="vec4-17"/>
<p>  <a href="#src-vec4-17">line 17: </a><kbd class="ex">  static def cross(v:
    Vector3, w:Vector3): Vector3 </kbd><br/>
<a href="#-16">Last time </a> we put the constraint on the vector lengths 
<a href="#-17">at the end</a>.  We did it that way because we were following
the dot-product example.  For cross product, though, it's just as natural to
say <i>"cross product takes two 3-element vectors"</i> as it is to
say <i>"cross product takes a 3-element vector and another 3-element
  vector"</i>.  We can perfectly well put the size constraint on the
arguments.
</p>


<a name="vec4-18"/>
<!--<p>  <a href="#src-vec4-18">line 18: </a><kbd class="ex">     = [</kbd><br/></p>-->
<a name="vec4-19"/>
<!--<p>  <a href="#src-vec4-19">line 19: </a><kbd class="ex">         v(1)*w(2) - v(2)*w(1), // component 0</kbd><br/></p>-->
<a name="vec4-20"/>
<!--<p>  <a href="#src-vec4-20">line 20: </a><kbd class="ex">         v(2)*w(0) - v(0)*w(2), // component 1</kbd><br/></p>-->
<a name="vec4-21"/>
<!--<p>  <a href="#src-vec4-21">line 21: </a><kbd class="ex">         v(0)*w(1) - v(1)*w(0)  // component 2</kbd><br/></p>-->
<a name="vec4-22"/>
<!--<p>  <a href="#src-vec4-22">line 22: </a><kbd class="ex">       ];</kbd><br/></p>-->
<a name="vec4-23"/>
<!--<p>  <a href="#src-vec4-23">line 23: </a><kbd class="ex">}</kbd><br/></p>-->

<h3>Argument Types Depending On Other Arguments</h3>

<p>
It made sense to think about cross product as taking two <kbd>Vector3</kbd>'s,
saying <i>"Cross product takes a 3-element vector and another 3-element
    vector"</i>. 
We can phrase dot product in the same style -- saying, in effect,
that <i>"dot product takes a vector, and another vector of the same length as
    the first one"</i>.  In X10, this looks like: 
</p>


<!--
public class Vec5 {
  public static def main(argv:Rail[String]!) {
    val v = [1.0, 2.0, 3.0];
    x10.io.Console.OUT.println("v*v = " + dot(v,v));
  }
  static def dot(v: ValRail[Double], w: ValRail[Double]{v.length == length})  = {
    var s : Double = 0.0;
    for((i) in 0 .. v.length - 1) {
      s += v(i) * w(i);
    }
    return s;
  }
}
-->
<table class="ex">
<a name="src-vec5-1"/>
<tr class="ex"><td><a href="#vec5-1" class="ex">1</a></td><td class="ex"><code>public class Vec5 {</code></td></tr>
<a name="src-vec5-2"/>
<tr class="ex"><td><a href="#vec5-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;public static def main(argv:Rail[String]!) {</code></td></tr>
<a name="src-vec5-3"/>
<tr class="ex"><td><a href="#vec5-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val v = [1.0, 2.0, 3.0];</code></td></tr>
<a name="src-vec5-4"/>
<tr class="ex"><td><a href="#vec5-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("v*v = " + dot(v,v));</code></td></tr>
<a name="src-vec5-5"/>
<tr class="ex"><td><a href="#vec5-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec5-6"/>
<tr class="ex"><td><a href="#vec5-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;static def dot(v: ValRail[Double], w: ValRail[Double]{v.length == length})  = {</code></td></tr>
<a name="src-vec5-7"/>
<tr class="ex"><td><a href="#vec5-7" class="ex">7</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;var s : Double = 0.0;</code></td></tr>
<a name="src-vec5-8"/>
<tr class="ex"><td><a href="#vec5-8" class="ex">8</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;for((i) in 0 .. v.length - 1) {</code></td></tr>
<a name="src-vec5-9"/>
<tr class="ex"><td><a href="#vec5-9" class="ex">9</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += v(i) * w(i);</code></td></tr>
<a name="src-vec5-10"/>
<tr class="ex"><td><a href="#vec5-10" class="ex">10</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec5-11"/>
<tr class="ex"><td><a href="#vec5-11" class="ex">11</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;return s;</code></td></tr>
<a name="src-vec5-12"/>
<tr class="ex"><td><a href="#vec5-12" class="ex">12</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-vec5-13"/>
<tr class="ex"><td><a href="#vec5-13" class="ex">13</a></td><td class="ex"><code>}</code></td></tr>
</table>

<a name="vec5-1"/>
<!--<p>  <a href="#src-vec5-1">line 1: </a><kbd class="ex">public class Vec5 {</kbd><br/></p>-->
<a name="vec5-2"/>
<!--<p>  <a href="#src-vec5-2">line 2: </a><kbd class="ex">  public static def main(argv:Rail[String]!) {</kbd><br/></p>-->
<a name="vec5-3"/>
<!--<p>  <a href="#src-vec5-3">line 3: </a><kbd class="ex">    val v = [1.0, 2.0, 3.0];</kbd><br/></p>-->
<a name="vec5-4"/>
<!--<p>  <a href="#src-vec5-4">line 4: </a><kbd class="ex">    x10.io.Console.OUT.println("v*v = " + dot(v,v));</kbd><br/></p>-->
<a name="vec5-5"/>
<!--<p>  <a href="#src-vec5-5">line 5: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="vec5-6"/>
<p>  <a href="#src-vec5-6">line 6: </a><kbd class="ex">  static def dot(v:
    ValRail[Double], w: ValRail[Double]{v.length == length})  = {</kbd><br/>
This is the only line different from <a href="#vec1-6">the previous dot
    product</a>.  In this variation, we have moved the constraint from the
    method as a whole to the type of the argument <kbd>w</kbd>.  
</p>
<a name="vec5-7"/>
<!--<p>  <a href="#src-vec5-7">line 7: </a><kbd class="ex">    var s : Double = 0.0;</kbd><br/></p>-->
<a name="vec5-8"/>
<!--<p>  <a href="#src-vec5-8">line 8: </a><kbd class="ex">    for((i) in 0 .. v.length - 1) {</kbd><br/></p>-->
<a name="vec5-9"/>
<!--<p>  <a href="#src-vec5-9">line 9: </a><kbd class="ex">      s += v(i) * w(i);</kbd><br/></p>-->
<a name="vec5-10"/>
<!--<p>  <a href="#src-vec5-10">line 10: </a><kbd class="ex">    }</kbd><br/></p>-->
<a name="vec5-11"/>
<!--<p>  <a href="#src-vec5-11">line 11: </a><kbd class="ex">    return s;</kbd><br/></p>-->
<a name="vec5-12"/>
<!--<p>  <a href="#src-vec5-12">line 12: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="vec5-13"/>
<!--<p>  <a href="#src-vec5-13">line 13: </a><kbd class="ex">}</kbd><br/></p>-->

<p>
In many cases, including this one, there's no particular advantage or
disadvantage to putting constraints on types rather than on the method as a
whole.  Use whichever approach makes sense for your situation.
</p>

<h2></h2>

<p>
We do not always know, at compile time, what length
a <kbd>ValRail[Double]</kbd> is.  For example, suppose that we want a
method <kbd>talkAbout(a:ValRail[Double], b:ValRail[Double])</kbd>, which: 
</p>
<ol>
<li>If <kbd>a</kbd> and <kbd>b</kbd> are different lengths, print a whiny
  message about that fact;</li>
<li>If they are the same length, print their dot product;</li>
<li>If they are both length 3, print their cross product as well.</li>
</ol>





<div class = "todo">
When X10 is fixed on this topic, finish this section.
</div>

<h2>What <kbd>!</kbd> Means</h2>

<p>
Remember from <a href="01-Tutorial.html#intro-bang">chapter one</a> that
a <kbd>!</kbd> at the end of a type means "the value of this type is
located <kbd>here</kbd>".  
</p>

<p>
Here's what that really means.
</p>

<p>
Every object -- everything that can be one place or another -- has a property
called <kbd>home</kbd>.  <kbd>home</kbd> is of type <kbd>Place</kbd>, and says
where the object is.  <kbd>T!</kbd> is an abbreviation for <kbd>T{home ==
    here}</kbd>.  
</p>

<p>
In fact, <kbd>T!p</kbd> is an abbreviation for <kbd>T{home==p}</kbd>.
</p>

<p>
That's all. 
</p>

<p>
So, place constraints are just a kind of compile-time constraint.
</p>



<h2>Talking about yourself: <kbd>self</kbd> in Type Constraints</h2>

<p>
Suppose you want to talk about the length of a <kbd>ValRail</kbd>, but you've
already got a variable called <kbd>length</kbd> around: 
</p>


<!--
public class Length {
  public static def main(argv:Rail[String]!) {
    val length = "six and a half feet";
    val L : ValRail[Int]{length == 4} =  [0,1,2,3]; // error!
    
  }
}

-->
<table class="ex">
<a name="src-length1-1"/>
<tr class="ex"><td><a href="#length1-1" class="ex">1</a></td><td class="ex"><code>public class Length {</code></td></tr>
<a name="src-length1-2"/>
<tr class="ex"><td><a href="#length1-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;public static def main(argv:Rail[String]!) {</code></td></tr>
<a name="src-length1-3"/>
<tr class="ex"><td><a href="#length1-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val length = "six and a half feet";</code></td></tr>
<a name="src-length1-4"/>
<tr class="ex"><td><a href="#length1-4" class="ex">4</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val L : ValRail[Int]{length == 4} =  [0,1,2,3]; // error!</code></td></tr>
<a name="src-length1-5"/>
<tr class="ex"><td><a href="#length1-5" class="ex">5</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;</code></td></tr>
<a name="src-length1-6"/>
<tr class="ex"><td><a href="#length1-6" class="ex">6</a></td><td class="ex"><code>&nbsp;&nbsp;}</code></td></tr>
<a name="src-length1-7"/>
<tr class="ex"><td><a href="#length1-7" class="ex">7</a></td><td class="ex"><code>}</code></td></tr>
</table>

<a name="length1-1"/>
<!--<p>  <a href="#src-length1-1">line 1: </a><kbd class="ex">public class Length {</kbd><br/></p>-->
<a name="length1-2"/>
<!--<p>  <a href="#src-length1-2">line 2: </a><kbd class="ex">  public static def main(argv:Rail[String]!) {</kbd><br/></p>-->
<a name="length1-3"/>
<p>  <a href="#src-length1-3">line 3: </a><kbd class="ex">    val length =
    "six and a half feet";</kbd><br/>
Declare a variable <kbd>length</kbd>.  This one isn't even an Int.
</p>
<a name="length1-4"/>
<p>  <a href="#src-length1-4">line 4: </a><kbd class="ex">    val L :
    ValRail[Int]{length == 4} =  [0,1,2,3]; // error!</kbd><br/>
Now, try to talk about the length of <kbd>L</kbd>.
</p>
<a name="length1-5"/>
<!--<p>  <a href="#src-length1-5">line 5: </a><kbd class="ex">    </kbd><br/></p>-->
<a name="length1-6"/>
<!--<p>  <a href="#src-length1-6">line 6: </a><kbd class="ex">  }</kbd><br/></p>-->
<a name="length1-7"/>
<!--<p>  <a href="#src-length1-7">line 7: </a><kbd class="ex">}</kbd><br/></p>-->

<p>
This program doesn't compile.  It gets this error: 
</p>
<pre>
/Users/bard/x10/exper/fortut/Length.x10:4: The == operator must have operands of comparable type; the types x10.lang.String and x10.lang.Int do not share any values.
</pre>

<p>
So, what it's complaining about is that <kbd>length</kbd> is a String,
and <kbd>4</kbd> is an Int, and there's no way that a String can <kbd>==</kbd>
an Int.
</p>

<p>
What's <i>really</i> going on is that <kbd>length</kbd> refers to the
variable <kbd>length</kbd> defined on the previous line.  
</p>

<p>
In general, if you have a variable name <kbd>x</kbd> appearing in a
constraint -- like <kbd>Cactus{x==3}</kbd> -- it could mean either of two
things: 
</p>
<ol>
<li>A variable <kbd>x</kbd> defined somewhere before this line of code; or</li>
<li>A property <kbd>x</kbd> of the type <kbd>Cactus</kbd>.</li>
</ol>

<p>
If there's only one of these two, X10 uses the one that it's got. That means
that, in this code: 
</p>
<pre class="ex">
  val x = 10;
  var L : ValRail{length == x}; 
</pre>
<p>
<kbd>length</kbd> is a property of <kbd>ValRail</kbd> and not a variable from
near that line, so it means the <kbd>length</kbd> property.  <kbd>x</kbd> is
a nearby variable and not a property of <kbd>ValRail</kbd>, so it means the
nearby variable.    
</p>

<p>
But, if it could be <i>both</i> a variable <i>and</i> a property, then X10
uses the <b>variable</b>.  
</p>
<pre class="ex">
  val length = "very";
  var L : ValRail{length == 10}; // No good
</pre>
<p>
<kbd>length</kbd> refers to the <i>variable</i> (set to <kbd>"vary"</kbd>),
and <i>not</i> the property.
</p>

<p>
So, what do you do when you've got a surrounding variable
called <kbd>length</kbd>, and you want to talk about the length of
a <kbd>ValRail</kbd>? 
</p>

<p>
X10's answer to use <kbd>self</kbd>. <kbd>self</kbd> is a pseudo-variable,
like <kbd>this</kbd> and <kbd>here</kbd>. It only is used in a type constraint
-- in the <kbd>c</kbd> part of <kbd>T{c}</kbd>. It means "<i>The value of
type <kbd>T</kbd> that <kbd>c</kbd> is constraining</i>".
</p>

<p>
So, if you want to talk about the <kbd>length</kbd> of a ValRail even if
there's a variable called <kbd>length</kbd> around, you can call
it <b><kbd>self.length</kbd></b>.  Like this: 
</p>
<pre class="ex">
  val length = "very";
  var L : ValRail{self.length == 10}; // Good!
</pre>

<p>
Some X10 programmers (including me) prefer to write <kbd>self.someProp</kbd>
instead of just <kbd>someProp</kbd> most of the time.  Doing so makes it quite
obvious that you're talking about a property, not a local variable.
</p>

<p>
Since <kbd>T{...self...}</kbd> refers to the value of type <kbd>T</kbd> that
is being investigated for membership in the constrained type, we can use it in
some surprising ways.  
For example, the type <kbd>Int{self==4}</kbd> is the type of integers which
are equal to <kbd>4</kbd>. There's only one integer like that --
namely, <kbd>4</kbd>.  This seems like a very fussy and particular type to
write -- if you know it's 4, what's the point of having it at all? -- and in
fact <i>you</i> won't write it very much.   
</p>

<p>
But types like this show up in X10 programs all the time.  When you ask for
type inference, the compiler gives you the best types it can.  So, if you
write a line of code like: 
</p>
<pre class="ex">
  val n = 4;
</pre>
<p>
The compiler tries to figure out the X10 type that describes <kbd>4</kbd>
better than any other type. That type is <kbd>Int{self==4}</kbd>: <kbd>4</kbd>
is an <kbd>Int</kbd>, and it's equal to <kbd>4</kbd>. And anything else that
happens to be true about <kbd>4</kbd> surely follows from these two facts.
</p>

<h4>Self and This</h4>

<p>
Some programmers may find <kbd>self</kbd> and <kbd>this</kbd> confusing.
(Especially programmers who have used a language like Self -- the thing
that X10 calls <kbd>this</kbd> is called <kbd>self</kbd> in Self.)  The two
are pretty different, though.
</p>

<p>
<kbd>this</kbd> means the same thing it does in Java and C++.  It's the object
that is getting a method call.   
</p>

<p>
<kbd>self</kbd> is only used in type constraints -- only in the <kbd>c</kbd>
part of <kbd>T{c}</kbd>, where <kbd>T</kbd> is a type.  <kbd>self</kbd> is a
value of type <kbd>T</kbd> -- the value that we're checking to see if it
makes <kbd>c</kbd> true and thereby is a member of <kbd>T{c}</kbd>.   
</p>

<blockquote class="xiom">
<b>Xiom:</b> <kbd>self</kbd> is used in type constraints.  <kbd>this</kbd> is
used in classes.
</blockquote>

<p>
<kbd>this</kbd> means the same thing throughout a whole class definition.
(And it only means something in instance methods, where there's an object of
that class being defined.)
</p>

<p>
<kbd>self</kbd> means the same thing inside of a single type expression. For
example, in <kbd>Cplx{self.x == self.y}</kbd>, <kbd>self</kbd> is the
complex number that is being tested to see if its <kbd>x</kbd>
and <kbd>y</kbd> fields are equal.  
</p>

<p>
But <kbd>self</kbd> means different things in different type expressions.
</p>


<!--
val r : ValRail[Int]{self.length == 3} = [1,2,3];
val z : Cplx{self.x == self.y} = new Cplx(1.8,1.8);
-->
<table class="ex">
<a name="src-self-diff-1"/>
<tr class="ex"><td><a href="#self-diff-1" class="ex">1</a></td><td class="ex"><code>val r : ValRail[Int]{self.length == 3} = [1,2,3];</code></td></tr>
<a name="src-self-diff-2"/>
<tr class="ex"><td><a href="#self-diff-2" class="ex">2</a></td><td class="ex"><code>val z : Cplx{self.x == self.y} = new Cplx(1.8,1.8);</code></td></tr>
</table>

<a name="self-diff-1"/>
<p>  <a href="#src-self-diff-1">line 1: </a><kbd class="ex">val r :
    ValRail[Int]{self.length == 3} = [1,2,3];</kbd><br/>
This <kbd>self</kbd> is talking about <kbd>r</kbd> --
  a <kbd>ValRail[Int]</kbd>. 
</p>
<a name="self-diff-2"/>
<p>  <a href="#src-self-diff-2">line 2: </a><kbd class="ex">val z :
    Cplx{self.x == self.y} = new Cplx(1.8,1.8);</kbd><br/>
This <kbd>self</kbd> is talking about <kbd>z</kbd> -- a <kbd>Cplx</kbd>
  value. 
</p>

<h4>Variables In Place Of <kbd>self</kbd></h4>

<p>
If you're declaring a variable <kbd>v</kbd> of type <kbd>T{c}</kbd>, you can
use the name <kbd>v</kbd> instead of <kbd>self</kbd>.   When this works, it's
a good idea to do it. 
</p>


<!--
val r : ValRail[Int]{r.length == 3} = [1,2,3];
val z : Cplx{z.x = z.y} == new Cplx(1.8,1.8);

-->
<table class="ex">
<a name="src-var-as-self-1"/>
<tr class="ex"><td><a href="#var-as-self-1" class="ex">1</a></td><td class="ex"><code>val r : ValRail[Int]{r.length == 3} = [1,2,3];</code></td></tr>
<a name="src-var-as-self-2"/>
<tr class="ex"><td><a href="#var-as-self-2" class="ex">2</a></td><td class="ex"><code>val z : Cplx{z.x == z.y} = new Cplx(1.8,1.8);</code></td></tr>
</table>

<a name="var-as-self-1"/>
<p>  <a href="#src-var-as-self-1">line 1: </a><kbd class="ex">val r :
    ValRail[Int]{r.length == 3} = [1,2,3];</kbd><br/>
<kbd>r</kbd> is used in place of <kbd>self</kbd> here -- we're asking for
a <kbd>ValRail[Int]</kbd>, called <kbd>r</kbd>, whose <kbd>length</kbd> is 3.
</p>
<a name="var-as-self-2"/>
<p>  <a href="#src-var-as-self-2">line 2: </a><kbd class="ex">val z : Cplx{z.x
    == z.y} = new Cplx(1.8,1.8);</kbd><br/>
<kbd>z</kbd> is used in place of <kbd>self</kbd> here -- we're asking for
a <kbd>Cplx</kbd> whose <kbd>x</kbd> and <kbd>y</kbd> are equal.
</p>

<h5>Beware!</h5>
<p>
Using variable names instead of generic <kbd>self</kbd> is great when it
can be used.  It can't be used everywhere, though -- it can only be used when
there's a variable name around to use.   Sometimes there's not.
</p>

<p>
For example, suppose we want to make a <kbd>ValRail</kbd> containing three
non-zero integers. 
</p>

<ul>
<li>The way to say "non-zero integer" is <kbd>Int{self != 0}</kbd>.  </li>
<li>The way to say "ValRail of non-zero integers" is <kbd>ValRail[Int{self !=
    0}]</kbd></li>. 
<li>The way to say "ValRail of three <kbd>T</kbd>'s"
  is <kbd>ValRail[T]{self.length == 3}</kbd>.</li>
<li>So, the way to say "ValRail of three non-zero integers", which is what we
  want, is 
  <kbd>ValRail[ Int{self != 0} ] {self.length == 3}</kbd>
  </li>
</ul>

<p>
Note that the two <kbd>self</kbd>s in there mean different things. The left
one, the one that isn't zero, is the <kbd>Int</kbd> value that is to be a
member of the ValRail.  The right one, the one whose length is three, is the
ValRail itself.
</p>

<p>
If we were making a variable <kbd>nz</kbd> of this type, we could write it
like this: 
</p>

<!--
    val nz : ValRail[ Int{self != 0} ] {nz.length == 3} = [1,2,3];

-->
<table class="ex">
<a name="src-nz-1"/>
<tr class="ex"><td><a href="#nz-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;&nbsp;&nbsp;val nz : ValRail[ Int{self != 0} ] {nz.length == 3} = [1,2,3];</code></td></tr>
</table>

<a name="nz-1"/>
<p>  <a href="#src-nz-1">line 1: </a><kbd class="ex">    val nz : ValRail[
    Int{self != 0} ] {nz.length == 3} = [1,2,3];</kbd><br/>
The <i>right</i> <kbd>self</kbd>, the one that refers to the ValRail, can be
    replaced by the variable <kbd>nz</kbd> -- because <kbd>nz</kbd> refers to
  the whole ValRail of nonzero numbers.  The <i>left</i> <kbd>self</kbd> talks
    about an Int which is a member of <kbd>nz</kbd>.  There's no variable in
    this line of code which refers to the members of <kbd>nz</kbd>.  So, we
    can't replace it by a variable.  It's got to be <kbd>self</kbd>. 
</p>

<h3>Caveat about <kbd>Double</kbd> and <kbd>Float</kbd></h3>

<p>
X10 v2.0.1 is fussy about its floating point.  <kbd>Float</kbd> constants have
a following <kbd>f</kbd>: <kbd>0.0f</kbd>, <kbd>1.1f</kbd>.  <kbd>Double</kbd>
constants don't: <kbd>0.0</kbd>, <kbd>1.1</kbd>.  
</p>

<p>
In IEEE floating point, double-precision numbers aren't simply
single-precision numbers with more precision.  Single-precision numbers can
get as big as 3.4 &times; 10<sup>38</sup>.  Double-precision numbers have a
vastly larger range: up to about 1.8 &times; 10<sup>308</sup>.  
</p>

<p>
Obviously, there's no good way to store a large double-precision number in a
single-precision space.  So, as of X10 v2.0.1, there's no automatic conversion
from <kbd>Double</kbd> to <kbd>Float</kbd>.  You need to write the one you
mean, explicitly.
</p>

<p>
This may be relaxed somewhat in later version ... but there will never be a
way to store 1.8 &times; 10<sup>308</sup> in a <kbd>Float</kbd>.
</p>


<h3>Caveats about Guards</h3>
<p>
Since braces <kbd>{...}</kbd> are used to group statements in X10, you
need to pay close attention to tell which is which.  Guards show up in these
places: 
</p>
<ol>
<li>After type names: <kbd>Rail[Float]{length == 3}</kbd>. This one is easy
  -- there's no other way that braces should show up here.</li>
<li>On class definitions, to provide class invariants.</li>
<li>After argument lists in method definitions.</li>
</ol>

<p>
The second and third choices are tricky, because braces <kbd>{...}</kbd> can
mean two things in that place.  Braces mean constraints -- and they also mean
code bodies.
</p>

<p>
When there are two sets of braces, the first one is for the constraint, and
the second one is for the code body.
</p>

<p>
When there's only <i>one</i> set of braces, it's the one it has to be -- the
code body.  
</p>


<!--
  static def codeBody(x:Int){return x != 0;}
  static def constraint1(x:Double){x != 0.0} {return 1/x;}
  static def constraint2(x:Double){x != 0.0} = {return 1/x;}
-->
<table class="ex">
<a name="src-bracing-1"/>
<tr class="ex"><td><a href="#bracing-1" class="ex">1</a></td><td class="ex"><code>&nbsp;&nbsp;static def codeBody(x:Int){return x != 0;}</code></td></tr>
<a name="src-bracing-2"/>
<tr class="ex"><td><a href="#bracing-2" class="ex">2</a></td><td class="ex"><code>&nbsp;&nbsp;static def constraint1(x:Double){x != 0.0} {return 1/x;}</code></td></tr>
<a name="src-bracing-3"/>
<tr class="ex"><td><a href="#bracing-3" class="ex">3</a></td><td class="ex"><code>&nbsp;&nbsp;static def constraint2(x:Double){x != 0.0} = {return 1/x;}</code></td></tr>
</table>

<a name="bracing-1"/>
<p>  <a href="#src-bracing-1">line 1: </a><kbd class="ex">  static def
    codeBody(x:Int){return x != 0;}</kbd><br/>
These braces are for a <i>code body</i>.  You can tell that because the thing
    inside them is a statement, not an expression.
</p>
<a name="bracing-2"/>
<p>  <a href="#src-bracing-2">line 2: </a><kbd class="ex">  static def
    constraint1(x:Double){x != 0.0} {return 1/x;}</kbd><br/>
The first braces <kbd>{x != 0.0}</kbd> are a constraint.  The second one are
    for the code body.
</p>
<a name="bracing-3"/>
<p>  <a href="#src-bracing-3">line 3: </a><kbd class="ex">  static def
    constraint2(x:Double){x != 0.0} = {return 1/x;}</kbd><br/>
This is just like <a href="#src-bracing-2">the last one</a>, except that it's
    written a bit more clearly. There's an <kbd>=</kbd> between the constraint
    and the code body.    The <kbd>=</kbd> is optional and does nothing but
    separate the two sets of braces.  Some people, including me, find it
    easier to read.
</p>


</body>
</html>
