<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Struct declaration</title>
</head>

<body>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Struct declaration</h2>

<div class="p"><!----></div>
X10 supports user-defined primitives (called
<em>structs</em>). Like classes, structs define zero or more fields and
zero or more methods, and may implement zero or more interfaces. A
struct has the same modifiers as a class. However, structs are
implicitly <b>val</b> and do <em>not</em> participate in any code
inheritance relation. (This makes structs very easy to implement,
without vtables.)

<div class="p"><!----></div>
<pre>
{<em>{</em>StructModifiers}}<sup>{</sup>{?}}
struct C[X<sub>1</sub>, &#8230;, X<sub>n</sub>](p<sub>1</sub>:T<sub>1</sub>, &#8230;, p<sub>n</sub>:T<sub>n</sub>){c} 
   implements I<sub>1</sub>, &#8230;, I<sub>k</sub> {
{<em>{</em>StructBody}}
}
</pre>

<div class="p"><!----></div>
Each field and method in a struct is implicitly marked <b>global</b>.  

<div class="p"><!----></div>
The size of a variable of struct type <b>C</b> is the size of the fields
defined at <b>C</b> (up to alignment considerations). No extra space is
allocated for a vtable or an itable. This means that unlike classes,
structs cannot be defined recursively. That is, a struct <b>S</b> cannot
contain a field of type <b>S</b>, or a field of struct type <b>T</b> which,
recursively, contains a field of type <b>S</b>.

<div class="p"><!----></div>

<ul>
<li> More precisely, we require that the set of <em>size equations</em>
  for all structs and classes must have a unique solution. A size
  equation for a struct <b>S</b> is defined as follows. Assume <b>S</b> has m fields
  of type <b>S</b><sub>i</sub> (for i in 0,&#8230;,m&#8722;1), and n fields of type (class) <b>C</b><sub>j</sub>
  (for j in 0,&#8230;,n&#8722;1). Then the size equation for <b>S</b> is 
<pre>
size(S) = size(S<sub>0</sub>)+&#8230;+size(S<sub>{m</sub>&#8722;1})+size(C<sub>0</sub>)+&#8230;+size(C<sub>{n</sub>&#8722;1}) 
</pre>
The size
equation for a class <b>C</b> is just <b>size(C) = AddressSize</b>, where
<b>AddressSize</b> is a compile-time parameter.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Values of a struct <b>C</b> type can be created by invoking a constructor
defined in <b>C</b>, but without prefixing it with <b>new</b>.

<div class="p"><!----></div>
Constrained types can be built on top of the base <b>C</b> in the same way as
they can be built on top of a class <b>D</b>. In struct <b>C[T1,..., Tn]{c}</b>,
the type of <b>self</b> in {c} is <b>C[T1,..., Tn]</b>.

<div class="p"><!----></div>

</body>
</html>