<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Type parameters</title>
</head>

<body>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Type parameters</h2>
<a name="TypeParameters">
</a>

<div class="p"><!----></div>
        A class, interface, method, or closure may have type parameters
        whose scope is the signature and body of the declaring
        class, interface, method,
        or closure.

        Similarly, a type definition may have
        type parameters that scope over the body of the type
        definition.

<div class="p"><!----></div>
        Type parameters may be constrained by a <em>guard</em> on the declaration
        (, ,

        ,).

        The type parameters of classes and interfaces must be
        bound to concrete types (possibly to a type parameter)
        for the type to be legal; thus "List[int]" and
        "List[C]" are legal types, but "List" alone is
        not.
        The type parameters of
        methods and closures

        must be bound to
        concrete types at invocation.
        Parametrized type definitions specify new type
        constructors; the type parameters of a type definition must be bound
        to yield a type.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Generic types</h3>
<a name="Generics">
</a>

        A <em>generic class</em> is a class
        declared with one or more type parameters.  Generic
        classes can be instantiated by instantiating the type
        parameters of the base type.

<div class="p"><!----></div>
Consider the following declaration of a "Cell" class.
<pre>
class Cell[X] {
    var x: X;
    def this(x: X) { this.x = x; }
    def get(): X = x;
    def set(x: X) = { this.x = x: }
}
</pre>

<div class="p"><!----></div>
This declares a class "Cell" with a type parameter "X".
"Cell" may be used as a type by instantiating "X".

<div class="p"><!----></div>
"Cell[int]" is the type of all "Cell" containing an
&#239;nt".  The "get" method returns an &#239;nt"; the
&#223;et" method takes an &#239;nt" as argument.  Note that
"Cell" alone is not a legal type because the parameter is
not bound.

<div class="p"><!----></div>
Parameters may be declared as invariant, covariant (""+'''),
or contravariant (""-''').

<div class="p"><!----></div>
Given types "S" and "T".

<ul>
<li>If a parameter "X" of a class or interface "C" is
<em>covariant</em>, then 
"C[S]" is a subtype of "C[T]" if
"S" is a <em>subtype</em> of "T".
<div class="p"><!----></div>
</li>

<li>
If a parameter "X" of a class or interface "C" is
<em>covariant</em>, then 
"C[S]" is a subtype of "C[T]" if
"S" is a <em>supertype</em> of "T".
<div class="p"><!----></div>
</li>

<li>
If a parameter "X" of a class or interface "C" is
<em>invariant</em>, then 
if "S" is a <em>supertype</em> of "T", then
"C[S]" is a subtype of "C[T]" if
"S" is <em>equal</em> to "T".
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Consider the following class declarations:
<pre>
class Get[+X] {
    var x: X;
    def this(x: X) { this.x = x; }
    def get(): X = x;
}

<div class="p"><!----></div>
class Set[-X] {
    var x: X;
    def this(x: X) { this.x = x; }
    def set(x: X) = { this.x = x: }
}
</pre>
In this example, "Get[Integer]" is a subtype of
"Get[Number]" since &#207;nteger" is a subtype of
"Number" and the parameter "X" of "Get" is covariant;
"Set[Number]" is a subtype of
"Get[Integer]" since "Number" is a supertype of
&#207;nteger"
 and the parameter "X" of "Set" is contravariant;

<div class="p"><!----></div>
The "X" parameter of the "Cell" class above is invariant.
Thus, "Cell[Integer]" and "Cell[Number]" are
incomparable;
      "Cell[Integer]" is a (reflexive) subtype of "Cell[Integer]"
      and
      "Cell[Number]" is a (reflexive) subtype of
      "Cell[Number]".

<div class="p"><!----></div>

</body>
</html>