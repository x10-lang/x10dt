<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Atomic blocks</title>
</head>

<body>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Atomic blocks</h2><a name="AtomicBlocks">
</a>
Languages such as Java use low-level synchronization locks to allow
multiple interacting threads to coordinate the mutation of shared
data. X10 eschews locks in favor of a very simple high-level
construct, the <em>atomic block</em>.

<div class="p"><!----></div>
A programmer may use atomic blocks to guarantee that invariants of
shared data-structures are maintained even as they are being accessed
simultaneously by multiple activities running in the same place.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Unconditional atomic blocks</h3>
The simplest form of an atomic block is the <em>unconditional
atomic block</em>:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement &nbsp;AtomicStatement </td></tr>
<tr><td align="right">AtomicStatement &nbsp;&#228;tomic"  Statement </td></tr>
<tr><td align="right">MethodModifier &nbsp;&#228;tomic" </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
For the sake of efficient implementation X10 v2.0 requires
that the atomic block be <em>analyzable</em>, that is, the set of
locations that are read and written by the <em>BlockStatement</em> are
bounded and determined statically.<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>
The exact algorithm to be used by
the compiler to perform this analysis will be specified in future
versions of the language.


<div class="p"><!----></div>
Such a statement is executed by an activity as if in a single step
during which all other concurrent activities in the same place are
suspended. If execution of the statement may throw an exception, it is
the programmer's responsibility to wrap the atomic block within a
"try"/"finally" clause and include undo code in the finally
clause. Thus the &#228;tomic" statement only guarantees atomicity on
successful execution, not on a faulty execution.

<div class="p"><!----></div>
We allow methods of an object to be annotated with &#228;tomic". Such
a method is taken to stand for a method whose body is wrapped within an
&#228;tomic" statement.

<div class="p"><!----></div>
Atomic blocks are closely related to non-blocking synchronization
constructs [], and can be used to implement 
non-blocking concurrent algorithms.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
In &#228;tomic S", "S" may include method calls,
conditionals, etc.

<div class="p"><!----></div>
It may <em>not</em> include an &#228;sync" activity (such as creation
of a "future").

<div class="p"><!----></div>
It may <em>not</em> include any statement that may potentially block at
runtime (e.g., "when", "force" operations, "next"
operations on clocks, "finish"). 

<div class="p"><!----></div>
All locations accessed in an atomic block must statically satisfy the
<em>locality condition</em>: they must belong to the place of the current
activity.<a name="LocalityCondition">
</a> 

<div class="p"><!----></div>
The compiler checks for this condition by checking whether the statement
could be the body of a "void" method annotated with &#223;afe" at
that point in the code (&#167;).

<div class="p"><!----></div>

<b>Consequences.&nbsp;&nbsp;</b>
Note an important property of an (unconditional) atomic block:

<div class="p"><!----></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 \xcd&#228;<span class="roman">tomic</span> {<span class="roman">s</span><span class="roman">1</span><span class="roman">;</span> <span class="roman">atomic</span> <span class="roman">s</span><span class="roman">2</span>}" </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">\xcd&#228;<span class="roman">tomic</span> {<span class="roman">s</span><span class="roman">1</span><span class="roman">;</span> <span class="roman">s</span><span class="roman">2</span>}"</td></tr></table></td><td width="50%"></td><td width="1" align="right">(1)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Further, an atomic block will eventually terminate successfully or
thrown an exception; it may not introduce a deadlock.

<div class="p"><!----></div>
      <h4><a name="tth_sEc11.1.1">
11.1.1</a>&nbsp;&nbsp;Example</h4>

<div class="p"><!----></div>
The following class method implements a (generic) compare and swap (CAS) operation:

<div class="p"><!----></div>
<pre>
// target defined in lexically enclosing environment.
public atomic def CAS(old: Object, new: Object): Boolean {
   if (target.equals(old)) {
     target = new;
     return true;
   }
   return false;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Conditional atomic blocks</h3>

<div class="p"><!----></div>
Conditional atomic blocks are of the form:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement &nbsp;WhenStatement </td></tr>
<tr><td align="right">WhenStatement &nbsp;"when" "(" Expression ")" Statement </td></tr>
<tr><td align="right">\ -  WhenStatement &#246;r" "(" Expression ")" Statement 
</td></tr></table>
</em>

<div class="p"><!----></div>
In such a statement the one or more expressions are called <em>
guards</em> and must be "Boolean" expressions. The statements are the
corresponding <em>guarded statements</em>. The first pair of expression
and statement is called the <em>main clause</em> and the additional pairs
are called <em>auxiliary clauses</em>. A statement must have a main
clause and may have no auxiliary clauses.

<div class="p"><!----></div>
An activity executing such a statement suspends until such time as any
one of the guards is true in the current state. In that state, the
statement corresponding to the first guard that is true is executed.
The checking of the guards and the execution of the corresponding
guarded statement is done atomically. 

<div class="p"><!----></div>
X10 does not guarantee that a conditional atomic block
will execute if its condition holds only intermmittently. For, based on
the vagaries of the scheduler, the precise instant at which a
condition holds may be missed. Therefore the programmer is advised to
ensure that conditions being tested by conditional atomic blocks are
eventually stable, i.e., they will continue to hold until the block
executes (the action in the body of the block may cause the condition
to not hold any more).

<div class="p"><!----></div>

<div class="p"><!----></div>
 Rationale:
The guarantee provided by "wait"/"notify" in Java is no
stronger. Indeed conditional atomic blocks may be thought of as a
replacement for Java's wait/notify functionality.
 

<div class="p"><!----></div>
We note two common abbreviations. The statement "when (true) S" is
behaviorally identical to &#228;tomic S": it never suspends. Second,
"when (c) ;" may be abbreviated to &#228;wait(c);"-it
simply indicates that the thread must await the occurrence of a
certain condition before proceeding.  Finally note that a "when"
statement with multiple branches is behaviorally identical to a
"when" statement with a single branch that checks the disjunction of
the condition of each branch, and whose body contains an
&#239;f"/"then"/&#235;lse" checking each of the branch conditions.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
For the sake of efficient implementation certain restrictions are
placed on the guards and statements in a conditional atomic
block. 


<div class="p"><!----></div>
Guards are required not to have side-effects, not to spawn
asynchronous activities and to have a statically determinable upper
bound on their execution. These conditions are expected to be checked
statically by the compiler.

<div class="p"><!----></div>
The body of a "when" statement must satisfy the conditions
for the body of an &#228;tomic" block.

<div class="p"><!----></div>
Note that this implies that guarded statements are required to be <em>
flat</em>, that is, they may not contain conditional atomic blocks. (The
implementation of nested conditional atomic blocks may require
sophisticated operational techniques such as rollbacks.)

<div class="p"><!----></div>

<b>Sample usage.&nbsp;&nbsp;</b> 
There are many ways to ensure that a guard is eventually
stable. Typically the set of activities are divided into those that
may enable a condition and those that are blocked on the
condition. Then it is sufficient to require that the threads that may
enable a condition do not disable it once it is enabled. Instead the
condition may be disabled in a guarded statement guarded by the
condition. This will ensure forward progress, given the weak-fairness
guarantee.

<div class="p"><!----></div>
The following class shows how to implement a bounded buffer of size
1 in X10 for repeated communication between a sender and a
receiver.

<div class="p"><!----></div>
<pre>
class OneBuffer {
  datum: Object = null;
  filled: Boolean = false;
  public def send(v: Object) {
    when (!filled) {
      this.datum = v;
      this.filled = true;
    }
  }
  public def receive(): Object {
    when (filled) {
      v: Object = datum;
      datum = null;
      filled = false;
      return v;
    }
  }
}
</pre>


<div class="p"><!----></div>

</body>
</html>