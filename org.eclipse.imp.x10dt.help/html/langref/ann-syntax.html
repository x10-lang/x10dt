<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Annotation syntax</title>
</head>

<body>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Annotation syntax</h2>

<div class="p"><!----></div>
The annotation syntax consists of an "<tt>@</tt>" followed by an interface type.

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Annotation ::= <b>@</b> InterfaceBaseType Constraints<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Annotations can be applied to most syntactic constructs in the language
including class declarations, constructors, methods, field declarations,
local variable declarations and formal parameters, statements,
expressions, and types.
Multiple occurrences of the same annotation (i.e., multiple
annotations with the same interface type) on the same entity are permitted.

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">ClassModifier ::= Annotation </td></tr>
<tr><td align="right">InterfaceModifier ::= Annotation </td></tr>
<tr><td align="right">FieldModifier ::= Annotation </td></tr>
<tr><td align="right">MethodModifier ::= Annotation </td></tr>
<tr><td align="right">VariableModifier ::= Annotation </td></tr>
<tr><td align="right">ConstructorModifier ::= Annotation </td></tr>
<tr><td align="right">AbstractMethodModifier ::= Annotation </td></tr>
<tr><td align="right">ConstantModifier ::= Annotation </td></tr>
<tr><td align="right">Type ::= AnnotatedType </td></tr>
<tr><td align="right">AnnotatedType ::= Annotation<sup>+</sup>&nbsp;Type </td></tr>
<tr><td align="right">Statement ::= AnnotatedStatement </td></tr>
<tr><td align="right">AnnotatedStatement ::= Annotation<sup>+</sup>&nbsp;Statement </td></tr>
<tr><td align="right">Expression ::= AnnotatedExpression </td></tr>
<tr><td align="right">AnnotatedExpression ::= Annotation<sup>+</sup>&nbsp;Expression </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Recall that interface types may have dependent parameters.

<div class="p"><!----></div>
The following examples illustrate the syntax:

<div class="p"><!----></div>

<ul>
<li> Declaration annotations:
<pre>
  // class annotation
  @Value
  class Cons { ... }

<div class="p"><!----></div>
  // method annotation
  @PreCondition(0 &lt;= i &amp;&amp; i &lt; this.size)
  public def get(i: Int): Object { ... }

<div class="p"><!----></div>
  // constructor annotation
  @Where(x != null)
  def this(x: T) { ... }

<div class="p"><!----></div>
  // constructor return type annotation
  def this(x: T): C@Initialized { ... }

<div class="p"><!----></div>
  // variable annotation
  @Unique x: A;
</pre>
<div class="p"><!----></div>
</li>

<li> Type annotations:
<pre>
  List@Nonempty

<div class="p"><!----></div>
  Int@Range(1,4)

<div class="p"><!----></div>
  Array[Array[Double]]@Size(n * n)
</pre>
<div class="p"><!----></div>
</li>

<li> Expression annotations:
<pre>
  m() : @RemoteCall
</pre>
<div class="p"><!----></div>
</li>

<li> Statement annotations:
<pre>
  @Atomic { ... }

<div class="p"><!----></div>
  @MinIterations(0)
  @MaxIterations(n)
  for (var i: Int = 0; i &lt; n; i++) { ... }

<div class="p"><!----></div>
  // An annotated empty statement ;
  @Assert(x &lt; y);
</pre>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

</body>
</html>