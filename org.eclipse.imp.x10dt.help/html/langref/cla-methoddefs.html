<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Method definitions</title>
</head>

<body>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Method definitions</h2>

<div class="p"><!----></div>
X10 permits guarded method definitions. 

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodDeclaration &nbsp;MethodHeader ";" </td></tr>
<tr><td align="right">\ -  MethodHeader "=" ClosureBody </td></tr>
<tr><td align="right">MethodHeader &nbsp;
  MethodModifiers<sup>?</sup>&nbsp;"def" Identifier TypeParameters<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&amp;&amp; "(" 
  FormalParameterList<sup>?</sup>&nbsp;")" Guard<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&amp;&amp; ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A formal parameter may optionally have a "val" or "var"
modifier (default: "val").  
The body of the method is executed in an environment in which 
each formal parameter corresponds to a local variable
and is initialized with the value of the actual parameter.
The local variable  is mutable if and only if the
parameter is a "var" parameter.

<div class="p"><!----></div>
<a name="MethodGuard">
</a>The guard (specified by <em>Guard</em>)
specifies a constraint "c" on the
properties of the class "C" on which the method is being defined. The
method exists only for those instances of "C" which satisfy "c".  It is
illegal for code to invoke the method on objects whose static type is
not a subtype of "C{c}".

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
The compiler checks that every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    for a method is type correct. Each each argument
    &#235;<sub>i</sub>" must have a
    static type "S<sub>i</sub>" that is a subtype of the declared type
    "T<sub>i</sub>" for the ith
    argument of the method, and the conjunction of static types
    of the arguments must entail the guard in the parameter list
    of the method.

<div class="p"><!----></div>
    The compiler checks that in every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    the static type of &#246;", "S", is a subtype of "C{c}", where the method
    is defined in class "C" and the guard for "m" is equivalent to
    "c".

<div class="p"><!----></div>
    Finally, if the declared return type of the method is
    "D{d}", the
    return type computed for the call is
    "D{a: S; x<sub>1</sub>: S<sub>1</sub>; ...; x<sub>n</sub>: S<sub>n</sub>; d[a/this]}",
    where &#228;" is a new
    variable that does not occur in
    "d, S, S<sub>1</sub>, ..., S<sub>n</sub>", and
    "x<sub>1</sub>, ..., x<sub>n</sub>" are the formal
    parameters of the method.

The method body is either an expression, a block of statements,
or a block ending with an expression.

<div class="p"><!----></div>
Consider the program:
<pre>
type Point(r:Int)=Point{self.rank==r};
final public class Point(rank: Int) implements (Int) =&#62; Int {
    public global val coords: ValRail[Int](rank);
    public global safe def apply(i: Int) = coords(i);
    public global safe def coords() = coords;
    public global safe operator - this: Point(rank) 
       = Point.make(rank, (i:Int)=&#62;-this.coords(i));
    public global safe operator this + (that: Point(rank)): Point(rank) 
       = Point.make(rank, (i:Int)=&#62; this.coords(i) + that.coords(i));
    ...
}
</pre>

<div class="p"><!----></div>
The following code fragment will typecheck:
<pre>
s: Point(3) = new Point([1,2,3]);
t: Point(3) = new Point([-1,-1,-1]);
u: Point(3) = s + u;
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Property methods</h3>

<div class="p"><!----></div>
A method declared with the modifier "property" may be used
in constraints.  A property method declared in a class must have
a body and must not be "void".  The body of the method must
consist of only a single "return" statement or a single
expression.  It is a static error if the expression cannot be
represented in the constraint system. 

<div class="p"><!----></div>
The expression may contain invocations of other properties. It is the
responsibility of the programmer to ensure that the evaluation of 
a property terminates at compile-time, otherwise the type-checker
will not terminate and the program will fail to compile.

<div class="p"><!----></div>
Property methods in classes are implicitly "final"; they cannot be
overridden.

<div class="p"><!----></div>
A property method definition may omit the formal parameters and
the "def" keyword.  That is, the following are equivalent:

<div class="p"><!----></div>
<pre>
property def rail(): boolean = rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
property rail: boolean = rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Method overloading, overriding, hiding, shadowing and obscuring</h3>
<a name="MethodOverload">
</a>

<div class="p"><!----></div>
The definitions of method overloading, overriding, hiding, shadowing
and obscuring in X10 are the same as in Java, modulo the following
considerations motivated by type parameters and dependent types.

<div class="p"><!----></div>
Two or more methods of a class or interface may have the same
name if they have a different number of type parameters, or
they have value parameters of different types.

<div class="p"><!----></div>
X10 v2.0 does not permit overloading based on constraints. 

<div class="p"><!----></div>
The definition of a method declaration "m<sub>1</sub>" "having the same signature
as" a method declaration "m<sub>2</sub>" involves identity of types. 

<div class="p"><!----></div>
The <em>constraint erasure</em> of a type "T" is defined as follows.
The constraint erasure of  (a)&nbsp;a class, interface or struct type "T" is 
"T"; (b)&nbsp;a type "T{c}" is the constraint erasure of 
"T"; (b)&nbsp;a type "T[S<sub>1</sub>,...,S<sub>n</sub>]" 
is "T'[S<sub>1</sub>',...,S<sub>n</sub>']" where each primed type is the erasure of 
the corresponding unprimed type.
 Two methods are said to have <em>the
  same signature</em> if (a) they have the same number of type parameters,
(b) they have the same number of formal (value) parameters, and (c)
for each formal parameter the constraint erasure of its types are equivalent. It is a
compile-time error for there to be two methods with the same name and
same signature in a class (either defined in that class or in a
superclass).

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
A class "C" may not have two declarations for a method named "m"-either
  defined at "C" or inherited:
<pre>
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: T<sub>1</sub>, ..., v<sub>n</sub>: T<sub>n</sub>){tc}: T {...}
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: S<sub>1</sub>, ..., v<sub>n</sub>: S<sub>n</sub>){sc}: S {...}
</pre>

if it is the case that the constraint erasures of the types "T<sub>1</sub>",
..., "T<sub>n</sub>" are
equivalent to the constraint erasures of the types "S<sub>1</sub>, ..., T<sub>n</sub>"
respectively.


<div class="p"><!----></div>
In addition, the guard of a overriding method must be 
no stronger than the guard of the overridden method.   This
ensures that any virtual call to the method
satisfies the guard of the callee.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
If a class "C" overrides a method of a class or interface
  "B", the guard of the method in "B" must entail
  the guard of the method in "C".


<div class="p"><!----></div>
A class "C" inherits from its direct superclass and superinterfaces all
their methods visible according to the access modifiers
of the superclass/superinterfaces that are not hidden or overridden. A method "M<sub>1</sub>" in a class
"C" overrides
a method "M<sub>2</sub>" in a superclass "D" if
"M<sub>1</sub>" and "M<sub>2</sub>" have the same signature.
Methods are overriden on a signature-by-signature basis.

<div class="p"><!----></div>
A method invocation &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
is said to have the <em>static signature</em>
&#171;T, T<sub>1</sub>, ..., T<sub>n</sub>&#62;" where "T" is the static type of
&#246;", and
"T<sub>1</sub>",
...,
"T<sub>n</sub>"
are the static types of &#235;<sub>1</sub>", ..., &#235;<sub>n</sub>",
respectively.  As in
Java, it must be the case that the compiler can determine a single
method defined on "T" with argument type
"T<sub>1</sub>", ... "T<sub>n</sub>"; otherwise, a
compile-time error is declared. However, unlike Java, the X10 type "T"
may be a dependent type "C{c}". Therefore, given a class definition for
"C" we must determine which methods of "C" are available at a type
"C{c}". But the answer to this question is clear: exactly those methods
defined on "C" are available at the type "C{c}"
whose guard "d" is implied by "c".

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Method qualifiers</h3>
<a name="MethodQualifier">
</a>


<div class="p"><!----></div>
      <h4><a name="tth_sEc6.3.1">
6.3.1</a>&nbsp;&nbsp;&#228;tomic" qualifier</h4>
<a name="AtomicAnnotation">
</a>


<div class="p"><!----></div>
A method may be declared &#228;tomic".

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodModifier &nbsp;&#228;tomic"  
</td></tr></table>
</em>

<div class="p"><!----></div>
Such a method is treated as if the statement in its body is wrapped 
implicitly in an &#228;tomic" statement.

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.3.2">
6.3.2</a>&nbsp;&nbsp;"global" qualifier</h4>
<a name="LocalAnnotation">
</a>
<a name="GlobalMethod">
</a>


<div class="p"><!----></div>
A method may be declared "global".

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodModifier &nbsp;"global"  
</td></tr></table>
</em>

<div class="p"><!----></div>
A "global" method can be invoked on an object &#246;" in any place. The
body of such a method is type-checked without assuming that
"here==this.home". This permits "global" fields of &#246;" to
be accessed, but not local fields. The programmer must insert an explicit
&#228;t(this)..." to get to the place where the object lives and access
the field.

<div class="p"><!----></div>
"global" methods can be overridden only by methods also marked "global".

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.3.3">
6.3.3</a>&nbsp;&nbsp;"pinned" qualifier</h4>
<a name="PinnedAnnotation">
</a>
<a name="PinnedMethod">
</a>


<div class="p"><!----></div>
A method may be declared "pinned".

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodModifier &nbsp;"pinned"  
</td></tr></table>
</em>

<div class="p"><!----></div>
A "pinned" method may not
contain any &#228;t" statement or expression whose place argument
is not statically equivalent to "here". It must call only
"pinned" methods. That is, a "pinned" method does not cause
any communication.

<div class="p"><!----></div>
"pinned" methods can be overridden only by methods marked "pinned".

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.3.4">
6.3.4</a>&nbsp;&nbsp;"nonblocking" qualifier</h4>
<a name="NonblockingAnnotation">
</a>
<a name="NonblockingMethod">
</a>


<div class="p"><!----></div>
A method may be declared "nonblocking".

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodModifier &nbsp;"nonblocking"  
</td></tr></table>
</em>

<div class="p"><!----></div>
A "nonblocking" method may not
contain any "when" statement whose condition
is not statically equivalent to "true". It must call only
"nonblocking" methods. That is, a "nonblocking" method does not block.

<div class="p"><!----></div>
"nonblocking" methods can be overridden only by methods marked "nonblocking".

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.3.5">
6.3.5</a>&nbsp;&nbsp;&#223;equential" qualifier</h4>
<a name="SequentialAnnotation">
</a>
<a name="SequentialMethod">
</a>


<div class="p"><!----></div>
A method may be declared &#223;equential".

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodModifier &nbsp;&#223;equential"  
</td></tr></table>
</em>

<div class="p"><!----></div>
A &#223;equential" method may not contain any &#228;sync"
statement. It must call only &#223;equential" methods. That is, a
&#223;equential" method does not spawn any activity.

<div class="p"><!----></div>
&#223;equential" methods can be overridden only by methods marked &#223;equential".

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.3.6">
6.3.6</a>&nbsp;&nbsp;&#223;afe" qualifier</h4>
<a name="SafeAnnotation">
</a>
<a name="SafeMethod">
</a>


<div class="p"><!----></div>
A method may be declared &#223;afe".

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodModifier &nbsp;&#223;afe"  
</td></tr></table>
</em>

<div class="p"><!----></div>
The &#223;afe" annotation is considered shorthand for "pinned
  nonblocking sequential".

<div class="p"><!----></div>

</body>
</html>