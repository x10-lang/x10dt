<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Type inference</title>
</head>

<body>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Type inference</h2>
<a name="TypeInference">
</a>



<div class="p"><!----></div>
X10 v2.0 supports limited local type inference, permitting
variable types and return types to be elided.
It is a static error if an omitted type cannot be inferred or
uniquely determined.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Variable declarations</h3>

<div class="p"><!----></div>
The type of a variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Return types</h3>

<div class="p"><!----></div>
The return type of a method can be omitted if the method has a
body (i.e., is not &#228;bstract" or &#235;xtern").  The
inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a constructor can be omitted if the
constructor has a body (i.e., is not &#235;xtern").
The inferred return type is the enclosing class type with
properties bound to the arguments in the constructor's "property"
statement, if any, or to the unconstrained class type.

<div class="p"><!----></div>
The inferred type of a method or closure body is the least common ancestor
of the types of the expressions in "return" statements
in the body.  If the method does not return a value, the
inferred type is "Void".

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Type arguments</h3>

<div class="p"><!----></div>
A call to a polymorphic method may omit the
explicit type arguments.  If the method has a type parameter
"T", the type argument corresponding to "T" is inferred
to be the least common ancestor of the types of any formal
parameters of type "T".

<div class="p"><!----></div>
Consider the following method:
<pre>
def choose[T](a: T, b: T): T { ... }
</pre>
Given "Set[T] &lt;: Collection[T]"
and "List[T] &lt;: Collection[T]",
in the following snippet, the algorithm will infer the type
"Collection[Any]" for "x".
<pre>
def m(intSet: Set[Int], stringList: List[String]) {
  val x = choose(intSet, stringList);
...
}
</pre>
And in this snippet, the algorithm should infer the type
"Collection[Int]" for &#255;".
<pre>
def m(intSet: Set[Int], intList: List[Int]) {
  val y = choose(intSet, intList);
  ...
}
</pre>
Finally, in this snippet, the algorithm should infer the type
"Collection{T &lt;: Number}" for "z".
<pre>
def m(intSet: Set[Int], numList: List{T &lt;: Number}) {
  val z = choose(intSet, numList);
  ...
}
</pre>

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>In order to allow this version of the language
  to focus on the core new ideas, X10 v2.0 does not have
  user-definable class loaders, though there is no technical reason
  why they could not have been added.

</body>
</html>