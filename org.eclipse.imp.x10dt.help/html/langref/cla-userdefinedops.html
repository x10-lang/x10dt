<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>User-Defined Operators</title>
</head>

<body>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;User-Defined Operators</h2>

<div class="p"><!----></div>
It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a <b>Poly</b> class of
polynomials - for the sake of illustration, single-variable polynomials with
<b>Int</b> coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: <b>+</b> to add, <b>*</b> to multiply,
<b>-</b> to subtract, and <b>p(x)</b> to compute the value of the polynomial at
argument <b>x</b>.  We would like to write code thus: 
<pre>
  public static def main(Rail[String]):Void {
     val X = new Poly([0,1]);
     val t &lt;: Poly = 7 * X + 6 * X * X * X; 
     val u &lt;: Poly = 3 + 5*X - 7*X*X;
     val v &lt;: Poly = t * u - 1;
     for ( (i) in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Writing the same code with method calls, while possible, is far less elegant: 
<pre>
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t &lt;: UglyPoly = X.mult(7).plus(X.mult(X).mult(X).mult(6));  
     val u &lt;: UglyPoly = const(3).plus(X.mult(5)).minus(X.mult(X).mult(7));
     val v &lt;: UglyPoly = t.mult(u).minus(1);
     for ( (i) in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
</pre>

<div class="p"><!----></div>
The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as <b>1+X</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Binary Operators</h3>

<div class="p"><!----></div>
Defining the sum <b>P+Q</b> of two polynomials looks much like a method
definition.  It uses the <b>operator</b> keyword instead of <b>def</b>, and
<b>this</b> appears in the definition in the place that a <b>Poly</b> would
appear in a use of the operator.  So, 
<b>operator this + (p:Poly!)</b> explains how to add <b>this</b> to a
<b>Poly!</b> value.
<pre>
class Poly {
  public global val coeff : ValRail[Int];
  public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
  public global def degree() = coeff.length()-1;
  public global def  a(i:Int) = (i&lt;0 </td><td width="150">
&#124;</td><td width="150">
&#124; i&#62;this.degree()) ? 0 : coeff(i);

<div class="p"><!----></div>
  public operator this + (p:Poly!) =  new Poly(
     ValRail.make[Int](
        Math.max(this.coeff.length(), p.coeff.length()),
        (i:Int) =&#62; this.a(i) + p.a(i)
     )); 
  // ... 
</pre>

<div class="p"><!----></div>
The sum of a polynomial and an integer, <b>P+3</b>, looks like
an overloaded method definition.  
<pre>
   public operator (n : Int) + this = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
However, we want to allow the sum of an integer and a polynomial as well:
<b>3+P</b>.  It would be quite inconvenient to have to define this as a method
on <b>Int</b>; changing <b>Int</b> is far outside of normal coding.  So, we
allow it as a method on <b>Poly</b> as well.

<div class="p"><!----></div>
<pre>
   public operator this + (n : Int) = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
<b>Poly</b>s could have been written:
<pre>
  public static operator (p:Poly!) + (q:Poly!) =  new Poly(
     ValRail.make[Int](
        Math.max(q.coeff.length(), p.coeff.length()),
        (i:Int) =&#62; q.a(i) + p.a(i)
     ));
</pre>

<div class="p"><!----></div>
This requires the following syntax:<br />

  :
  |
  
  
  
  <em>
  
<table>

<tr><td align="right">MethodHeader ::=
  <b>operator</b> TypeParameterList<sup>?</sup>&nbsp;<b>this</b> BinOp <b>(</b>  FormalParameter <b>)</b> </td></tr>
<tr><td align="right">&amp;&amp; Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">MethodHeader ::=
  <b>operator</b> TypeParameterList<sup>?</sup>&nbsp;<b>(</b>  FormalParameter <b>)</b> BinOp <b>this</b>  </td></tr>
<tr><td align="right">&amp;&amp; Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">MethodHeader ::=
  <b>operator</b> TypeParameterList<sup>?</sup>&nbsp;<b>(</b>  FormalParameter <b>)</b> BinOp  <b>(</b>  FormalParameter <b>)</b>  </td></tr>
<tr><td align="right">&amp;&amp; Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
When X10 attempts to typecheck a binary operator expression like <b>P+Q</b>, it
first typechecks <b>P</b> and <b>Q</b>. Then, it looks for operator declarations
for <b>+</b> in the types of <b>P</b> and <b>Q</b>. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a <em>best-matching</em> operation,  one which does
not require the operands to be converted to another type. For example,
<b>operator this + (n:Long)</b> and <b>operator this + (n:Int)</b> both apply to
<b>p+1</b>, because <b>1</b> can be converted from an <b>Int</b> to a <b>Long</b>.
However, the <b>Int</b> version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.

<div class="p"><!----></div>
The main difference between expressing a binary operation as an instance
method (with a <b>this</b> in the definition) and a static one (no <b>this</b>)
is that instance methods don't apply any conversions, while static methods
attempt to convert both arguments. 


<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Unary Operators</h3>

<div class="p"><!----></div>
Unary operators are defined in a similar way, with <b>this</b> appearing in the
<b>operator</b> definition where an actual value would occur in a unary
expression.  The operator to negate a polynomial is: 

<div class="p"><!----></div>
<pre>
  public operator - this = new Poly(
    ValRail.make[Int](coeff.length(), (i:Int) =&#62; -coeff(i))
    );
</pre>

<div class="p"><!----></div>
The syntax for unary operators is:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodHeader ::=
  <b>operator</b> PrefixOp <b>this</b>    Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;
</td></tr></table>
</em>

<div class="p"><!----></div>
The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;Type Conversions</h3>

<div class="p"><!----></div>
Explicit type conversions, <b>e as T{c}</b>, can be defined as operators on
class <b>T</b>.

<div class="p"><!----></div>
<pre>
class Poly {
  public global val coeff : ValRail[Int];
  public def this(coeff: ValRail[Int]) { this.coeff = coeff;}
  public static operator (a:Int) as Poly! = new Poly([a]);
  public static def main(Rail[String]):Void {
     val three : Poly! = 3 as Poly!;
  }
}
</pre>

<div class="p"><!----></div>
You may define a type conversion to a constrained type, like <b>Poly!</b> in
the previous example.   If you convert to a more specific constraint, X10 will use
the conversion, but insert a dynamic check to make sure that you have
satisfied the more specific constraint.  For example: 
<pre>
class Uni(n:Int) {
  public def this(n:Int) : Uni{self.n==n} = {property(n);}
  static operator (String) as Uni{self.n != 9} = new Uni(3);
  public static def main(Rail[String]):Void {
    val u = "" as Uni{self.n != 9 &amp;&amp; self.n != 3};
  }
}
</pre>
The string <b>""</b> is converted to <b>Uni{self.n != 9}</b> via the defined
conversion operator, and that value is checked against the remaining
constraints <b>{self.n != 3}</b> at runtime.  (In this case it will fail.)

<div class="p"><!----></div>
There may be many conversions from different types to <b>T</b>, but there may
be at most one conversion from any given type to <b>T</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.4">
8.4</a>&nbsp;&nbsp;Implicit Type Coercions</h3>

<div class="p"><!----></div>
You may also define <em>implicit</em> type coercions to <b>T{c}</b> as static
operators in class <b>T</b>.  The syntax for this is
<b>static operator (x:U) : T{c} = e</b>.
Implicit coercions are used automatically by the compiler.  


<div class="p"><!----></div>
For example, we can define an implicit coercion from <b>Int</b> to <b>Poly!</b>,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define <b>+</b> on
two polynomials (using a <b>static</b> operator, so that implicit coercions
will be used - they would not be for an instance method operator).  The
calculation <b>1+x</b> coerces <b>1</b> to a polynomial and uses polynomial
addition to add it to <b>x</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static safe operator (c : Int) : Poly! = new Poly([c]);

<div class="p"><!----></div>
  public static operator (p:Poly!) + (q:Poly!) = new Poly(
      ValRail.make[Int](
        Math.max(p.coeff.length(), q.coeff.length()),
        (i:Int) =&#62; p.a(i) + q.a(i)
     ));

<div class="p"><!----></div>
  public static def main(Rail[String]):Void {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.5">
8.5</a>&nbsp;&nbsp;<b>set</b> and <b>apply</b></h3>

<div class="p"><!----></div>
X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The <b>Array</b>-like classes take advantage
of both of these in <b>a(i) = a(i) + 1</b>.  Unlike unary and binary operators,
subscripting and indexed assignment are done by methods, <b>apply</b> and
<b>set</b> respectively.

<div class="p"><!----></div>
<b>a(b,c,d)</b> is short for the method call <b>a.apply(b,c,d)</b>.  Since it is
possible to overload methods, the application syntax can be overloaded.  For
example, an ordered dictionary structure could allow subscripting by numbers
with <b>def apply(i:Int)</b>, and by string-valued keys with 
<b>def apply(s:String)</b>.  

<div class="p"><!----></div>
<b>a(i)=b</b> is short for the method call <b>a.set(b,i)</b>, with one or more
indices <b>i</b>. (This has a
possibly surprising consequence for the order of evaluation: in <b>a(i)=b</b>,
as in <b>a.set(b,i)</b>, <b>a</b> is evaluated first, then <b>b</b>, and finally
<b>i</b>.)  Again, it is possible to overload <b>set</b> to provide a variety of
subscripting operations.  Each <b>set</b> method must have a corresponding
<b>apply</b> method; that is, <b>a(i,j)=b</b> is only defined when <b>a(i,j)</b>
is defined, despite the fact that <b>a(i,j)=b</b> does not evaluate <b>a(i,j)</b>.

<div class="p"><!----></div>
The <b>Oddvec</b> class of somewhat peculiar vectors illustrates this.
<b>a()</b> returns a string representation of the oddvec, which probably should
be done by <b>toString()</b> instead.  <b>a(i)</b> picks out one of the three
coordinates of <b>a</b>, which is sensible.  <b>a(i)=b</b> assigns to one of the
coordinates.  <b>a(i,j)=b</b> assigns different values to <b>a(i)</b> and
<b>a(j)</b>, purely for the sake of the example.

<div class="p"><!----></div>
<pre>
class Oddvec {
  var v : Rail[Int]! = Rail.make[Int](3, (Int)=&#62;0);
  public def apply() = "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public def apply(i:Int) = v(i);
  public def apply(i:Int, j:Int) = [v(i),v(j)];
  public def set(newval:Int, i:Int) = {v(i) = newval;}
  public def set(newval:Int, i:Int, j:Int) = {
       v(i) = newval; v(j) = newval+1;} 
  // ... 
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.5.1">
8.5.1</a>&nbsp;&nbsp;<b>proto</b> Rules</h4>
<a name="protorules">
</a>
<a name="ProtoRules">
</a>


<div class="p"><!----></div>
For every type <b>T</b> (where <b>T</b> is not a type variable), we
introduce the type <b>proto T</b>. 

<div class="p"><!----></div>
There is no relationship between types <b>T</b> and <b>proto T</b> -
neither is a subtype of the other.<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>

<div class="p"><!----></div>
Incomplete types are permitted to occur only as types of method
parameters or local variables or as return types for methods and
constructors. They may not occur in (the source or target of) cast
statements, <b>extends</b> or <b>implements</b> clauses, <b>catch</b>
clauses, or as types of class fields.

<div class="p"><!----></div>
Within the body of a class <b>C</b> the type of <b>this</b> in
constructors, instance initializers and instance variable initializers
is <b>proto C</b>.

<div class="p"><!----></div>
Let {v} be a value of type <b>proto C</b>, for some class <b>C</b>. 

<div class="p"><!----></div>
No fields of {v} can be read.  (This is the defining property of
<b>proto</b> types.)  However, {v}'s (accessible) instance fields
can be assigned.

<div class="p"><!----></div>
{v} can be assigned to an instance field <b>o.f</b> only if <b>f</b>
is of some type <b>S</b> such that <b>T &lt;: S</b> and <b>o</b> has an
incomplete type.

<div class="p"><!----></div>
{v} can be assigned to local variables  only if they are of some type
<b>proto S</b> (such that <b>T &lt;: S</b>).

<div class="p"><!----></div>
Instance methods of class <b>C</b> may be qualified with <b>proto</b>
(these methods are called <em>incomplete methods</em>). The type of <b>this</b>
in incomplete methods is <b>proto C</b>. Incomplete methods can be
overridden only by incomplete methods.  Only incomplete methods can be
invoked on {v}. Incomplete methods which do not take an argument of incomplete
type can be invoked on completed values. 

<div class="p"><!----></div>
{v} can be passed as argument into a constructor or method call,
or returned from a method.  The return type of a method taking an
argument at an incomplete type must be <b>void</b> or incomplete.  The
return type of a constructor taking an argument at a <b>proto</b> type
must be incomplete.

<div class="p"><!----></div>
A generic type parameter <b>T</b> can be instantiated with the type <b>proto
  S</b> (where <b>S</b> is not a type parameter itself), provided that the body of
the entity being instantiated satisfies the conditions above for <b>proto
  S</b>.

<div class="p"><!----></div>
During code generation, the type <b>proto T</b> is treated as if it were
<b>T</b>. That is, there is no run-time cost to <b>proto</b> types.

<div class="p"><!----></div>
The invariants maintained by the design are as follows.  Say that an
object field or stack variable (local variable) contains an incomplete
value if a value of type <b>proto T</b> (for some <b>T</b>) was written
into it.

<div class="p"><!----></div>

<ul>
<li> If an object <b>o</b> has a field containing an incomplete value {v},
then either {v}'s constructor has exited or <b>o</b> is confined.
Further, every reference to <b>o</b> on the stack is held at an incomplete type.
<div class="p"><!----></div>
</li>

<li> If a stack variable contains an incomplete value, then
  the variable's type is incomplete.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Say that a constructor invocation for a class <b>C</b> on the call
stack is a <em>root</em> if it takes no incomplete arguments. Such a
constructor invocation will return an object of type <b>C</b> whose
fields may point to an arbitrary graph of newly created objects
(objects created by the activity after the constructor
invocation). Since the object returned is at type <b>C</b> - and not
<b>proto C</b> - It may be assigned to any field of any object on the
heap of type <b>D</b> such that <b>C &lt;: D</b>.  It is no longer
confined. Thus the "magic moment" when an incomplete value becomes
complete is when the last constructor for any incomplete value it
references (including itself) returns.

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.5.2">
8.5.2</a>&nbsp;&nbsp;Proto Example: Circular Buffer</h4>

<div class="p"><!----></div>
This example shows how to create a fixed-size circular buffer.
(Its pointer structure is immutable, though the contents of each
field are mutable.)



<div class="p"><!----></div>

</body>
</html>