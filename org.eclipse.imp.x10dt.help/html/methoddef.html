<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Method Definitions</title>
</head>

<body>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Method definitions</h2>

<div class="p"><!----></div>
 X10 permits guarded method definitions, similar to guarded
field definitions. Additionally, the parameter list for a method may
contain a WhereClause.

<div class="p"><!----></div>
<pre>
MethodHeader ::= 
  MethodModifiersopt ResultType 
  MethodDeclarator Throwsopt
MethodDeclarator ::= 
  ThisClauseopt identifier 
  ( FormalParameterListopt WhereClauseopt )
  |  MethodDeclarator [ ]

<div class="p"><!----></div>
ResultType ::= Type  |  void
</pre>

<div class="p"><!----></div>
The guard (specified by <tt>ThisClause</tt>) speciifes a constraint <tt>c</tt> on the
properties of the class <tt>C</tt> on which the method is being defined. The
method exists only for those instances of <tt>C</tt> which satisfy <tt>c</tt>.  It is
illegal for code to invoke the method on objects whose static type is
not a subtype of <tt>C(:c)</tt>.

<div class="p"><!----></div>
We relax the rules of lexical visibility and finality for variable
references in deptypes for method parameters.  Method
parameters not necessarily declared to be final are permitted to occur
in the types of parameters that occur after them in textual
order. Method parameters may also occur in the ReturnType for the
method, as long as they are declared final. (Even though the ReturnType
occurs lexically before the parameter list, it is considered to lie in
the scope of the declarations in the parameter list.)

<div class="p"><!----></div>

<blockquote>   Static semantics Rule: 
    The compiler checks that every method invocation <tt>o.m(e1,..., en)</tt>
    for a method is type correct. Each each argument ei must have a
    static type Si that is a subtype of the declared type Ti for the ith
    argument of the method, and the conjunction of static types
    of the arguments must entail the WhereClause in the parameter-list
    of the method.

<div class="p"><!----></div>
    The compiler checks that in every method invocation <tt>o.m(e1,...,
    en)</tt> the static type of o, S, is a subtype of C(:c), where the method
    is defined in class C and the ThisClause for m is equivalent to
    <tt>this(:c)</tt>.

<div class="p"><!----></div>
    Finally, if the declared return type of the method is D(:d), the
    return type computed for the call is <tt>D(: final S a; S1 x1; ...; Sn
    xn; d[a/this])</tt>, where a is a new variable that does not occur in
    <tt>d, S, S1, ... , Sn</tt>, and <tt>x1,...,xn</tt> are the formal parameters of the
    method.
</blockquote>

<div class="p"><!----></div>
<b>Example 10.1</b> Consider the program:
  <pre>
public class List(int(:n &#62;=0) n) {
  protected this(:n &#62; 0) Object  value;
  protected this(:n &#62; 0) List(n-1)  tail;
  public List(t.n+1)(Object o, List t) {
      n=t.n+1;
      tail = t;
      value = o;
  }
  public List(:self.n==0) () {
      n=0;
  }
  public List(:self.n==this.n+l.n) append(List l) {
      return (n==0)? l 
         : new List( value, tail.append(l)); 
  }
  public this(:n&#62;0) 
    Object nth(final int(:k &#62;= 1 &amp;&amp; k &lt;= n) k) {
      return k==1 ? value : tail.nth(k-1);
  }
}
</pre>

<div class="p"><!----></div>
The following code fragment
<pre>
List(:self.n==3) u = ...
List(:self.n==x) t = ...;
List(:self.n==x+3) s = t.append(u);
</pre>

<div class="p"><!----></div>
 will typecheck. The type of the expression <tt>t.append(u)</tt> is 
<pre>
List(: final List(:self.n==x) a; 
       List(:self.n==3) l; self.n== a.n+l.n)  
</pre>

<div class="p"><!----></div>
 and this simplifies to
<pre>
List(: final List(:self.n==x) a; 
       List(:self.n==3) l; self.n== x+3)  
</pre>

<div class="p"><!----></div>
 which, after dropping unused local variables, reduces to:
<pre>
List(: self.n== x+3)  
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;Method overloading, overriding, hiding, shadowing and obscuring</h3>

<div class="p"><!----></div>
The definitions of method overloading, overriding, hiding, shadowing
and obscuring in  X10 are the same as in Java, modulo the following
considerations motivated by dependent types.

<div class="p"><!----></div>
The definition of a method declaration <tt>m1</tt> "having the same signature
as" a method declaration <tt>m2</tt> involves identity of types. Two  X10 types
are defined to be identical iff they are equivalent (&#167;&nbsp;4.7</a>).
Two methods are said to have <em>the same signature</em> if (a)
they have the same number of formal parameters, (b) for each parameter
their types are equivalent, and (c) the constraints associated with
their ThisTypes are equivalent. It is a compile-time error for there
to be two methods with the same name and same signature in a class
(either defined in that class or in a superclass).

<div class="p"><!----></div>

<blockquote>    Static Semantics Rule:
  A class <tt>C</tt> may not have two declarations for a method named <tt>m</tt> - either
  defined at <tt>C</tt> or inherited -
<pre>
T this(:tc) m(T1(:t1) v1,..., Tn(:tn) vn) {...}
S this(:sc) m(S1(:s1) v1,..., Sn(:sn) vn) {...}
</pre>

<div class="p"><!----></div>
   if it is the case that the types <tt>this(:tc), T1(:t1), ...., Tn(:tn)</tt> are
  equivalent to the types <tt>this(:sc), S1(:t1), ...., Tn(:tn)</tt>
  respectively.
</blockquote>

<div class="p"><!----></div>
A class <tt>C</tt> inherits from its direct superclass and superinterfaces all
their methods visible according to the access restriction modifiers
public/private/protected/(package) of the superclass/superinterfaces
that are not hidden or overridden. A method <tt>M1</tt> in a class <tt>C</tt> overrides
a method <tt>M2</tt> in a superclass <tt>D</tt> if <tt>M1</tt> and <tt>M2</tt> have the same signature.
Methods are overriden on a signature-by-signature basis.

<div class="p"><!----></div>
A method invocation <tt>o.m(e1,..., en)</tt> is said to have the <em>static
signature</em> <tt>&lt;T, T1,...,Tn&#62;</tt> where <tt>T</tt> is the static type of <tt>o</tt>, and
<tt>T1,..., Tn</tt> are the static types of <tt>e1,..., en</tt> respectively.  As in
Java, it must be the case that the compiler can determine a single
method defined on <tt>T</tt> with argument type <tt>T1,..., Tn</tt>, otherwise a
compile-time error is declared. However, unlike Java, the  X10 type <tt>T</tt>
may be a dependent type <tt>C(:c)</tt>. Therefore, given a class definition for
<tt>C</tt> we must determine which methods of <tt>C</tt> are available at a type
<tt>C(:c)</tt>. But the answer to this question is clear: exactly those methods
defined on <tt>C</tt> are available at the type <tt>C(:c)</tt> whose guard <tt>d</tt> is implied
by <tt>c</tt>.

<div class="p"><!----></div>
  <b>Example 10.2</b> Consider the definitions:
  <pre>
class Point(int i, int j) {...}
class Line(Point s, Point(:self != i) e) {
//m1: Both points lie in the right half of the plane
  this(:s.i&#62;= 0 &amp;&amp; e.i &#62;= 0) void draw() {...}
// m2 - Both points lie on the y-axis
  this(:s.i== 0 &amp;&amp; e.i == 0) void draw() {...}
// m3 - Both points lie in the top half of the plane
  this(:s.j&#62;= 0 &amp;&amp; e.j &#62;= 0) void draw() {...}
  // m4  - The general method
  void draw() {...}
} 
</pre>   

<div class="p"><!----></div>
  Three different implementations are given for the draw method, one
  for the case in which the line lies in the right half of the plane,
  one for the case that the line lies on the y-axis and the third for
  the case that the line lies in the top half of the plane.

<div class="p"><!----></div>
  Consider the invocation
Line(:s.i &lt; 0) m = ...
m.draw();

<div class="p"><!----></div>
  This generates a compile time error because there is no applicable
  method definition.

<div class="p"><!----></div>
  Consider the invocation

<div class="p"><!----></div>
<pre>
Line(:s.i&#62;=0 &amp;&amp; s.j&#62;=0 &amp;&amp; e.i&#62;=0 &amp;&amp; e.j&#62;=0) 
  m = ...
m.draw();
</pre>

<div class="p"><!----></div>
  This generates a compile time error because both m1 and m3 are applicable.

<div class="p"><!----></div>
  Consider the invocation
<pre>
Line(:s.i&#62;=0 &amp;&amp; s.j&#62;=0 &amp;&amp; e.i&#62;=0) m = ...
m.draw();
</pre>

<div class="p"><!----></div>
  This does not generate any compile-time error since only m1 is
  applicable. 


<div class="p"><!----></div>
In the last example, notice that at runtime <tt>m1</tt> will be invoked
(assuming <tt>m</tt> contains an instance of the <tt>Line</tt> class, and not some
subclass of <tt>Line</tt> that overrides this method). This will be the case
even if <tt>m</tt> satisfies at runtime the stronger conditions for <tt>m2</tt> (i.e.,
<tt>s.i==0 &amp;&amp; e.i==0</tt>). That is, dynamic method lookup will not take into
account the  "strongest" constraint that the receiver may satisfy, i.e.
its "strongest deptype". 

<div class="p"><!----></div>
<em> DESIGN RATIONALE.
  The design decision that dynamic method lookup should ignore
  dependent type information was made to keep the design and the
  implementation simple and to ensure that serious errors such as
  method invocation errors are captured at compile-time.

<div class="p"><!----></div>
  Consider the above example and the invocation
  <pre>
   Line m = ...
   m.draw();    
</pre>  

<div class="p"><!----></div>
   Statically the compiler will not report an error because m4 is the
   only method that is applicable. However, if dynamic method lookup
   were to use deptypes then we would face the problem that if m is a
   line that lives in the upper right quadrant then *both* m2 and m3
   are applicable and one does not override the other. Hence we must
   report an error dynamically.

<div class="p"><!----></div>
   As discussed above, the programmer can write code with <tt>instanceof</tt>
   and classcasts that perform any application-appropriate
   discrimination.  
</em>
</body>
</html>