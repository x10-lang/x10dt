<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Value Classes</title>
</head>

<body>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Value classes</h2><a name="ValueClasses">
</a>

<div class="p"><!----></div>
 X10 singles out a certain set of classes for additional
support. A class is said to be <em>stateless</em> if all of its fields
are declared to be <tt>final</tt> (&#167;&nbsp;3.5.1), otherwise it
is <em>stateful</em>. ( X10 has syntax for specifying an array class
with final fields, unlike  Java.) A <em>stateless (stateful)
object</em> is an instance of a stateless (stateful) class.

<div class="p"><!----></div>
 X10 allows the programmer to signify that a class (and all its
descendents) are stateless. Such a class is called a <em>value
class</em>.  The programmer specifies a value class by prefixing the
modifier <tt>value</tt> before the keyword <tt>class</tt> in a class
declaration.  (A class not declared to be a value class will be called
a <em>reference class</em>.)  Each instance field of a value class is
treated as <tt>final</tt>. It is legal (but neither required nor recommended)
for fields in a value class to be declared final. For brevity, the  X10
compiler allows the programmer to omit the keyword <tt>class</tt> after
<tt>value</tt> in a value class declaration.

<div class="p"><!----></div>
<pre>
447  ClassDeclaration ::= ValueClassDeclaration
448  ValueClassDeclaration ::= 
       ClassModifiersopt value identifier Superopt 
          Interfacesopt ClassBody
449   |  ClassModifiersopt value class identifier 
          Superopt Interfacesopt ClassBody
</pre>

<div class="p"><!----></div>
The <tt>nullable</tt> type-constructor (&#167;&nbsp;3.2) can
be used to declare variables whose value may be <tt>null</tt> or a value
type.

<div class="p"><!----></div>
Stable equality for value types is defined through a deep walk,
bottoming out in fields of reference types (&#167;&nbsp;12.4.3).


<div class="p"><!----></div>

<b>Static semantics.&nbsp;&nbsp;</b>
It is a compile-time error for a value class to inherit from a
stateful class or for a reference class to inherit from a value
class. All fields of a value class are implicitly declared <tt>
final</tt>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Representation</h3>

<div class="p"><!----></div>
Since value objects do not contain any updatable locations, they can
be freely copied from place to place. An implementation may use
copying techniques even within a place to implement value types,
rather than references. This is transparent to the programmer.

<div class="p"><!----></div>
More explicitly,  X10 guarantees that an implementation must always
behave as if a variable of a reference type takes up as much space as
needed to store a reference that is either null or is bound to an
object allocated on the (appropriate) heap. However,  X10 makes no
such guarantees about the representation of a variable of value
type. The implementation is free to behave as if the value is stored
"inline", allocated on the heap (and a reference stored in the
variable) or use any other scheme (such as structure-sharing) it may
deem appropriate. Indeed, an implementation may even dynamically
change the representation of an object of a value type, or dynamically
use different representations for different instances (that is,
implement automatic box/unboxing of values).

<div class="p"><!----></div>
Implementations are strongly encouraged to implement value types as
space-efficiently as possible (e.g. inlining them or passing them in
registers, as appropriate).  Implementations are expected to cache
values of remote final value variables by default. If a value is
large, the programmer may wish to consider spawning a remote activity
(at the place the value was created) rather than referencing the
containing variable (thus forcing it to be cached).

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Example</h3>


<div class="p"><!----></div>
A functional <tt>LinkedList</tt> program may be written as follows:

<div class="p"><!----></div>
<pre>
value LinkedList  { 
  Object first;
  nullable LinkedList rest;
  public
     LinkedList(Object first) {
     this(first, null);
  }
  public
    LinkedList(Object first,  
               nullable LinkedList rest) {
    this.first = first;
    this.rest = rest;
  }
  public 
    Object first() {
    return first;
  }
  public 
    nullable LinkedList rest() {
    return rest;
  } 
  public
    LinkedList append(LinkedList l) {
    return (this.rest == null) 
        ? new LinkedList(this.first, l) 
        : this.rest.append(l);
  }
}
</pre>

<div class="p"><!----></div>
Similarly, a <tt>Complex</tt> class may be implemented as follows:
<pre>
value Complex  { 
  double re;
  double im;
  public
     Complex(double re, double im) {
     this.re=re;
     this.im=im;
  }
  public Complex add(Complex other) {
    return new Complex(this.re+other.re,
                       this.im+other.im);
  }
  public Complex mult(Complex other) {
    return new Complex(this.re^2-other.re^2,
                       2*this.im*other.im);
  }
  ...
}
</pre>
</body>
</html>