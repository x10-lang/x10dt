<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Clocks</title>
</head>

<body>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />Clocks</h1><a name="XtenClocks">
</a>

The standard library for  X10, <tt>x10.lang</tt> defines a <tt>final
value class</tt>, <tt>clock</tt> intended for repeated quiescence detection
of arbitrary, data-dependent collection of activities. Clocks are a
generalization of <em>barriers</em>. They permit dynamically created
activities to register and deregister. An activity may be registered
with multiple clocks at the same time. In particular, nested clocks
are permitted: an activity may create a nested clock and within one
phase of the outer clock schedule activities to run to completion on
the nested clock.  Neverthless the design of clocks ensures that
deadlock cannot be introduced by using clock operations, and that
clock operations do not introduce any races.

<div class="p"><!----></div>
This chapter describes the syntax and semantics of clocks and
statements in the language that have parameters of type <tt>clock</tt>. 

<div class="p"><!----></div>
The key invariants associated with clocks are as follows.  At any
stage of the computation, a clock has zero or more <em>registered</em>
activities. An activity may perform operations only on those clocks it
is registered with (these clocks constitute its <em>clock set</em>).  An
activity is registered with one or more clocks when it is created.
During its lifetime the only additional clocks it is registered with
are exactly those that it creates. In particular it is not possible
for an activity to register itself with a clock it discovers by
reading a data-structure.

<div class="p"><!----></div>
An activity may perform the following operations on a clock <tt>
c</tt>. It may <em>unregister</em> with <tt>c</tt> by executing <tt>
c.drop();</tt>. After this, it may perform no further actions on <tt>c</tt>
for its lifetime. It may <em>check</em> to see if it is unregistered on a
clock. It may <em>register</em> a newly forked activity with <tt>c</tt>.
It may <em>resume</em> the clock by executing <tt>c.resume();</tt>. This
indicates to <tt>c</tt> that it has finished posting all statements it
wishes to perform in the current phase. Finally, it may <em>block</em>
(by executing <tt>next;</tt>) on all the clocks that it is registered
with. (This operation implicitly <tt>resume</tt>'s all clocks for the
activity.) It will resume from this statement only when all these
clocks are ready to advance to the next phase.

<div class="p"><!----></div>
A clock becomes ready to advance to the next phase when every activity
registered with the clock has executed at least one <tt>resume</tt>
operation on that clock and all statements posted for completion in
the current phase have been completed.

<div class="p"><!----></div>
Though clocks introduce a blocking statement (<tt>next</tt>) an important
property of  X10 is that clocks cannot introduce deadlocks. That
is, the system cannot reach a quiescent state (in which no activity is
progressing) from which it is unable to progress. For, before blocking
each activity resumes all clocks it is registered with. Thus if a
configuration were to be stuck (that is, no activity can progress) all
clocks will have been resumed. But this implies that all activities
blocked on <tt>next</tt> may continue and the configuration is not stuck.
The only other possibility is that an activity may be stuck on <tt>
finish</tt>. But the interaction rule between <tt>finish</tt> and clocks
(&#167;&nbsp;) guarantees that this cannot cause a cycle
in the wait-for graph. A more rigorous proof may be found in [].
</body>
</html>