<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>A Potpourri of Types</title>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />A Potpourri of Types</h1><a name="chp:tsl">
</a>

<div class="p"><!----></div>
We have already mentioned a few of the basic types that X10 provides in its
standard library.  We will look at some more of them here.  Our discussion will be far
from complete, but it will at least get you started and aware of where to look
as you need more. A complete API for the library can be found in
<a href="http://dist.codehaus.org/x10/xdoc/">http://dist.codehaus.org/x10/xdoc/</a>.  

<div class="p"><!----></div>
The library is very much a work in progress.
For that reason, some of this chapter may become out-of-date reasonably
quickly, mostly, if not entirely, because X10's resources will rapidly become
richer. We will try to keep this guide in step as best we can.    

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;The Numbers Game</h2>

     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;The Players</h3>
X10 provides the usual sorts of basic numeric types:

<dl compact="compact">

	<dd><b>Byte, Short, Int, Long: </b>  8-bit, 16-bit, 32-bit, and 64-bit signed integers.</dd>

	<dd><b>UByte, UShort, UInt, ULong: </b>  8-bit, 16-bit, 32-bit, and 64-bit <em>unsigned</em> integers.</dd>

	<dd><b>Float, Double: </b> single and double precision IEEE floating point.</dd>
</dl>
It also supplies a double-precision <tt>Complex</tt> type that FORTRAN and C++ programmers have come to expect.
All of these types are in the package <tt>x10.lang</tt>.

<div class="p"><!----></div>
In terms of what these types mean and how they get used, X10 is consistent
with what other languages do, so we won't go into a lot of detail here.  In
particular,  implicit conversions will be performed as needed. For the signed
numeric types, the conversions are between a type  and any type to its right:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;Byte&nbsp;&lt;&nbsp;Short&nbsp;&lt;&nbsp;Int&nbsp;&lt;&nbsp;Long&nbsp;&lt;&nbsp;Float&nbsp;&lt;&nbsp;Double
</pre>
And the similarly for unsigned types

<pre>&nbsp;&nbsp;&nbsp;&nbsp;UByte&nbsp;&lt;&nbsp;UShort&nbsp;&lt;&nbsp;UInt&nbsp;&lt;&nbsp;ULong&nbsp;&lt;&nbsp;Float&nbsp;&lt;&nbsp;Double
</pre>

<div class="p"><!----></div>
Let us be a little more clear about our vocabulary here:

<blockquote>
<b>Coercions:</b> Suppose we declare a variable "<tt>i</tt>" to be an <tt>Int</tt>:
<tt>var i: Int;</tt> The expression "<tt>i as Long</tt>" is X10's syntax for
saying "convert <tt>i</tt> to be a <tt>Long</tt>."  In one sense, this conversion
involves no substantive change to <tt>i</tt>'s value as an integer.  On the other
hand, when we realize <tt>i as Long</tt> in memory, or in CPU register, the full 8
byte representation of a long integer will be used.  This sort of
conversion-in form, but not in substance-is usually called a <em>coercion</em>.

<div class="p"><!----></div>
<b>Casts:</b>  Another sort of conversion is that from <tt>Int</tt> to <tt>Byte</tt>. 
The value of the expression "<tt>i as Byte</tt>" is the result of masking out the
leading 24 bits of <tt>i</tt> and regarding what is left as a <tt>Byte</tt>, meaning
an integer in the range from -128 to 127.  If, for example, <tt>i</tt> is 4095,
which in hex is <tt>0xfff</tt>, then masking out the leading bits leaves us with
<tt>0xff</tt>, so <tt>4095 as Byte == -1 as Byte</tt>. 

<div class="p"><!----></div>
A conversion like that from <tt>Int</tt> to <tt>Byte</tt>, or more dramatically, from
<tt>Long</tt> to <tt>Double</tt> that may involve more than a change to the physical
representation of the value is called a <em>cast</em>.

<div class="p"><!----></div>
The example of "<tt>4095 as Byte == -1 as Byte</tt>" shows that casting can be
dangerous. Here, at least, there is nothing subtle going on, so if that wasn't
the programmer's real intention, there is some chance that the problem can be spotted.
One may not always be so lucky. For example, casting <tt>Int</tt> to <tt>Float</tt>
can lose precision for the same reason that <tt>Int</tt> to <tt>Byte</tt> can, because
<tt>Float</tt> only has 23 bits (plus a sign bit) to hold the value.  It uses the
remaining 8 bits in its 32 bit word for the exponent.  So casting
<tt>23456789 as Float</tt> yields <tt>2.3456788E7</tt>.  Note carefully the
last digit.  If that last digit had some significance, you are in trouble-and
the problem is going to be <em>very</em> hard to see.
</blockquote>

<div class="p"><!----></div>
Thus, some of the implicit conversions above, like <tt>Int</tt> to <tt>Long</tt> 
are really coercions, while others, like <tt>Long</tt> to <tt>Float</tt>, are
really casts. Where a cast is what is at stake, X10 usually forces you to
be explicit: "<tt>Int i = someValue(); Byte b = i <em>as Byte</em>;</tt>".  The
explicit cast "<tt>as Byte</tt>" says you are prepared for the consequences of
the conversion.

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Signed versus unsigned</h3>
This section is largely an aside for Java programmers, because the distinction
between "signed"  and "unsigned" integers does not exist in Java and so may
not be familiar. What is at stake?

<div class="p"><!----></div>
From the dawn of computer history, CPUs have supported two kinds of arithmetic
instructions: one set in which one of the bits that make up the integer's value
is used to hold its sign, and a second set in which all integer values are
treated as non-negative.  Having the extra bit as part of the value doubles the
size of the largest positive integer you can express-something that was pretty
important when the normal machine "word" was 16 bits wide.  Today, with 64
bit words becoming the norm, the extra bit is not all that big a deal:
2<sup>63</sup>&#8722;1 is plenty big-how often will you really need 2<sup>64</sup>&#8722;1?

<div class="p"><!----></div>
When the Java standard was first developed, the designers
felt that, in their experience, exposing both types, as languages like C had done,
had been a source of more errors than the additional
power warranted.  Thus, unsigned values never made it into Java.  Well, they
made it back into X10. There <em>are</em> some arguments for having it, aside
from doubling the largest value, not the least:

<div class="p"><!----></div>
When you declare something to be "unsigned", you are telling the reader of
your code something:  negative values are neither expected nor welcome.
It is nice to have code that really says what you really mean.

<div class="p"><!----></div>
Another argument is that if you want to use a numeric type to represent one of
the 8-bit ISO character types- ISO-8859-1, which handles European
languages nearly completely-then <tt>UByte</tt> is a better match than <tt>
Byte</tt>.  Certainly, everyone <em>thinks</em> of the mapping from numbers to
characters as being a map from the integers 0, ..., 255 to characters. Also
with <tt>UByte</tt>, you can test for control characters with one inequality: they
are precisely those whose value as a <tt>UByte</tt> is less than <tt>0x20</tt>.
Similar considerations apply to multi-byte encodings of characters.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;String Theory</h2>

<div class="p"><!----></div>
X10 support for character-based applications is limited at the moment, but
with enough implemented to provide a base for applications that are not
fundamentally about manipulating character data.  Internationalization,
in particular, has only very limited support, and regular expressions have
not yet been implemented. What has been implemented will, with a few exceptions,
not surprise anyone coming from C++ or Java. The same can be said for file input
and output.

<div class="p"><!----></div>
The basic types for character work are <tt>x10.lang.Char</tt>, <tt>
x10.lang.String</tt>, and  <tt>x10.util.StringBuilder</tt>. Since <tt>StringBuilder</tt>
is in the package <tt>x10.util</tt>, it must be imported explicitly; the other two
need not be.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;<tt>Char</tt></h3> An instance is a 16-bit Unicode character.
<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a> Like <tt>Byte</tt> and <tt>Int</tt>, <tt>Char</tt> is a struct, but it
is <em>not</em> a numeric type: there is <em>no</em> implicit conversion to any
numeric type. The only explicit conversion to a numeric type is the method <tt>
ord</tt> that returns an <tt>Int</tt>:

<pre>&nbsp;&nbsp;&nbsp;'a'.ord()&nbsp;==&nbsp;0x61
</pre>
will evaluate to to <tt>true</tt>. You <em>can</em> cast integer values to characters

<pre>&nbsp;
&nbsp;&nbsp;&nbsp;i:&nbsp;Int&nbsp;=&nbsp;...;
&nbsp;&nbsp;&nbsp;c:&nbsp;Char&nbsp;=&nbsp;i&nbsp;as&nbsp;Char;
</pre>
does what you expect: produces the <tt>Char</tt> whose "<tt>ord</tt>" is <tt>i</tt>.  

<div class="p"><!----></div>
Programmers used to avoiding calls to  <tt>isdigit</tt> by writing 
<tt>'0' &lt;=c <br /></td><td width="150">
<br /></td><td width="150">
 c &lt;= '9'</tt> will find that the compiler
complains that you cannot compare integers and characters.  (This will probably be
fixed in an upcoming release of X10).  For now, when you
are writing X10, call <tt>isDigit</tt>, <tt>isLowerCase</tt>, <tt>isSpaceChar</tt>,
and so on.   All of these utilities are identical in function with their
counterparts that have been around since the birth of C. 


<div class="p"><!----></div>
A Unicode character can be written as an escape sequence
\<tt>u<em>nnnn</em></tt>, in which each of the <tt>n</tt>'s is a hex digit. 
As usual, the following escape sequences may be used:

<blockquote>
 <tt>\b == \u0008</tt>: backspace BS<br />
 <tt>\t == \u0009</tt>: horizontal tab HT<br />
 <tt>\n == \u000a</tt>: linefeed LF<br />
 <tt>\f == \u000c</tt>: form feed FF<br />
 <tt>\r == \u000d</tt>: carriage return CR<br />
 <tt>\" == \u0022</tt>: double quote "<br />
 <tt>\' == \u0027</tt>: single quote '<br />
 <tt>\\ == \u005c</tt>: backslash           
</blockquote>

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;<tt>String</tt></h3>

<div class="p"><!----></div>
A <tt>String</tt> is an <em>immutable</em> array of <tt>Char</tt>s.  Immutability means
that, for example, once you declare

<pre>&nbsp;&nbsp;&nbsp;&nbsp;s:&nbsp;String&nbsp;=&nbsp;"hi";
</pre>
you can, if you wish, access the first character in <tt>s</tt> as <tt>s(0)</tt>, but
you <em>cannot</em> reassign via "<tt>s(0) = 'o';</tt>".

<div class="p"><!----></div>
String literals are delimited by "double quotes," as in <tt>"begin,end"</tt>. 
The same escapes apply within <tt>String</tt> literals as for <tt>Char</tt> literals.

<div class="p"><!----></div>
Any object, be it from a class or struct, is converted to a <tt>String</tt> by
calling its method <tt>toString()</tt>, and there is always a default implemention
that is provided which does something sensible.  You are free, of course, to
provide your own implementation in the classes and structs you create.  For
example:

<pre>
&nbsp;1&nbsp;public&nbsp;class&nbsp;Cast&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1)):&nbsp;Void&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("I&nbsp;am&nbsp;a&nbsp;"+&nbsp;new&nbsp;Cast());
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;toString()&nbsp;{&nbsp;return&nbsp;"Cast&nbsp;of&nbsp;Thousands";&nbsp;}
&nbsp;6&nbsp;}
</pre>

<div class="p"><!----></div>
In line 3, the effect of the "<tt>+</tt>" operation is to concatenate the two
<tt>Strings</tt>.  When the code is run, the console output is:

<pre>
%x10&nbsp;Cast&nbsp;
I&nbsp;am&nbsp;a&nbsp;Cast&nbsp;of&nbsp;Thousands

</pre>

<div class="p"><!----></div>
There are some basic methods already implemented for <tt>String</tt>s, and over
time more will be added.  To explode a string into an array of characters
or bytes, use <tt>chars()</tt> or <tt>bytes()</tt>.  For example:

<pre>&nbsp;1&nbsp;public&nbsp;class&nbsp;GG&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1)):&nbsp;Void&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;s:&nbsp;String&nbsp;=&nbsp;"greed&nbsp;is&nbsp;good";
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;sa&nbsp;=&nbsp;s.chars();
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sa(4)&nbsp;=&nbsp;'k';
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;newS&nbsp;=&nbsp;new&nbsp;String(sa,&nbsp;0,&nbsp;s.length());
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("The&nbsp;new&nbsp;s&nbsp;is&nbsp;'"+newS+"'");
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;9&nbsp;&nbsp;}
</pre>
Here's the console output:

<pre>%x10&nbsp;GG
The&nbsp;new&nbsp;s&nbsp;is&nbsp;'greek&nbsp;is&nbsp;good'
</pre>

<div class="p"><!----></div>
Be careful calling <tt>bytes()</tt> if you are working with multi-byte characters:
it discards all but the trailing 8 bits of each character, a bug that will be
fixed eventually.

<div class="p"><!----></div>
There are four methods for extracting substrings:

<blockquote><tt>substring(from:Int)</tt><br />
<tt>substring(from:Int, to:Int)</tt><br /><tt>trim()</tt><br /><tt>split(s: String)</tt>
</blockquote>
The first argument for both versions of <tt>substring</tt> is the index
of the first character to keep, and the second argument, if it is supplied,
is one beyond the last character to keep. For instance, if we have <tt>val s =
"misguided"</tt>, then both <tt>s.substring(3)</tt> and <tt>
s.substring(3,s.length())</tt> will be <tt>"guided"</tt>.

<div class="p"><!----></div>
If you just want to get rid of leading and trailing white-space, the method
<tt>trim()</tt> is what you want.  Or if you need to break up a comma-separated
list, or something like that, use the <tt>split()</tt> method:

<pre>&nbsp;&nbsp;&nbsp;val&nbsp;s&nbsp;=&nbsp;"a,b,&nbsp;c,&nbsp;&nbsp;d";
&nbsp;&nbsp;&nbsp;val&nbsp;parts&nbsp;=&nbsp;s.split(",");

</pre>
yields an array of four substrings: <tt>&#228;", "b", " c"</tt> and <tt>"  d"</tt>.
The argument <tt>split</tt> is currently just a <tt>String</tt> in the C++ runtime
but is a regular expression in the Java runtime. 
Eventually, both will accept a regular expression, which will make it
easier to clean up the white-space while throwing out the commas.

<div class="p"><!----></div>
There are also four approaches to comparing <tt>String</tt>s. Let <tt>s</tt> and <tt>
t</tt> be two <tt>String</tt>s:

<blockquote>
<b>Equality as objects:</b>  <tt>s == t</tt> evaluates to true if <tt>s</tt> and
<tt>t</tt> name the same <tt>String</tt> object.  <tt>String</tt> is a class, not a
struct, <em>so what</em> <tt>s</tt> <em>names is a reference to a </em> <tt>String</tt>, not
a literal string value.

<div class="p"><!----></div>
<tt>s != t</tt> is true when <tt>s</tt> and <tt>t</tt> do <em>
not</em> name the same <tt>String</tt> object.

<div class="p"><!----></div>
<b>Equality as values: </b>  The expression <tt>s.equals(t)</tt> evaluates to 
true if the current values-that is, the contents of the underlying byte
arrays-of the two variables are the same.

<div class="p"><!----></div>
<b>Infix comparison operators: </b> The operators <tt>&lt;</tt>, <tt>&lt;=</tt>, <tt>
&#62;=</tt>, and <tt>&#62;</tt> compare two <tt>String</tt> values using lexicographic
(dictionary) order.   For example, <tt>"good"&lt"goof"</tt> will evaluate to <tt>
true</tt>, since <tt>d</tt> comes before <tt>f</tt>.

<div class="p"><!----></div>
<b>Comparison methods: </b> The method <tt>compareTo(s:String):Int</tt>
returns a signed integer that is

<blockquote>
<em>negative</em> if <tt>s &lt; t</tt>,<br />
0 if <tt>s.equals(t)</tt>, and <br />
<em>positive</em> if <tt>s &#62; t</tt>
</blockquote>
The method <tt>compareToIgnoreCase(s:String):Int</tt> can be used if
you need comparisons that are <em>not</em> case-sensitive.
</blockquote>

<div class="p"><!----></div>
Searching <tt>String</tt>s can be done with the methods <tt>indexOf</tt>, <tt>
lastIndexOf</tt>, <tt>startsWith</tt>, and <tt>endsWith</tt>.  The last two take a
<tt>String</tt> as argument, and the first three take as a first argument either a <tt>
Char</tt> or a <tt>String</tt>, with an optional second argument that is the index in
the <tt>String</tt> where the search is to begin.

<div class="p"><!----></div>
For those with fond memories of C's <tt>printf</tt> or Java's <tt>format</tt>, X10
gives you

<pre>
format(fmt:String,&nbsp;args:Array[Any]):String

</pre> whose first
argument is a format string like those of its C and Java ancestors, and whose
second argument is the array of whatever is to be formatted.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>  For example, executing

<pre>
s&nbsp;=&nbsp;String.format("%s&nbsp;%d&nbsp;%s&nbsp;%f",&nbsp;["int",&nbsp;32,&nbsp;"dbl",3.2]);

</pre>
leaves <tt>s</tt> with the value <tt>&#239;nt 32 dbl 3.200000"</tt>.

<div class="p"><!----></div>
Support for the formatting options is limited at the moment, but most
simple cases work as they have done since <tt>printf</tt> was introduced some
thirty years ago.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;<tt>StringBuilder</tt></h3> One often has to build up a string whose
length is not known in advance and which isn't short enough that it makes
sense to just build it up as a concatenation <tt>a+b+c+...</tt>. 
That is the job of <tt>x10.util.StringBuilder</tt>. We remind you that you have to
import this class, like all others in the <tt>x10.util</tt> package.  For
practical purposes, a <tt>StringBuilder</tt> has two methods: <tt>add(a: Any)</tt> and
<tt>result()</tt>.  The method <tt>add</tt> uses its argument's <tt>toString</tt> method
to compute the <tt>String</tt> to append, and <tt>result</tt> simply returns the <tt>
String</tt> you have been accumulating. Here's an example of how one uses a <tt>
StringBuilder</tt>:

<pre>
val&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuilder();
sb.add(2);
sb.add("&nbsp;and&nbsp;");
sb.add(3);
sb.add("&nbsp;is&nbsp;"+5);
val&nbsp;s&nbsp;=&nbsp;sb.result();

</pre>
The value of <tt>s</tt> will be <tt>"2 and 3 is 5"</tt>.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Files</h2><a name="sec:files">
</a>
The basic drill for reading and writing files is to get hold of a <tt>File</tt>
object, and use it to get a stream either inbound or outbound.  Let's start
simply with the program in figure .

<div class="p"><!----></div>
<a name="tth_fIg1">
</a> <hr />

<pre>&nbsp;1&nbsp;import&nbsp;x10.io.File;
&nbsp;2&nbsp;
&nbsp;3&nbsp;public&nbsp;class&nbsp;FileIO&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inputPath&nbsp;&nbsp;=&nbsp;args(0);
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;outputPath&nbsp;=&nbsp;args(1);
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;I&nbsp;=&nbsp;new&nbsp;File(inputPath);
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;O&nbsp;=&nbsp;new&nbsp;File(outputPath);
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;P&nbsp;=&nbsp;O.printer();
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(line&nbsp;in&nbsp;I.lines())&nbsp;{
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P.print(line);
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P.flush();
14&nbsp;&nbsp;&nbsp;&nbsp;}
15&nbsp;}
</pre>
 
<center>Figure 1: A simple line-reader file copy program,
 <a href="http://dist.codehaus.org/x10/documentation/guide/src/files/FileIO.x10">files/FileIO.x10</a></center><a name="fig:flc">
</a>
 <hr />


<div class="p"><!----></div>
The fun begins with line 7.

<dl compact="compact">
 <dt><b>lines 7 and 8:</b></dt>
	<dd> Executing "<tt>I = new File(inputPath)</tt>" converts
a file-system path into an object that represents
the corresponding file. That file may be either a directory or an ordinary file.
The constructor for <tt>File</tt> does not check whether there exists a file
corresponding to the path.  It will create the file, if need be, when it is
opened for writing and does not yet exist.

<div class="p"><!----></div>
The <tt>File</tt> class has methods that allow you to do various administrative
tasks, like getting the absolute path. It also has methods for creating readers and writers, but more
commonly, you will wind up using an instance of <tt>File</tt> as an argument to a
constructor that builds an input or output stream with some desirable
properties like buffering.</dd>
 <dt><b>line 9:</b></dt>
	<dd> The call <tt>O.printer()</tt> returns an instance of the class <tt>
Printer</tt>.  This is the class to which the familiar <tt>Console</tt> streams <tt>
OUT</tt> and <tt>ERR</tt> belong.  You have seen the <tt>println</tt> method in action
already, and <tt>print</tt>, which we use here, is the same, but does not append
a new-line. <tt>Print</tt> also has a <tt>printf</tt> method that is X10's take on
the familiar C function, but where the data to be formatted is most
efficiently passed as an <tt>Array</tt>, although if you have 6 or fewer items
to format, you can just string them out, C-style, as extra arguments.

<div class="p"><!----></div>
When the <tt>Printer P</tt> is created, the file to which <tt>P</tt> refers is opened for
writing and is created if need be.  If the file exists already, its contents are
discarded.</dd>
 <dt><b>line 10:</b></dt>
	<dd>  This is our first example of a <tt>for</tt> loop that is tied to
the "<tt>Iterator</tt>" interface.  An <tt>Iterator</tt> is always associated with
some underlying collection.  In our example, <tt>I.lines()</tt> is the <tt>
Iterator</tt>, and its collection consists of the lines in the input file. The
interface requires two methods:

<blockquote>
<tt><b>next():</b></tt> returns the next element, as yet unseen, from the
collection. 

<div class="p"><!----></div>
<tt><b>hasNext():</b></tt> returns a <tt>Boolean</tt>, the return value
being "true" if a call to <tt>next()</tt> at this point will succeed.
</blockquote>
Written in terms of the <tt>Iterator</tt>, the <tt>for</tt> loop would look like

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;lines&nbsp;=&nbsp;I.lines();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(lines.hasNext())&nbsp;P.print(lines.next());
</pre>
While there is some chance that a smart implementation might generate better
code for the <tt>for</tt> loop for some <tt>Iterators</tt>, one should view it more as
a concise, readable way of writing the loop.</dd>
 <dt><b>line 13:</b></dt>
	<dd> We call <tt>flush()</tt> to make sure that, in case the <tt>
Printer</tt> has been buffering our output, all of it gets sent <em>now</em>.  Do not
count on the output stream being flushed when the program terminates-even when
it terminates normally. Better safe than sorry here.</dd>
</dl>

<div class="p"><!----></div>
If you compile <tt>FileIO.x10</tt> and then execute

<blockquote>

<pre>
%x10&nbsp;FileIO&nbsp;FileIO.x10&nbsp;out.put

</pre>
</blockquote>
in the same directory as <tt>FileIO.x10</tt>, you should find that <tt>out.put</tt>
is a copy of <tt>FileIO.x10</tt>.

<div class="p"><!----></div>
This example is fine for text files.  Our next examples
 are two classes that show how to read and write a binary file.  

<div class="p"><!----></div>
Let's look at the writer first, because we need it to generate input for the
reader.

<pre>
&nbsp;1&nbsp;public&nbsp;class&nbsp;WriteDBL&nbsp;{&nbsp;//&nbsp;see&nbsp;the&nbsp;file&nbsp;files/WriteDBL.x10
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;I&nbsp;&nbsp;=&nbsp;new&nbsp;File(args(0));
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;W&nbsp;&nbsp;=&nbsp;new&nbsp;FileWriter(I);
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;line&nbsp;=&nbsp;Console.IN.readLine().trim();
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(line.length()&nbsp;==&nbsp;0)&nbsp;break;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;dbl&nbsp;=&nbsp;Double.parse(line);
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W.writeDouble(dbl);
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W.close();
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
13&nbsp;&nbsp;}

</pre>
We've skipped the imports here-by now, you know what's needed there, and the
working file is available in
<a href="http://dist.codehaus.org/x10/documentation/guide/src/files/WriteDBL.x10">files/WriteDBL.x10</a>.

<dl compact="compact">
 <dt><b>line 4:</b></dt>
	<dd> We use the class <tt>x10.io.FileWriter</tt> to stream the output. 
It has methods like <tt>writeInt</tt>, <tt>writeFloat</tt>, and so on, that allow you
to write binary data easily out to a file.  In this example, we are going to use
<tt>writeDouble</tt>.

<div class="p"><!----></div>
As when creates a new <tt>Printer</tt>, creating the new <tt>FileWriter</tt> creates
the new file if need be, or if it already exists, discards all of its contents.</dd>
 <dt><b>line 5:</b></dt>
	<dd> The keyword <tt>while</tt> introduces a loop.  The loop's syntax is
<tt>while(<em>booleanExpression</em>) <em>statement</em></tt>.  The expression is
called the <em>loop's test</em>, and the statement is the <em>loop's body</em>. 
When execution reaches the test, it is evaluated, and if the true,
the body is executed. This sequence-check the test, execute the
body-is continued until the test fails:  evaluates to "false".
Execution then passes to the code that immediately follows the body.

<div class="p"><!----></div>
In our example, the test is <em>always</em> true, so the loop is 
terminated from within its body, by the <tt>break</tt> statement on line 7.</dd>
 <dt><b>lines 6-7:</b></dt>
	<dd> We read a line of ordinary text from the standard input
stream and trim any white-space characters from the beginning and end of the
line.  If the line is now empty, we break out of the loop.  The statement "<tt>
break;</tt>" causes execution to continue at the first statement following the
loop's body.</dd>
 <dt><b>lines 8-9:</b></dt>
	<dd> The input line is converted to a <tt>Double</tt>, and that
value is written, bit-for-bit, to the output file.</dd>
 <dt><b>line 11:</b></dt>
	<dd> We explicitly close the stream here.  This should guarantee that
any output that has been buffered, but not yet actually written out, does get
written.</dd>
</dl>
We compiled our <tt>WriteDBL.x10</tt> and ran it to create a file for the reader to
read:

<pre>%&nbsp;x10&nbsp;WriteDBL&nbsp;dbl.out
1.2
2.3
3.4
5.678

%

</pre>
Now its the reader's turn.  

<pre>&nbsp;1&nbsp;public&nbsp;class&nbsp;ReadDBL&nbsp;{&nbsp;//&nbsp;see&nbsp;the&nbsp;file&nbsp;files/ReadDBL.x10
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inputPath&nbsp;&nbsp;=&nbsp;args(0);
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;I&nbsp;&nbsp;=&nbsp;new&nbsp;File(inputPath);
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;R&nbsp;&nbsp;=&nbsp;new&nbsp;FileReader(I);
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)&nbsp;{
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println(R.readDouble());
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
10&nbsp;&nbsp;}
</pre>
The working copy is in
<a href="http://dist.codehaus.org/x10/documentation/guide/src/files/ReadDBL.x10">files/ReadDBL.x10</a>.
You can see that it is almost line-for-line the same
as the writer-no surprise, really.  The one thing that is different is
figuring out how to terminate the <tt>while</tt> loop in lines 6-8.  The problem is
that <tt>FileReader</tt> does not offer a method for testing when we are at the end
of a stream.  You might think, therefore, that <tt>readDouble</tt> might return a
nonsense value on end-of-stream, so we could test for that.  It does not.  To
see what's going on, look at the console log we got by running the code shown
with input from the file <tt>dbl.out</tt> that we just created:

<pre>%x10&nbsp;ReadDBL&nbsp;dbl.out
1.2
2.3
3.4
5.678
x10.io.EOFException
&nbsp;&nbsp;&nbsp;at&nbsp;x10.io.InputStreamReader.read(InputStreamReader.java:73)
&nbsp;&nbsp;&nbsp;at&nbsp;x10.io.Marshal$LongMarshal.read(Marshal.java:877)
&nbsp;&nbsp;&nbsp;at&nbsp;x10.io.Marshal$DoubleMarshal.read(Marshal.java:1057)
&nbsp;&nbsp;&nbsp;at&nbsp;x10.io.Reader.readDouble(Reader.java:164)
&nbsp;&nbsp;&nbsp;at&nbsp;ReadDBL.main(ReadDBL.java:107)
&nbsp;&nbsp;&nbsp;...
</pre>
We read the file and got just the output we would have expected, and the first
attempt to read beyond the data we provided caused an "end-of-file exception".
Which brings us to our next topic: exceptions.

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Exceptions</h2><a name="sec:exc">
</a>
An exception in programming, as in life, is literally an event out of the
ordinary.  Being out of the ordinary, exceptions are a rarity. If they
happened frequently, they would be part of the rule, and not an exception.
In programming, an exception is a way of performing an <em>abnormal return</em>
from a method call. 

<blockquote>
An abnormal return is one where the called routine cannot sensibly return a
value to its caller (or simply return to its caller if no return value is at
stake) because some situation, usually something terribly wrong, has arisen
that the caller may not have enough context to handle.  Often, that context is
only available to a method that is many steps earlier in the call chain.  The
problem is to get control efficiently to where it can be exercised effectively,
without unduly penalizing the "normal", exception-free paths through the code.
</blockquote>

<div class="p"><!----></div>
Instead of each method in the call chain having to look at the
problem and then having to admit that it doesn't know what to do
about it, we force a method that thinks it <em>can</em> handle it to say so. The
construct needed is called a <tt>try</tt> statement.  If you're not familiar with
it, no problem: we'll describe it in detail in a moment.  The important thing
for now is that not every method need take responsibility for every sort of
problem that might happen while it, or something it calls, is executing.

<div class="p"><!----></div>
When running <tt>FileIO.main</tt> for example, the attempts to read and write the
files <em>could</em> fail, but how often does that really happen? Almost never.
If our <tt>main</tt> really wanted to deal with the
error, it could put the code inside a <tt>try</tt> statement that says it is
willing to deal this exception-we'll show the more cautious code in a
moment.

<div class="p"><!----></div>
The lingo of the trade is that exceptions are either "thrown" or "raised." 
X10 belongs to the "throw" camp.  The methods that want to handle an
exception are said to "catch" it.
To say that an X10 method "throws an exception" means that execution
reaches an X10 <tt>throw</tt> statement, which looks like:

<blockquote>
<tt>throw new <em>ExceptionSubclass</em>(<em>explanation</em>);</tt>
</blockquote>
For example, if a file open failed because an incorrect path was provided, you
might see

<pre>
&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;x10.io.FileNotFoundException("Bad&nbsp;path&nbsp;'"+path+"'");

</pre>
What happens when this statement is executed is that an instance of the
class being thrown, <tt>x10.io.FileNotFoundException</tt> in our example,
is constructed.  The class whose name appears in the <tt>throw</tt> must be a
subclass of <tt>x10.lang.Exception</tt><a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>.
The newly created instance has a field that holds the argument <tt><em>
explanation</em></tt> in the constructor.  The catcher can retrieve it by calling the
method <tt>getMessage()</tt>.  The X10 run-time manager will also provide the
instance with the call chain at the point of the "throw", which can be
retrieved (as an array of <tt>Strings</tt>, one for each method in the call chain)
by calling the method <tt>getStackTrace()</tt>.  The X10 run-time manager will
then look back up that call chain until a method is found that says that it
wants to handle any exception whose type is a
subclass of the type named in the <tt>throw</tt>.  Control is returned to that
method at an appropriate point-we'll see where in our next example:

<div class="p"><!----></div>
Let's rewrite our <tt>ReadDbl.main</tt> so that it handles all its I/O
problems gracefully (see
<a href="http://dist.codehaus.org/x10/documentation/guide/src/files/ReadDBL2.x10">files/ReadDBL2.x10</a>).

<pre>&nbsp;1&nbsp;&nbsp;public&nbsp;class&nbsp;ReadDBL2&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inputPath&nbsp;&nbsp;=&nbsp;args(0);
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;I&nbsp;&nbsp;=&nbsp;new&nbsp;File(inputPath);
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;r:&nbsp;FileReader&nbsp;=&nbsp;null;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;new&nbsp;FileReader(I);
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true)&nbsp;{
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println(r.readDouble());
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch(eof:&nbsp;x10.io.EOFException)&nbsp;{
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("Done!");
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch(ioe:&nbsp;x10.io.IOException)&nbsp;{
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.ERR.println(ioe);
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;!=&nbsp;null)&nbsp;r.close();
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
18&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
19&nbsp;}
</pre>

<div class="p"><!----></div>
Here's the line-by-line:

<dl compact="compact">
 <dt><b>line 5:</b></dt>
	<dd>  Our reader <tt>r</tt> is now a <tt>var</tt>, not a <tt>val</tt>, because
we are going to use it when we reach line 16, and we cannot be sure that the
assignment in line 7 will succeed.  Remember, a mistyped input file path will
cause the constructor to throw an exception-an
<tt>x10.io.FileNotFoundException</tt> in fact, which happens to be a
subclass of <tt>x10.io.IOException</tt>.  So the assignment in line 7 may be
aborted.</dd>
 <dt><b>line 6:</b></dt>
	<dd> This is the beginning of the <tt>try</tt> statement, the "try block".
The brace following the keyword <tt>try</tt> is required.  The catch blocks in
lines 11 and 13 describe the types of exceptions that this <tt>try</tt> statement
promises to handle.  For example, if the assignment in line 7 does <em>not</em>
complete normally, the exception thrown will be an <tt>
x10.io.IOException</tt>, which will cause control to go to line 14, the body of
the catch block that promises to handle <tt>x10.io.IOExceptions</tt>.</dd>
 <dt><b>lines 8-10:</b></dt>
	<dd> The <tt>while</tt> loop is unchanged.  It goes its merry way
until the end of file exception is thrown, but now, since there is a catcher at
line 11, control will go to line 12 when the exception is thrown.</dd>
 <dt><b>line 11:</b></dt>
	<dd> The try block is ended by the closing brace, "<tt>}</tt>". 
What follows is a catch block, which, in English, says: "if an exception
was thrown in the try block that is an <tt>x10.io.EOFException</tt>, or is in a
subclass of <tt>x10.io.EOFException</tt>, then return control to my body,
namely, the statement bracketed by my braces.  Set the identifier <tt>eof</tt> 
to the object that was thrown."  At end-of-file, we don't care about the <tt>
eof</tt>'s message or the call-chain traceback, so we simply ignore <tt>eof</tt>. 
We're just done!

<div class="p"><!----></div>
All that remains, once the <tt>println</tt> completes, is to be polite and
close up the <tt>FileReader r</tt>.  Because there is a "finally block" at line
15, control goes to its body, and the close is done there.  Control then falls
through to whatever statement (if any) comes next.  If there had been no finally block,
then once the body of the catch block had been executed, control would have
passed to the first statement following the <em>last</em> catch block.</dd>
 <dt><b>line 13:</b></dt>
	<dd> Here we have a second catch block, one that is intended to
catch errors.  When you have several catch blocks, they behave like "<tt>
if... else if ... else if ...</tt>" sequences: the first one that can do
the job is the one that the run-time picks: later blocks are ignored.  <em>
This is very important:</em>

<blockquote>
If we had put the <tt>IOException</tt> block <em>first</em>, then, because <tt>
EOFException</tt> is a subclass of <tt>IOException</tt>, the
<tt>IOException</tt> block would
get control on end-of-file as well as whenever an error occurred.  This is
definitely not what we want, and this can be a pernicious error, because it is
not always obvious what classes are subclasses of what other classes.  This
is why, if we had reversed the order of our catch blocks, the compiler
would have signalled it as an error: "<tt>Unreachable catch block for
EOFException. It is already handled by the catch block for IOException</tt>".  Try
compiling 
<a href="http://dist.codehaus.org/x10/documentation/guide/src/files/ReadDBL3.x10">files/ReadDBL3.x10</a>
to see this in action.
</blockquote></dd>
 <dt><b>line 15: </b></dt>
	<dd> The statement following the keyword <tt>finally</tt> will be
executed whether or not the try block terminates without throwing an exception.
The <tt>finally</tt> block will be excuted even if an exception was thrown that is
<em>not</em> one we have a catcher for in this try statement. One of the catch
blocks may be executed before the entering the <tt>finally</tt>, if there is a
catcher for the error that occurred, but no matter what, control will
reach the <tt>finally</tt> before leaving the method.

<div class="p"><!----></div>
That is why we had to be careful to provide an initial value for <tt>r</tt>: if the
constructor in line 7 aborted, control would have gone to the second catch block,
and when it completed, control would wind up in the "finally" at line 16.
Because we were careful to initialize <tt>r</tt> in line 5, we are on safe ground
accessing its value here, no matter how we got here.  Actually, the compiler
would have complained if <tt>r</tt> had <em>not</em> been set along some path that
starts at its declaration and reaches its use in line 16.  It is an error in
X10 for code to read an identifier's value before the identifier has been
initialized.</dd>
</dl>

<div class="p"><!----></div>
A <tt>try</tt> statement may have a <tt>finally</tt> but no <tt>catch</tt> blocks: no
matter what exception occurs, the <tt>finally</tt>'s statement will get executed. 
The reason is exactly the sort of thing we saw in this example: if you have
acquired some resource and need to release it, putting the release
in a <tt>finally</tt> guarantees that it happens. A <tt>try</tt> statement
need have no <tt>finally</tt> block. In that case, when the body of the try block
completes, control goes to the first statement that follows the last of its
catch blocks.

  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Functions</h2>

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Function Types</h3>
We have already seen examples of how one can create functions in X10 and
pass them as arguments.  Indeed, functions are values like any other from the
point of view of assigning them, passing them around as arguments, and so on. 
As a "type", though, they form a distinct unit, being neither class, struct,
nor interface.

<div class="p"><!----></div>
The basic syntax for function <em>types</em>-as opposed to
the syntax for specific method or closure definitions-is:

<blockquote>
<tt>(<em>arg1Type, arg2Type, ...</em>) =&#62; <em>returnType</em></tt>
</blockquote>
For example, we could declare

<pre>&nbsp;var&nbsp;doSum:&nbsp;(Array[Double](1))&nbsp;=&#62;&nbsp;Double;
</pre>
The value of <tt>doSum</tt>, when it is assigned, will be a function that
takes a single argument, of type a singly-indexed array of <tt>Doubles</tt>, and
returns a value of type <tt>Double</tt>.  If it was helpful for people reading the
declaration to have a name for the argument, you can supply one:

<pre>&nbsp;var&nbsp;doSum:&nbsp;(a:&nbsp;Array[Double](1))&nbsp;=&#62;&nbsp;Double;
</pre>
Here it is not very useful, but there obviously are a lot of situations where
the argument types by themselves do not reveal your intent.

<div class="p"><!----></div>
The argument list for a function type may be empty, as it was for our random
number generator in the Monte Carlo calculation in .

<div class="p"><!----></div>
Getting back to <tt>doSum</tt>, we know that, being a <tt>var</tt>, it can be set (and
reset!) whenever we wish. It would be polite, however, to assign an initial
value in the declaration that, if nothing like what we eventually want, at least
would betray an attempt to use <tt>doSum</tt> before it was properly set.
For example, we could set it to <tt>null</tt>, but that is pretty drastic.
A better solution would be to just let it always return "not a number!": 

<pre>&nbsp;var&nbsp;doSum:&nbsp;(Array[Double](1))&nbsp;=&#62;&nbsp;Double
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(a:&nbsp;Array[Double](1))&nbsp;=&#62;&nbsp;Double.NaN;

</pre>
or to let it throw an exception:

<pre>&nbsp;var&nbsp;doSum:&nbsp;(Array[Double](1))&nbsp;=&#62;&nbsp;Double
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;(a:&nbsp;Array[Double](1)):&nbsp;Double&nbsp;=&#62;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;msg&nbsp;=&nbsp;"doSum&nbsp;called&nbsp;before&nbsp;being&nbsp;set.";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalOperationException(msg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

</pre>
These two examples show the two patterns for creating function "values".
One is exemplified the right-hand side of the first assignment, in which
the arrow "&#62;" is followed by an expression that is the return value of
the function.  The other possibility is to write out the function body in the
usual statement form, bracketed by braces, which is what we did to throw the
exception.  When you use this format for the function body and want to return a
value, you need to use a <tt>return</tt> statement to do so.

<div class="p"><!----></div>
Notice the semicolon following the body of the function value: what we have here
is an assignment, not a method definition, so it expects to be terminated with
a semicolon.  

<div class="p"><!----></div>
The bottom line is that the syntax for function literals is the same as that for
function types, except that for a literal, the body follows the arrow rather
than (as for types) the return type. You <em>can</em> specify
the return type for a function literal explicitly if you absolutely need to.
Just append <tt>:<em>returnType</em></tt> to the argument list.  For example, we could
have written <tt>doSum = (a: Array[Double](1)):Double =&#62; {...}</tt> if we felt
we had to say explicitly that it returned a <tt>Double</tt>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;A Few Words On Arguments</h3>
Consider the following attempt to pass some <tt>Int</tt> arguments into a method.

<pre>
&nbsp;1&nbsp;public&nbsp;class&nbsp;TryArgs&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;tryargs(val&nbsp;a:&nbsp;Int,&nbsp;b:&nbsp;Int,&nbsp;var&nbsp;c:&nbsp;Int)&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b&nbsp;=&nbsp;c&nbsp;=&nbsp;1;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1)):&nbsp;Void&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;a:&nbsp;Int&nbsp;=&nbsp;0,&nbsp;b:&nbsp;Int&nbsp;=&nbsp;0,&nbsp;c:&nbsp;Int&nbsp;=&nbsp;0;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tryargs(a,b,c);
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("a&nbsp;=&nbsp;"+a+",&nbsp;b&nbsp;=&nbsp;"+b+",&nbsp;c&nbsp;=&nbsp;"+c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;}
10&nbsp;}
</pre>
When you compile it<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>, the compiler will generate error messages:

<pre>
%&nbsp;x10c&nbsp;&nbsp;TryArgs.x10
TryArgs.x10:3:&nbsp;Final&nbsp;variable&nbsp;"b"&nbsp;might&nbsp;already&nbsp;have&nbsp;been
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialized
TryArgs.x10:3:&nbsp;Final&nbsp;variable&nbsp;"a"&nbsp;might&nbsp;already&nbsp;have&nbsp;been
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialized
</pre>
The complaint about attempting to reset "<tt>a</tt>" after you declared it to be a
<tt>val</tt> is what you would expect.  The complaint about "<tt>b</tt>" is less
obvious, but now you know: unless you say that an argument is a <tt>var</tt>, it is
going to be a <tt>val</tt>.

<div class="p"><!----></div>
The next obvious thing to try is 
<a href="http://dist.codehaus.org/x10/documentation/guide/src/fcns/TryArgs2.x10">fcns/TryArgs2.x10</a>: 

<pre>
public&nbsp;class&nbsp;TryArgs2&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;tryargs(var&nbsp;c:&nbsp;Int)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.print("In&nbsp;tryargs,&nbsp;c&nbsp;is&nbsp;"+c);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1)):&nbsp;Void&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c:&nbsp;Int&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tryargs(c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println(".&nbsp;&nbsp;In&nbsp;main,&nbsp;c&nbsp;is&nbsp;"+c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;}
}
</pre>
We compile and run, and the console shows:

<pre>\%&nbsp;x10&nbsp;TryArgs2
In&nbsp;tryargs,&nbsp;c&nbsp;is&nbsp;1.&nbsp;&nbsp;In&nbsp;main,&nbsp;c&nbsp;is&nbsp;0

</pre>
So inside the method <tt>tryargs</tt>, we are clearly working with a copy of <tt>
c</tt>, not the original.  In this respect, X10 is behaving just the way
Java and C++ do.  Maybe this had something to do with <tt>Int</tt> being a struct,
so let's try
<a href="http://dist.codehaus.org/x10/documentation/guide/src/fcns/TryArgs3.x10">fcns/TryArgs3.x10</a>:

<pre>
public&nbsp;class&nbsp;TryArgs3&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;var&nbsp;value:&nbsp;Int;
&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(n:&nbsp;Int)&nbsp;{&nbsp;value&nbsp;=&nbsp;n;&nbsp;}
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;tryargs(var&nbsp;c:&nbsp;TryArgs3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;new&nbsp;&nbsp;TryArgs3(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.print("In&nbsp;tryargs,&nbsp;c&nbsp;is&nbsp;"+c.value);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1)):&nbsp;Void&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c:&nbsp;TryArgs3&nbsp;=&nbsp;new&nbsp;TryArgs3(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tryargs(c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println(".&nbsp;&nbsp;In&nbsp;main,&nbsp;c&nbsp;is&nbsp;"+c.value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;}
}
</pre>
The result is still showing no change to <tt>main</tt>'s <tt>c</tt>.  

<pre>\%&nbsp;x10&nbsp;TryArgs3
In&nbsp;tryargs,&nbsp;c&nbsp;is&nbsp;1.&nbsp;&nbsp;In&nbsp;main,&nbsp;c&nbsp;is&nbsp;0
</pre>
So whether <tt>c</tt> was an instance of a struct or class does not matter: a copy
is made.  One final example,
<a href="http://dist.codehaus.org/x10/documentation/guide/src/fcns/TryArgs4.x10">fcns/TryArgs4.x10</a>:

<pre>
public&nbsp;class&nbsp;TryArgs4&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;var&nbsp;value:&nbsp;Int;
&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(n:&nbsp;Int)&nbsp;{&nbsp;value&nbsp;=&nbsp;n;&nbsp;}
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;tryargs(c:&nbsp;TryArgs4)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.value&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.print("In&nbsp;tryargs,&nbsp;c&nbsp;is&nbsp;"+c.value);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1)):&nbsp;Void&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c:&nbsp;TryArgs4&nbsp;=&nbsp;new&nbsp;TryArgs4(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tryargs(c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println(".&nbsp;&nbsp;In&nbsp;main,&nbsp;c&nbsp;is&nbsp;"+c.value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;}
}
</pre>
Being an instance of a class, <tt>c</tt>'s value is a reference to
its data.  It is the reference which is copied into <tt>tryargs</tt>.
<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a> <tt>tryargs</tt> can
then use that reference to change what is stored in <tt>c.value</tt>, but it cannot change
what the original <tt>c</tt> referenced. What we see on the console when we
run <tt>TryArgs4</tt> is:

<pre>
%&nbsp;x10&nbsp;TryArgs4
In&nbsp;tryargs,&nbsp;c&nbsp;is&nbsp;1.&nbsp;&nbsp;In&nbsp;main,&nbsp;c&nbsp;is&nbsp;1

</pre>
For the first time, the values are the same.

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Creating Functions Dynamically</h3>

<div class="p"><!----></div>
We have already seen in  that when you build a function at
run-time, you can take advantage of at least some of the identifiers visible to
you in implementing the body of the function.  Here's the code we had there:
 
<pre>
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random();
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;()&nbsp;=&#62;&nbsp;r.nextDouble();
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inCircle&nbsp;=&nbsp;countPoints(N,&nbsp;&nbsp;rand);
&nbsp;
</pre>
You'll recall that this code sat inside a loop, so every time through the loop,
executing line 2 gave us a new value of <tt>r</tt> to use with which to build a new
function to assign to <tt>rand</tt>.

<div class="p"><!----></div>
The question is: what identifiers from the surrounding context are allowed in
the body of a function literal (or as it is more usually called, a "closure")
like <tt>rand</tt>?

<div class="p"><!----></div>
The bad news is that you cannot use any of the method's <em>local</em> identifiers
that are declared to be <tt>vars</tt>.  The good news is that anything else goes.
Any identifier that is a <tt>val</tt> or is <tt>static</tt>
can be used. If the closure is being declared <em>inside an instance
method</em>, then any instance member <tt>this.x</tt> (field or method) of the class
may appear in the literal's body. This is okay because, even if <tt>x</tt>
is a field that is a <tt>var</tt>, what is being captured by the closure is
the value of <tt>this</tt>, and <tt>this</tt> itself is a local <tt>val</tt> in the
instance method: you cannot assign a value to <tt>this</tt> itself in the body of
a method, you can only assign to the fields <tt>this</tt> references.

<div class="p"><!----></div>

<pre>&nbsp;1&nbsp;public&nbsp;class&nbsp;IntRange&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;low:&nbsp;Int;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;high:&nbsp;Int;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(low:&nbsp;Int,&nbsp;high:&nbsp;Int)&nbsp;{
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.low&nbsp;=&nbsp;low;&nbsp;this.high&nbsp;=&nbsp;high;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;includes(n:Int)&nbsp;=&nbsp;low&nbsp;&lt;=&nbsp;n&nbsp;\&amp;\&amp;&nbsp;n&nbsp;&lt;=&nbsp;high;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;isDigitFcn()&nbsp;{
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;digit&nbsp;=&nbsp;new&nbsp;IntRange(0,9);
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(n:&nbsp;Int)&nbsp;=&#62;&nbsp;digit.includes(n);
11&nbsp;&nbsp;&nbsp;&nbsp;}
12&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;inMeTester()&nbsp;{
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(n:&nbsp;Int)&nbsp;=&#62;&nbsp;low&nbsp;&lt;=&nbsp;n&nbsp;\&amp;\&amp;&nbsp;n&nbsp;&lt;=&nbsp;high;
14&nbsp;&nbsp;&nbsp;&nbsp;}
15&nbsp;}

</pre>

<dl compact="compact">
 <dt><b>lines 2-3:</b></dt>
	<dd> Here we've got two instance members that define the range.
We made one of them a <tt>var</tt> to make a point later about accessing <tt>vars</tt>
in defining function literals.</dd>
 <dt><b>lines 8-10:</b></dt>
	<dd>  We can use an instance method to create a function.
First, we have to create an instance <tt>digit</tt>.  
Then <tt>digit.includes</tt> will be a function with one
<tt>Int</tt> argument that can be packaged so that when it is returned by
<tt>isDigitFcn</tt>, it is a function callable by anyone from anywhere.</dd>
 <dt><b>lines 12-14</b></dt>
	<dd>
 The instance method 
<tt>inMeTester</tt> takes advantage of using the instance members for "<tt>this</tt>" 
to create a function
anyone can use to test whether a given <tt>Int</tt> is in its range:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;hexDigitRange&nbsp;=&nbsp;new&nbsp;IntRange(0,&nbsp;15);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;isHD&nbsp;=&nbsp;hexDigitRange.inMeTester();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("7?&nbsp;"+isHD(7)+",&nbsp;21?&nbsp;"+isHD(21));

</pre>
You might be tempted to object that this violates the rule that no <tt>vars</tt> 
may be accessed in the function body-<tt>high</tt> is, after all, a <tt>var</tt>.  
Remember, though, that in line 13, <tt>high</tt> is really just a shorthand for
<tt>this.high</tt>, <em>so it is really the (hidden) argument</em> <tt>this</tt> that is
being used in line 13, and as we've said, <tt>this</tt> is a <tt>val</tt>, which
means <tt>this</tt> itself <em>can</em> be used, and hence so can <tt>this.high</tt>.

<div class="p"><!----></div>
To see this class in action, compile and run 
<a href="http://dist.codehaus.org/x10/documentation/guide/src/fcns/IntRange.x10">fcns/IntRange.x10</a>:

<div class="p"><!----></div>
To see what won't work, let's add a method to our class <tt>IntRange</tt>:

<pre>&nbsp;&nbsp;&nbsp;static&nbsp;def&nbsp;wontWork(var&nbsp;k:&nbsp;Int)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(n:&nbsp;Int)&nbsp;=&#62;&nbsp;k*low&nbsp;&lt;=&nbsp;n&nbsp;\&amp;\&amp;&nbsp;n&nbsp;&lt;=&nbsp;k*high;
&nbsp;&nbsp;&nbsp;}
</pre>
The compiler will complain that "<tt>Local variable "k" is accessed
from an inner class or a closure, and must be declared final.</tt>"

<div class="p"><!----></div>
What's at stake here is not that <tt>k</tt> is an argument, but that it is local
<tt>var</tt> for the method <tt>wontWork</tt>.  Any <tt>var</tt> declared in the body of
<tt>wontWork</tt> would have led to the same problem.</dd>
</dl>

      <h4><a name="tth_sEc5.3.1">
5.3.1</a>&nbsp;&nbsp;An aside on syntax:</h4> It is a reasonable question to ask why
X10 chose to go with a syntax different from the tradition established by C
in the 1970's.  There is no one-line answer, but function types provide a nice
example of the advantages of the newer syntax.  Suppose you want to declare that
<tt>x</tt> is a function that returns a function of a <tt>Double</tt> that returns a
function that returns an <tt>Int</tt>.  Here's the X10:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;x:&nbsp;()&nbsp;=&#62;&nbsp;(Double)&nbsp;=&#62;&nbsp;()&nbsp;=&#62;&nbsp;Int;
</pre>
This is a little contrived, true, but functions that return functions aren't all
that strange a notion.  Exercise for those who are comfortable with C/C++
syntax: rewrite this declaration in that syntax.  Good luck!

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Arrays, At Last</h2>

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Some Design Issues</h3>
Let's begin by looking at how Java and C++ implement arrays.  If you
are using one of those languages and want a matrix <tt>M</tt>, or in other
words, you want an array indexed by a pair of integers, what you get is an
array of arrays: <tt>M[i][j]</tt> is the (i,j)-th element of the array, and <tt>
M[i]</tt> is a reference to (or in C++, points to) an array that is the i-th row.
To repeat, <tt>M</tt> is not really a doubly-indexed array: it is an array of
arrays.

<div class="p"><!----></div>
Matrices are only the beginning: arrays indexed by 3-tuples,
4-tuples and even more occur regularly in physical problems.  And even if you
stick with matrices, there are a number of different types that require very
different storage layout strategies, most obviously <em>sparse</em> matrices, where
only a small fraction of the entries are non-zero, require  different
handling from <em>dense</em> matrices.

<div class="p"><!----></div>
The essential differences among these various sorts of arrays is how we choose
to manage the underlying storage, <em>and not the operations we wish to perform
on them</em>. How nice it would be, for instance, if accessing an element of an
array looked the same, regardless of the underlying storage layout. This
suggests that there should be an <tt>interface</tt> or an <tt>abstract class</tt> 
that defines the API common to all arrays, whatever their dimension or storage
layout. To get there, it is helpful to begin with two more primitive classes:
one for the type of an array index, and the other for the type of the underlying
storage:

<blockquote>
An array index is an ordered n-tuple of <tt>Ints</tt> for some non-negative
integer n.  The integer n is called the <em>dimension</em> or the <em>
rank</em> of the tuple<a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>. The corresponding X10 class is
called <tt>x10.array.Point</tt>.

<div class="p"><!----></div>
The storage required for an array is indexed by a set of tuples <em>all
having the same rank</em> n.  Again, n can be any integer  &#8805; &nbsp;0.  We'll call
these sets <em>regions</em> or <em>domains</em>, and the X10 class that implements
them is called <tt>x10.array.Region</tt>.

<div class="p"><!----></div>
</blockquote>The class <tt>x10.array.Array</tt> implements generic arrays that are local to a
single <tt>Place</tt>. It aims to provide performance at the cost, in some cases,
of storage. The three classes <tt>Point</tt>, <tt>Region</tt> and  <tt>Array</tt> are
all part of the package <tt>x10.array</tt>, which, like <tt>x10.lang</tt>, is
imported automatically for you.  The rest of this chapter looks at each of
these classes in detail.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Points</h3><a name="sec:points">
</a>

<div class="p"><!----></div>
While array code is littered with <tt>Points</tt>, there are relatively few
situations where you actually wind up constructing a <tt>Point</tt> explicitly. 
One clean way to do so is to simply write out the coordinates:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;p&nbsp;=&nbsp;[i,&nbsp;j,&nbsp;k]&nbsp;as&nbsp;Point;
</pre>
The expression <tt>[i,j,k]</tt> is really a rank-1 array of <tt>Ints</tt> of size
three.  Appending "<tt>as Point</tt>" causes the compiler to convert that <tt>
Array</tt> to a rank-3 <tt>Point</tt> with same 3 coordinates.<a href="#tthFtNtAAH" name="tthFrefAAH"><sup>7</sup></a>

<div class="p"><!----></div>
Zero-based indexing is used for <tt>Points</tt>.  So, for the <tt>Point</tt> "<tt>p</tt>"
just constructed, <tt>p(0)</tt> is <tt>i</tt>, <tt>p(1)</tt> is <tt>j</tt> and <tt>p(2)</tt> is
<tt>k</tt>.

<div class="p"><!----></div>
The assignment to <tt>p</tt> could also have been written:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;p:&nbsp;Point&nbsp;=&nbsp;[i,&nbsp;j,&nbsp;k];
</pre>
The compiler will perform the implied conversion for you.  This is an
interesting case where it makes sense to specify the type of a <tt>val</tt>.

<div class="p"><!----></div>
There is nothing sacred about using an <tt>Array</tt> literal like <tt>[i, j,
k]</tt> on the right-hand side. Any <tt>Array</tt> value that is zero-based and singly
indexed will do:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;a:&nbsp;Array[Int](1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;//&nbsp;a()&nbsp;is&nbsp;initialized&nbsp;here!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;q:&nbsp;Point&nbsp;=&nbsp;a;

</pre>

<div class="p"><!----></div>
The declaration for <tt>q</tt> here raises an
interesting issue. Suppose that you know in advance what rank you need <tt>q</tt>
to be. X10 allows you to constrain the type to make that clear:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;q:&nbsp;Point(3)&nbsp;=&nbsp;a;
</pre>
The compiler will try to enforce the restriction, but if it cannot
verify at compile-time that <tt>a</tt> has 3 elements, it will generate code to
do the check at run-time. If the check fails, a <tt>ClassCastException</tt> will be
thrown.

<div class="p"><!----></div>
In our example, the rank of <tt>q</tt> is specified as a literal constant, 3.  It
need not be. The constraint could relate the rank of <tt>q</tt> to the rank of
some other variable <tt>p</tt>:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;q:&nbsp;Point(p.rank)&nbsp;=&nbsp;...;
</pre>
We mention this not because we want to help you avoid errors by writing
more precise declarations, although being as precise as you can in your
declarations is generally a good idea.
<a href="#tthFtNtAAI" name="tthFrefAAI"><sup>8</sup></a>  But documenting when two identifiers share a property
is well worthwhile, particularly when it is not visible from the surrounding
context that they must share it.

<blockquote>
For example, X10Doc will reproduce a method's signature as part of its API
documentation. If the signature is <tt>doIt(p:Point, q:Point)</tt>, it may or may
not be clear whether <tt>p</tt> and <tt>q</tt> must have the same
rank.  It might be clear from the implementation, but X10Doc is not going to
display that.  So writing the signature out as <tt>doIt(p:Point,
q:Point(p.rank))</tt>, or in the more explicit form<a href="#tthFtNtAAJ" name="tthFrefAAJ"><sup>9</sup></a>
<tt>doIt(p:Point, q:Point{self.rank == p.rank})</tt>, has some real virtue.
It is clearly better than burying the check in the body of the method, or just
alluding to it in the method's X10Doc comment, or (worst of all) not saying
anything about it anywhere.
</blockquote>
At the moment, there are no public constructors for <tt>Points</tt>.
There is a family of static "factory" methods, all named "<tt>make</tt>".  For
example,

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;p&nbsp;=&nbsp;Point.make(1,k);
</pre>
assigns a rank 2 point to <tt>p</tt> with coordinates <tt>1</tt> and <tt>k</tt>. 
Calls to <tt>make</tt> can be made with 1, 2, 3 or 4 <tt>Int</tt>s as arguments to get
<tt>Points</tt> of the corresponding rank. For points with rank  &gt; 4,  <tt>
make</tt> takes one argument, a zero-based <tt>Array[Int](1)</tt> whose size is the
rank. In situations where the compiler can see that a conversion from <tt>
Array</tt> to <tt>Point</tt> has to be done, there is no obvious advantage to calling <tt>make</tt>
over simply using an array value, as we did in our first example.

<div class="p"><!----></div>
There is one other form of <tt>make</tt> that is sometimes convenient: 

<pre>&nbsp;&nbsp;&nbsp;val&nbsp;p&nbsp;=&nbsp;Point.make(4,&nbsp;(n:&nbsp;Int)&nbsp;=&#62;&nbsp;2*n&nbsp;+&nbsp;1);
</pre>
The first argument is the rank, which in this example is 4, and the second
argument is a function that assigns a value to each coordinate.  The value for
<tt>p</tt> will be the same as if we had written "<tt>val p:Point(4) = [1,3,5,7];</tt>".  

<div class="p"><!----></div>
<tt>Point</tt> implements coordinate-wise arithmetic for pairs of <tt>Points</tt>, for
example,

<pre>&nbsp;&nbsp;&nbsp;&nbsp;(1,2)&nbsp;+&nbsp;(3,4)&nbsp;==&nbsp;(4,6)
&nbsp;&nbsp;&nbsp;&nbsp;(2,5,8)&nbsp;*&nbsp;(6,3,1)&nbsp;==&nbsp;(12,15,8)

</pre> 
It also implements scalar arithmetic operations like

<pre>&nbsp;&nbsp;&nbsp;&nbsp;(4,3)&nbsp;-&nbsp;1&nbsp;==&nbsp;(3,2)
&nbsp;&nbsp;&nbsp;&nbsp;(6,9)/3&nbsp;==&nbsp;(2,3)

</pre> 

<div class="p"><!----></div>
In addition, <tt>Points</tt> may be compared using  <tt>
&lt;</tt>, <tt>&lt;=</tt>, <tt>&#62;=</tt> and <tt>&lt;</tt>.  The ordering is <em>lexicographic</em>:

<blockquote>
Let <tt>p</tt> and <tt>q</tt> be two points of the same rank. Then <tt>p &lt; q</tt> if,
when <tt>k</tt> is the first coordinate for which <tt>p(k) != q(k)</tt>, then <tt>
p(k) &lt; q(k)</tt>.  For example, (1,2,3,5)  &lt;  (1,2,4,0), because they agree up to
the point where the first has a 3 and the second a 4.
</blockquote>

<div class="p"><!----></div>
<b>But be careful!</b> The truth of the expression <tt>p&lt;=q && q&lt;=p</tt> does <em>
not</em> imply the truth of <tt>p==q</tt>, because <tt>Point</tt> is implemented as a <tt>
class</tt>. It <em>does</em> imply that <tt>p.equals(q)</tt>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Regions</h3><a name="sec:regions">
</a>

<div class="p"><!----></div>
A <tt>Region</tt> is just a set of <tt>Points</tt> all having the same rank.  That
rank is referred to as the rank (or dimension) of the <tt>Region</tt>. 
As with <tt>Points</tt> and <tt>Arrays</tt>, you can specify the rank of a <tt>
Region</tt> by appending it in the declaration,  "<tt>Region(2)</tt>" for a two
dimensional (rank-2) <tt>Region</tt>.

<div class="p"><!----></div>
Unlike <tt>Point</tt>, which is as concrete a class as there is, the class <tt>
Region</tt> has to be abstract, because regions vary widely in how they may be
represented efficiently.  This goes to the heart of the problem of bringing
together into one API domains as different from one another as those needed for
rectangular matrices and sparse matrices.

<div class="p"><!----></div>
The most commonly used concrete subclass handles "rectangular regions".  
A rank-<tt>n</tt> rectangular <tt>Region</tt> is determned by two rank-1
arrays of size <tt>n</tt>:

<dl compact="compact">
 <dt><b>mins,</b></dt>
	<dd> whose elements are the lower bounds for each coordinate, and</dd>
 <dt><b>maxs,</b></dt>
	<dd> whose elements are the corresponding upper bounds.</dd>
</dl> 
The <tt>Region</tt> consists of all <tt>Points p</tt>
that satisfy

<blockquote>
<tt>mins(k) &lt;= p(k) <br /></td><td width="150">
<br /></td><td width="150">
 p(k) &lt;= maxs(k)</tt> for <tt>k = 0</tt>, <tt>
1</tt>, ..., <tt>n-1</tt>.
</blockquote> 
The class method call <tt>Region.makeRectangular(mins,
maxs)</tt> constructs precisely this <tt>Region</tt>.  In the literature,
you will often find this sort of region called an "n-dimensional
hyper-rectangle" or, when the sides all have the same length, an
"n-dimensional hyper-cube".

<div class="p"><!----></div>
For constructing rank-1 <tt>Regions</tt>, there is a useful shorthand: given two
<tt>Ints</tt>, <tt>min</tt> and <tt>max</tt>, you can use the expression <tt>min..max</tt>
in place of 

<blockquote>
<tt>Region.makeRectangular([min],[max])</tt>.
</blockquote>
This means that you can represent
more general rectangular regions as Cartesian products: 

<blockquote><tt>(min1..max1) * (min2..max2) *</tt> ... <tt>*
(mink..maxk)</tt></blockquote> is the same rank-<tt>k</tt> rectangular <tt>Region</tt>
that you would get by invoking

<blockquote><tt>
Region.makeRectangular([min1,...,mink], [max1,...,maxk])</tt>
</blockquote>

<div class="p"><!----></div>
There are other "factory" methods in <tt>Region</tt>, but none nearly so
commonly used as <tt>Region.makeRectangular</tt>.  One that is useful in a negative
sort of way is <tt>makeEmpty(rank:Int)</tt>, which creates an empty
region of the given rank.  This is useful for initializing <tt>Region</tt> variables in
situations where you need some sensible value, but are not yet ready to assign
what you <em>really</em> want.  It is also useful as a return value when you wish
to return a subset of a <tt>Region</tt> where the rank is specified, and you have
to deal the possibility that there are no <tt>Points</tt> in the subset.

<div class="p"><!----></div>
Another useful method is <tt>Region.makeUnit</tt>.   If <tt>u =
Region.makeUnit()</tt>,  and if <tt>r</tt> is any <tt>Region</tt>, then the two Cartesian
products, <tt>u*r</tt> and <tt>r*u</tt> are both the same  as <tt>r</tt>-that is, both
<tt>Regions</tt> consist of the same <tt>Points</tt> as <tt>r</tt>.<a href="#tthFtNtABA" name="tthFrefABA"><sup>10</sup></a>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;The Notions Of Properties and Constrained Types</h3><a name="sub:tnpct">
</a>
<tt>Regions</tt> provide a good example of an X10 declarative notion that is not
part of either Java or C++'s type descriptions.  The starting point is the
notion of "<tt>property</tt>", and the first few lines of <tt>Region</tt>'s
declaration illustrate both forms for declaring properties:

<pre>
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;class&nbsp;Region(
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rank:&nbsp;Int,
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rect:&nbsp;Boolean,
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zeroBased:&nbsp;Boolean&nbsp;)
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;implements&nbsp;Iterable[Point(rank)]&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;rail&nbsp;=&nbsp;rank==1&nbsp;\&amp;\&amp;&nbsp;rect&nbsp;\&amp;\&amp;&nbsp;zeroBased;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;8&nbsp;}

</pre>

<dl compact="compact">
 <dt><b>lines 1-4</b></dt>
	<dd> Notice that, unlike the other class declarations we have seen,
the class name, <tt>Region</tt>, is followed by an open parenthesis, as if it were
a function signature.  Inside the parentheses are declarations for three
identifiers, <tt>rank</tt>, <tt>rect</tt>, <tt>zeroBased</tt>.  Each of these is a <em>
property</em> of the class, which is a special set of <tt>val</tt> instance fields that
may be used to constrain declarations involving the class-here is an example:

<blockquote><tt>
var r: Region{rank==2, rect==true};
</tt>
</blockquote>
We are declaring a variable <tt>r</tt> that is not just any old <tt>Region</tt>, but
one that must have rank 2 and must be rectangular. The expression <tt>
Region{...}</tt> is an example of a <em>constrained type</em>, the boolean
expression in the braces being the constraint.

<div class="p"><!----></div>
So to rephrase: a <tt>property</tt> of class, struct, or interface is a value
that you want  X10 to view as part of a type declaration.  For
example, two <tt>Regions</tt> with different <tt>ranks</tt> have distinct types.

<div class="p"><!----></div>
The three properties for an <tt>x10.array.Region</tt> have the following
semantics:

<dl compact="compact">
 <dt><b>rank</b></dt>
	<dd> is the rank of the <tt>Points</tt> in the <tt>Region</tt>. It is a
non-negative <tt>Int</tt>.</dd>
 <dt><b>rect</b></dt>
	<dd> is a <tt>Boolean</tt>.  It is true if, and only if, the <tt>Region</tt>
was constructed by calling <tt>Region.makeRectangular</tt> or by forming a
Cartesian product of rectangular regions.</dd>
 <dt><b>zeroBased</b></dt>
	<dd> is also a <tt>Boolean</tt>.  It is true when the lower bound of
the index in every coordinate is 0.</dd>
</dl></dd>
 <dt><b>line 6</b></dt>
	<dd> Here, in the body of the class definition, we declare another
property:

<dl compact="compact">
 <dt><b>rail</b></dt>
	<dd> is another <tt>Boolean</tt>.  It is true precisely when we have rank-1,
rectangular region with zero-based indexing: in other words, when we have a
C/Java-like array.</dd>
</dl></dd>
</dl>
Structs, interfaces and classes can all have properties.  When you have a
declaration like

<blockquote><tt>struct Complicated(t1: T1, t2: T2, ... tn: Tn) ...</tt>
</blockquote>
the properties <tt>t1</tt>, <tt>t2</tt>,  must be set in the constructor.  For
this example, we'd see a constructor that looked like:

<pre>
&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(&nbsp;...&nbsp;some&nbsp;argument&nbsp;list&nbsp;...&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;some&nbsp;computations&nbsp;here,&nbsp;perhaps&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property(expr1,&nbsp;expr2,&nbsp;...,&nbsp;exprn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;more&nbsp;computation&nbsp;here
&nbsp;&nbsp;&nbsp;}

</pre>
The properties that appeared in the declaration of <tt>Complicated</tt> are set in
a single <tt>property</tt> statement, the <tt>i</tt>-th expression being the value for
the <tt>i-th</tt> property named in the struct or class declaration.  So here, the
value <tt>expr1</tt> will be assigned to <tt>t1</tt>, and so on.

<div class="p"><!----></div>

<blockquote>Don't be fooled by
the story for <tt>x10.array.Region</tt> into thinking that properties must all be
some sort of "scalar" like <tt>Int</tt>.  The types <tt>Tk</tt> in the
declaration for <tt>Complicated</tt> can be just about any legitimate type you can
imagine. For example, <tt>x10.array.Array</tt> has a property <tt>region</tt> whose
value is a <tt>Region</tt>, namely the index set for the array.
</blockquote>

<div class="p"><!----></div>
As we saw in the case of <tt>rail</tt>, a property declared in the body of the
class or struct can be initialized using the values of properties in the
declaration itself.  You can also use any other property whose value is known at
the point where this property is being initialized.

<div class="p"><!----></div>
You may be wondering why <tt>Point(1)</tt> and <tt>Region(1)</tt>
work to constrain the types to having rank 1. Why don't we need <tt>
Point{rank==1}</tt>? The answer is that you can use a <tt>type</tt> declaration to
shorten the cumbersome expression that is the true constraint syntax.  Indeed,
if you look in the file <tt>x10.lang._.x10</tt><a href="#tthFtNtABB" name="tthFrefABB"><sup>11</sup></a>, you will find the
following two declarations:

<pre>
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;type&nbsp;Point(r:Int)&nbsp;=&nbsp;Point{self.rank==r};
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;type&nbsp;Region(r:Int)&nbsp;=&nbsp;Region{self.rank==r};

</pre>
The identifier "<tt>self</tt>" in these declarations refers to the type
expression of which it is a part.  In the declaration for <tt>Point(r:Int)</tt>,
for example, <tt>self</tt> refers to the <tt>Point</tt> to the right of the "<tt>
=</tt>".  

<div class="p"><!----></div>
The reason X10 introduced "<tt>self</tt>" is that there are
situations-of which the two examples above are <em>not</em> examples-in which
the property name appearing in a constraint may be ambiguous.  Here is a
typical example, where you really do need <tt>self</tt>:

<pre>
&nbsp;1&nbsp;public&nbsp;class&nbsp;Trailer(width:&nbsp;Int)&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;this(width:&nbsp;Int)&nbsp;{&nbsp;property(width);&nbsp;};
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;doubleWide():&nbsp;Trailer{self.width==2*this.width}&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Trailer(2*width);
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;6&nbsp;}

</pre>
In line 3, if we omitted the "<tt>self</tt>" and the "<tt>this</tt>" from the
constraint, the compiler would be unable to tell which <tt>width</tt> we meant:
that of the type being constrained (namely, the return type, "<tt>Trailer</tt>"),
or that of the instance of <tt>Trailer</tt> which is invoking the method <tt>
doubleWide</tt>. Also, you can see why X10 cannot
just use a single keyword <tt>this</tt>, but has to introduce a second, <tt>
self</tt>: there are two different things involved in the constraint: an instance
and a return type.

<div class="p"><!----></div>
What we meant when we said that
this example is typical is the interplay between property
names of a type that I am describing right here and property or
instance member names of the surrounding class.<a href="#tthFtNtABC" name="tthFrefABC"><sup>12</sup></a> The problem is analogous to the familiar one of
having to spell out "<tt>this.x</tt>" in a method body when <tt>x</tt> also names an argument or a local variable of that
method.  In that situation, if you really want to refer to the instance field
<tt>x</tt>, and not that other <tt>x</tt>, you have to prepend the "<tt>this.</tt>". 

<div class="p"><!----></div>
One can  go even further in constraining a type in a <tt>type</tt>
declaration than the two examples of <tt>Point</tt> and <tt>Region</tt>
above suggest. One can also force one or more properties to have some
particular value, as in

<blockquote>
<tt>public static type Matrix[T] = Array[T]{region.rank==2}</tt>;
</blockquote>
As we mentioned above, <tt>Arrays</tt> have a property <tt>region</tt> whose value is
the <tt>Region</tt> that is the <tt>Array</tt>'s index set. The type
declaration above says that a <tt>Matrix</tt> is an <tt>Array</tt> whose region has
rank 2. Of course, you could go even further and also force <tt>region.rect</tt>
to be true for a <tt>Matrix</tt>: that is, you aren't limited as to which
properties you can fix in a <tt>type</tt> declaration:

<pre>
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;type&nbsp;Matrix[T]&nbsp;=&nbsp;Array[T]&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;region.rank&nbsp;==&nbsp;2,&nbsp;region.rect,&nbsp;region.zeroBased
&nbsp;&nbsp;&nbsp;};

</pre>
Each of the comma-separated list of <tt>Boolean</tt> expressions in the braces must
evaluate to <tt>true</tt>.  You don't have to say "<tt>region.rect==true</tt>",
because <tt>region.rect</tt> is already a <tt>Boolean</tt> value.  The effect the
constraints is to pin down everything about the <tt>Array</tt>'s region except the
upper bounds on its region's two coordinates.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;Arrays: First Words</h3>

<div class="p"><!----></div>
There's more to the <tt>Region</tt> API than we've covered, but we have more than
enough for the moment, so let's move on to <tt>Arrays</tt>.

<div class="p"><!----></div>
The first thing to keep in mind when working with <tt>Arrays</tt> is that they
really are indexed by <tt>Points</tt>, not <tt>Ints</tt>.  It is easy to be misled by
code like that for the "quicksort" implementation shown as  "<tt>sort</tt>" in
Figure . The compiler has done you a favor here: because you 

<div class="p"><!----></div>
<a name="tth_fIg2">
</a> <hr />

<pre>public&nbsp;static&nbsp;def&nbsp;sort(data:Array[Int](1),left:Int,right:Int)&nbsp;{
&nbsp;&nbsp;&nbsp;var&nbsp;i:&nbsp;Int&nbsp;=&nbsp;left,&nbsp;j:&nbsp;Int&nbsp;=&nbsp;right;
&nbsp;&nbsp;&nbsp;val&nbsp;pivot&nbsp;=&nbsp;data((left&nbsp;+&nbsp;right)/2);
&nbsp;&nbsp;&nbsp;while&nbsp;(i&nbsp;&lt;=&nbsp;j)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(data(i)&nbsp;&lt;&nbsp;pivot)&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(data(j)&nbsp;&#62;&nbsp;pivot)&nbsp;j--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&lt;=&nbsp;j)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;tmp&nbsp;=&nbsp;data(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data(i++)&nbsp;=&nbsp;data(j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data(j--)&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;finish&nbsp;{&nbsp;//&nbsp;when&nbsp;you&nbsp;are&nbsp;here,&nbsp;i&nbsp;&#62;&nbsp;j
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(left&nbsp;&lt;&nbsp;j)&nbsp;async&nbsp;sort(data,&nbsp;left,&nbsp;j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&lt;&nbsp;right)&nbsp;sort(data,&nbsp;i,&nbsp;right);
&nbsp;&nbsp;&nbsp;}
}
</pre>
<hr />


<center>Figure 2: Basic quicksort for Int arrays</center><a name="fig:qs">
</a>

<div class="p"><!----></div>
declared <tt>data</tt> to be a rank-1 array, it has cast the <tt>Ints i</tt> and <tt>
j</tt> to be rank-1 <tt>Points</tt>.  If you had just declared <tt>
data</tt> to be <tt>Array[Int]</tt>, the compiler would have complained bitterly about
the argument to <tt>data</tt> not being a <tt>Point</tt>.

<div class="p"><!----></div>
The code for <tt>sort()</tt> is also worth a moment's study for the way the
recursion is handled. Using an <tt>async</tt> for the left half of the array allows you to
process the left and right halves in parallel, and the <tt>finish</tt> sets up the
rendezvous for the two threads very cleanly. <em>Extra credit</em>: if you are
familiar with tail-recursion elimination, think about the trade-off between
using the <tt>async</tt> (as we did here) and taking advantage of the
tail-recursion to eliminate the second of the two recursive calls to <tt>
sort</tt>.

<div class="p"><!----></div>
The properties <tt>rank</tt>, <tt>rect</tt>, <tt>zeroBased</tt> and <tt>rail</tt>
of an <tt>Array</tt>'s underlying <tt>Region</tt> are available as
properties of the <tt>Array</tt> itself: an <tt>Array a</tt>'s
<tt>Region</tt> is <tt>a.region</tt>, and <tt>a.rect</tt> is a shorthand for <tt>a.region.rect</tt>.
Curiously, the <tt>size</tt> of <tt>a</tt>'s <tt>Region</tt> may be got simply by
<tt>a.size</tt>-you don't need <tt>a.size()</tt>.

<div class="p"><!----></div>
One thing to remember, particularly if you come from the C++ world, is that 
all of the "<tt>new Array</tt>" calls initialize the entire <tt>Array</tt>.  If no
value is provided, the storage is zeroed.  For example, <tt>dbl = new
Array[Double](R)</tt> will set every entry of <tt>dbl</tt> to 0.0. 

<div class="p"><!----></div>
A call like 
<tt>new Array[Double](R, Double.NaN)</tt> will initialize all of the entries in
the <tt>Array</tt> with the value "not a number".  This is probably a better
initial value in many cases than the default, 0.0, would be: if you are in a
situation where you may have to check whether your program has actually stored a
value in given entry of the <tt>Array</tt> after the constructor returned, it is
better to initialize with a value that cannot be mistaken for the real thing.

<div class="p"><!----></div>
There are several different constructors to make it convenient to initialize
arrays.  Suppose that we are working with an <tt>Array</tt> whose <tt>Region</tt> is
<tt>R</tt>, and whose elements must have type <tt>T</tt>.

<dl compact="compact">
 <dt><b><tt>new Array[T](R, t)</tt></b></dt>
	<dd> Initialize every element of the array to
have the value <tt>t</tt> of type <tt>T</tt>, coercing <tt>t</tt> to the correct type, if
need be.  Our example "<tt>new Array[ Double](R, Double.NaN)</tt>" used this
call.</dd>
 <dt><b><tt>new Array[T](R, (p:Point(R.rank):T=&#62;...))</tt></b></dt>
	<dd> For each point <tt>p</tt>
in the region <tt>R</tt>, evaluates the given function at <tt>p</tt> to get the
initial value for that entry in the array.</dd>
 <dt><b><tt>new Array[T](anotherArrayOfT)</tt></b></dt>
	<dd> Create a new array that is a copy of
the argument.</dd>
</dl>
<b>Be careful here:</b> In the last form of the construct, the type of the
argument <tt>anotherArrayOfT</tt> must be precisely <tt>Array[T]</tt>, <em>and
not <tt>Array[U]</tt> for some type <tt>U</tt> that is not <tt>T</tt>, but that can be
coerced to <tt>T</tt></em>.  For example, if <tt>arrayOfInt</tt> has type <tt>
Array[Int]</tt>, you cannot write <tt>new Array[Long](arrayOfInt)</tt>.  The compiler
will say

<pre>
Constructor&nbsp;this(reg:&nbsp;x10.array.Region)&nbsp;cannot&nbsp;be&nbsp;invoked&nbsp;with
&nbsp;&nbsp;&nbsp;&nbsp;arguments&nbsp;(x10.array.Array[x10.lang.Int]).

</pre>
This may seem strange to Java and C++ programmers, who might expect the <tt>
Ints</tt> to be converted to <tt>Longs</tt> automatically on being copied into the
corresponding entries in the new <tt>Array</tt>, at the expense, possibly, of a
much slower copy. We'll have more to say about X10's strictness in this
regard in a moment.

<div class="p"><!----></div>
For 1-dimensional arrays, you can replace the region <tt>R</tt> in these calls with
the number of elements you want in the array.
There are also some other constructors that allow you to construct an array from
data that is remote-that is, is stored at another <tt>Place</tt>.  We'll worry about
them in the next chapter.

<div class="p"><!----></div>
As we saw in the initialization of <tt>Points</tt>, small 1-dimensional <tt>
Arrays</tt> can be written by simply spelling out their elements, surrounded by
square brackets, as in <tt>[1.0, 3.5, 1.1]</tt>.  Here each entry is visibly of
type <tt>Double</tt>, so the type of the <tt>Array</tt> will be <tt>Array[Double](1)</tt>
and its <tt>Region</tt> will be <tt>0..2</tt>.  

<div class="p"><!----></div>
When forming an expression like <tt>[a, b, ...]</tt>, you don't have to use
constants for the entries.  Run-time values are equally valid.

<div class="p"><!----></div>
<b>More on the strict typing:</b>  If the entries in your <tt>Array</tt> literal are
not all of exactly the same type, it is important to make the type you
want for the resulting <tt>Array</tt> explicit by casting each element in the
literal to the appropriate type. Consider the literal <tt>[3.14, 1]</tt>. If
you want to know what X10 thinks its type is, you can execute:

<blockquote>

<pre>public&nbsp;class&nbsp;CastType&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;&nbsp;&nbsp;	Console.OUT.println([3.1,&nbsp;1].typeName());
&nbsp;&nbsp;&nbsp;}
}

</pre>
</blockquote>
The console output will be <tt>x10.array.Array[x10.lang.Any]</tt>.  We've seen <tt>
Any</tt> before: it is the base interface we described in section
, page .  In other words, the most that
the two entries's types have in common is the minimum possible.
Change the "<tt>1</tt>" to a "<tt>1 as Double</tt>" and the output that you get
will be

<blockquote>
&nbsp;&nbsp;&nbsp; <tt>x10.array.Array[x10.lang.Double]</tt>.
</blockquote>

<div class="p"><!----></div>
Another way of writing the literal that will get you an array of <tt>Doubles</tt>,
if that is you want, is <tt>new Array[Double][3.14, 1]</tt>.  Notice that the array
literal <tt>[3.14, 1]</tt> follows the the array type specification immediately:
<em>it is</em> not <em>parenthesized!</em>  Providing the array element type up front
prods the compiler into doing the implied conversion of the second entry.

<div class="p"><!----></div>
It is important to understand that one does not always want the conversion of
the <tt>Int</tt> to a <tt>Double</tt> to be done.  Consider the following code:

<pre>public&nbsp;class&nbsp;Casts&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;neat&nbsp;=&nbsp;String.format("\%f&nbsp;\%d",&nbsp;[3.1,&nbsp;1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println(neat);
&nbsp;&nbsp;&nbsp;}
}
</pre>
Clearly you don't want the compiler to mess with the "1",
because your formatting string, <tt>%f %d</tt>, says, "I expect a
double-precision float, followed by an integer". Moral: sometimes you want
conversions, sometimes you don't, and the reasons may be beyond the context that
the compiler is aware of.  If you have really good manners, you can go all the
way and write <tt>[3.1 as Any, 1 as Any]</tt>. Then there is no doubt that you
match <tt>String.format</tt>'s argument type, <tt>Array[Any](1)</tt>.

<div class="p"><!----></div>
There is yet another good reason for X10's strictness regarding array types. 
Consider the following scenario:

<blockquote>
1) You create create a rank-1 array <tt>fleet</tt> whose elements are instances of
our class <tt>DieselArk</tt>.

<div class="p"><!----></div>
2) In your code, you pass <tt>fleet</tt> as an argument to a function that expects
<tt>Array[NoahsArk]</tt>.  Now, <tt>DieselArk</tt> is a subclass of <tt>
NoahsArk</tt>, so there should be no problems here.

<div class="p"><!----></div>
3) But there are.  Inside the function, an instance of <tt>RowedArk</tt>, which
is also a subclass of <tt>NoahsArk</tt>, is assigned to <tt>fleet(0)</tt>.  Then the
function returns.

<div class="p"><!----></div>
4) Back in our own code, what started out as an array of <tt>DieselArks</tt> now
has a row boat as its first element.  Not good.
</blockquote>
Java deals with this problem by inserting code to check, at the
point of the assignment, whether the class of the value being assigned is
acceptable.  In our scenario, that check would throw an exception when it saw a
row boat being supplied when a diesel was expected.  <em>This is a run-time check,
and if the array is large and the assignments many, the cost is substantial.</em> 
X10's concern is with high-performance computing, and this is a case where a
little strictness about what the compiler allows pays real dividends, not just
in theory, but in practice.

<div class="p"><!----></div>
Bottom line: as the type of an argument, <tt>Array[T]</tt> really means <tt>
Array[T]</tt>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.6">
6.6</a>&nbsp;&nbsp;Arrays: An Example</h3>

<div class="p"><!----></div>
We're now going to look at some example code that will help us fill in the API
for <tt>Arrays</tt>.  The algorithm we are going to implement comes about in
problems like trying to estimate heat transfer.  Suppose we have bowl in the
shape of a hemisphere made of ice at roughly 0deg C.  We pour some liquid into
the bowl, filling it to the top. Initially, there is some temperature
distribution across the liquid.  How does that evolve over time?  

<div class="p"><!----></div>
Intuitively,
it must be true that if one looks at a small ball in the middle of the liquid,
then over a short interval of time, the temperature at the center of the ball
should drift toward the average of the temperatures in the ball.  And, at least
for a while, because the liquid is bounded by the 0deg ice, the temperature
at the boundary ought to stay fairly close to 0deg-essentially constant.

<div class="p"><!----></div>
We are going to use a discrete version of this problem for our example. 
The <tt>Region</tt> is going to be the integer points in a hemisphere, the ice bowl
being a layer of some (relatively small) width at the boundary of the
hemisphere. The function <tt>inTheBowl</tt> differentiates the points in the bowl
from those not:

<pre>
&nbsp;1&nbsp;&nbsp;&nbsp;static&nbsp;def&nbsp;inTheBowl(p:Point(3),&nbsp;outer:Int,&nbsp;inner:Int)&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p(2)&nbsp;&#62;&nbsp;0)&nbsp;return&nbsp;-1;&nbsp;//&nbsp;p&nbsp;is&nbsp;above&nbsp;the&nbsp;bowl
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;lengthSquared:&nbsp;Int&nbsp;=&nbsp;p(0)*p(0)&nbsp;+&nbsp;p(1)*p(1)&nbsp;+&nbsp;p(2)*p(2);&nbsp;&nbsp;&nbsp;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;lengthSquared&nbsp;&lt;=&nbsp;inner&nbsp;?&nbsp;&nbsp;1&nbsp;:
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lengthSquared&nbsp;&lt;=&nbsp;outer&nbsp;?&nbsp;&nbsp;0&nbsp;:
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1;
&nbsp;7&nbsp;&nbsp;&nbsp;}
&nbsp;
</pre>
Here <tt>p</tt> is a <tt>Point</tt> of rank 3 whose position we care about.  
The two other parameters, <tt>outer</tt> and <tt>inner</tt>,
are the <em>squared</em> radii, respectively, of the whole bowl and of its
interior. 
We could take <tt>inner</tt> to be 16 = 4<sup>2</sup> and <tt>outer</tt> to be 25 = 5<sup>2</sup>.  Our bowl would be the points in the ball
of radius 5 centered at (0,0,0) whose third coordinate is  &#8804; 0.  Its
interior would be hemisphere of points that also lie in the ball of radius 4:


<blockquote>
(3,4,0) is on the boundary, since 3<sup>2</sup> + 4<sup>2</sup> is 25 = 5<sup>2</sup>; 

<div class="p"><!----></div>
(2,3,&#8722;1) is an interior point, since 2<sup>2</sup> + 3<sup>2</sup> + (&#8722;1)<sup>2</sup> is
 &#8804; 16; 

<div class="p"><!----></div>
(4,4,0), is outside of the bowl, since 4<sup>2</sup> + 4<sup>2</sup> is 32; and

<div class="p"><!----></div>
(0, 0, 1) is outside the bowl, even though its squared length is 1, because
its third coordinate is positive, and therefore it lies above the bowl.
</blockquote>
The return values of <tt>inTheBowl()</tt> are

<blockquote>
&nbsp;<tt><b>1</b></tt>&nbsp;&nbsp;&nbsp; when the point lies in the inner
bowl- is in the interior;<br />
&nbsp;<tt><b>0</b></tt>&nbsp;&nbsp;&nbsp; when the point lies between the inner
and outer bowls- lies on the boundary;  and<br />
<tt><b>-1</b></tt>&nbsp;&nbsp;&nbsp; when the point lies outside the outer bowl. 
</blockquote>
We could, if we wished to, capture all of <tt>inTheBowl</tt>'s values as cheaply
as possible in an <tt>Array[Byte]</tt>, and avoid having to call the function any
more often than necessary.

<div class="p"><!----></div>
<b>Problem:</b> We'd like an <tt>Array</tt>, the temperature distribution,
whose Region is exactly the bowl.  To get there, we need to implement an
extension of the class <tt>Region</tt> whose <tt>Points</tt> are those in the whole
bowl, and which also has enough information so that we can easily and
efficiently tell when a <tt>Point</tt> is on the boundary. We'll call the class
"<tt>BlobWithBdry</tt>", because it allows us, at minimal additional cost, to
define <tt>Regions</tt> much less regular than our very-well behaved bowls. You
can find the code for it in its entirety in
 <a href="http://dist.codehaus.org/x10/documentation/guide/src/avging/BlobWithBdry.x10">avging/BlobWithBdry.x10</a>.

<div class="p"><!----></div>
<tt>BlobWithBdry</tt> has two main instance fields: a <tt>Region</tt>
"<tt>box</tt>" that contains the (possibly quite irregular) blob that is the <tt>
Region</tt> we really want, and a function "<tt>where: (p:Point)=&#62;Byte</tt>" that
implements the analogue of <tt>inTheBowl</tt>: <tt>where</tt> is defined for <tt>
Points</tt> in <tt>box</tt>, and its value is positive, 0, or
negative according as <tt>p</tt> is in the interior, on the boundary, or outside
the blob.  Here is the constructor:

<div class="p"><!----></div>

<pre>&nbsp;1&nbsp;public&nbsp;class&nbsp;BlobWithBdry&nbsp;extends&nbsp;Region&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;val&nbsp;box:&nbsp;&nbsp;&nbsp;Region(rank);
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;val&nbsp;where:&nbsp;(p:&nbsp;Point)=&#62;Int;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(box:Region,&nbsp;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where:(p:&nbsp;Point)=&#62;Int)&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(box.rank,&nbsp;false,&nbsp;false);
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.box&nbsp;&nbsp;&nbsp;=&nbsp;box;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.where&nbsp;=&nbsp;where;
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;}
10&nbsp;&nbsp;&nbsp;&nbsp;...
</pre>

<dl compact="compact">
 <dt><b>line 2:</b></dt>
	<dd>  <tt>box</tt> is a <tt>Region</tt> that is large enough to hold the
blob and that can serve as the natural domain for the mask <tt>where</tt>.
In practice, it will be a rectangular region: the whole point is space 
and time efficiency.  Because the blob-like <tt>Region</tt> we are representing
here is a subset of the <tt>Region box</tt>, the two <tt>Regions</tt> clearly must
have the same rank.

<blockquote> 
In the context of this line, <tt>rank</tt> appearing unqualified is a shorthand for
<tt>this.rank</tt>, namely the rank of this instance of a <tt>BlobWithBdry</tt>.  So
the declaration "<tt>box:Region(rank)</tt>" means that <tt>box</tt> is a <tt>Region</tt>
whose rank must be the same as its <tt>BlobWithBdry</tt>'s rank.
</blockquote></dd>
 <dt><b>lines 3, 5:</b></dt>
	<dd> "<tt>where</tt>" is the function that determines which <tt>
Points</tt> in the <tt>box</tt> are in the blob and which are actually on the boundary.</dd>
 <dt><b>line 6:</b></dt>
	<dd> The constructor begins by calling the superclass <tt>Region</tt>'s
constructor.  The first argument, <tt>box.rank</tt>, is what will become the <tt>
rank</tt> of the newly constructed <tt>Region</tt>.  This is how we force our new
<tt>Region</tt> and <tt>box</tt> to have the same rank.  The remaining two
arguments being false, say that our region is neither rectangular nor
zero-based.</dd>
</dl>

<div class="p"><!----></div>
The bulk of the rest of the code in <tt>BlobWithBdry.x10</tt> is boilerplate that
is needed to fill in all of the abstract methods of the <tt>Region</tt> API, so we
leave it to those who are interested to read through the source. We are really more
interested in how to use this class than in its implementation.
A class we'll call <tt>HeatXfer</tt> carries out the averaging process that we
sketched at the start of this section.  The complete source for it can be found
in
<a href="http://dist.codehaus.org/x10/documentation/guide/src/avging/HeatXfer.x10">avging/HeatXfer.x10</a>.

<div class="p"><!----></div>
Its instance fields are

<pre>
&nbsp;&nbsp;&nbsp;private&nbsp;val&nbsp;B:&nbsp;BlobWithBdry;&nbsp;
&nbsp;&nbsp;&nbsp;private&nbsp;val&nbsp;T:&nbsp;Array[Double](B.rank);

</pre>
<tt>B</tt> is the bowl, which we're declaring to be an arbitrary blob, but our
constructor is only going to initialize it to be a bowl.
The <tt>Array T</tt> is the temperature array. We will initialize it with random
values between 0.0 and 1.0 and then average some number of times to see how it
evolves. 

<div class="p"><!----></div>
The last ingredient we need is the "small ball" over which to average. We'll
start with the integer points on the boundary of the ball of radius 1 around the
origin (0,0,0)  That set is precomputed as the array <tt>NBRS</tt>. It consists of the 6
points (&#177;1, 0, 0), (0, &#177;1, 0)  and (0, 0, &#177;1), which are the
nearest neighbors of the origin.

<div class="p"><!----></div>
<tt>HeatXfer</tt>'s constructor is 

<pre>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(r:&nbsp;Int,&nbsp;bw:&nbsp;Int)&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;box&nbsp;=&nbsp;(-r..r)&nbsp;*&nbsp;(-r..r)&nbsp;*&nbsp;(-r..0);
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inBowl&nbsp;=&nbsp;(p:Point)=&#62;inTheBowl(p,r*r,(r-bw)*(r-bw));
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;new&nbsp;BlobWithBdry(box,&nbsp;inBowl);
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;new&nbsp;Random();
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;assignTemp&nbsp;=&nbsp;(p:Point(B.rank))&nbsp;=&#62;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B.contains(p)&nbsp;?&nbsp;rand.nextDouble()&nbsp;:&nbsp;-300.0;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;=&nbsp;new&nbsp;Array(B,&nbsp;assignTemp);
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;

</pre>

<dl compact="compact">
 <dt><b>line 1:</b></dt>
	<dd>  The arguments to the constructor are

<dl compact="compact">
 <dt><b><b>r</b>:</b></dt>
	<dd> the radius of the ball the lower half of whose interior is the
bowl.</dd>
 <dt><b><b>bw</b>:</b></dt>
	<dd> the boundary width: the boundary will consist of all the points
with integer coordinates lying in the bowl, but lying outside the ball of radius
<tt>r-bw</tt>.</dd>
</dl></dd>
 <dt><b>line 2:</b></dt>
	<dd> On the right-hand side, we construct the hyper-rectangle that is
the bounding box for the bowl. It is the smallest rectangular region that
contains the bowl.  The use of Cartesian products of 1-dimensional <tt>Regions</tt>
makes this code very clean.</dd>
 <dt><b>lines 3-4:</b></dt>
	<dd> Here we are using the function <tt>inTheBowl</tt> that we
described earlier to create the function for the particular case we need here:
outer radius <tt>r</tt> and inner radius <tt>r-bw</tt>.  Remember that <tt>inTheBowl</tt>
uses the <em>squared</em> radii as arguments.</dd>
 <dt><b>lines 5-8:</b></dt>
	<dd> This is the now familiar waltz for creating and initializing
an <tt>Array</tt>.  For points in the bowl, we use a random number between 0.0 and
1.0.  Outside of the bowl, we use the value <tt>-300.0</tt>.  That guarantees
that if we ever try to average in a point <em>not</em> in the bowl, we will get a negative
value, which is clearly nonsense, since in the bowl, boundary and all, the
temperature is 0.0 or above.</dd>
</dl>
The process, starting from <tt>HeatXfer</tt>'s <tt>main</tt> is (1) construct the
bowl and the initial temperature distribution, (2) print some initial
statistics about the temperature distribution, (3) go through the averaging
algorithm some number of times, and (4) print the final temperature statistics.
We'll look at the display last-it turns out to be the interesting part.
Here's the averaging code:

<div class="p"><!----></div>

<pre>&nbsp;1&nbsp;public&nbsp;def&nbsp;average()&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;for(p&nbsp;in&nbsp;T)&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(B.isInTheInterior(p))&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;count:&nbsp;Int&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sum:&nbsp;&nbsp;&nbsp;Double&nbsp;=&nbsp;T(p);
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var&nbsp;n:&nbsp;Int&nbsp;=&nbsp;0;&nbsp;n&nbsp;&lt;&nbsp;6;&nbsp;n++)&nbsp;{
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;neighbor&nbsp;=&nbsp;p&nbsp;+&nbsp;NBRS(n);
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(B.contains(neighbor))&nbsp;{
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;&nbsp;+=&nbsp;T(neighbor);
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;+=&nbsp;1;
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T(p)&nbsp;=&nbsp;sum/count;&nbsp;
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
15&nbsp;&nbsp;&nbsp;&nbsp;}
16&nbsp;}
</pre>
A few comments:

<dl compact="compact">
 <dt><b>line 2:</b></dt>
	<dd> This is some classic "syntactic sugar."  The loop is over all
<tt>Points p</tt> in the <tt>Region</tt> underlying the <tt>Array T</tt>.  This works
because <tt>Region</tt> has an instance method <tt>iterator()</tt> that returns an
object that implements the <tt>Iterator</tt> interface that we first saw in
connection with reading lines from a file (Figure <a href="#fig:flc">1</a>, page
<a href="#fig:flc">pageref</a>).  This <tt>Iterator</tt>'s <tt>next()</tt> method returns the next
<tt>Point</tt> from the <tt>Region</tt> in lexicographic order, so in the <tt>for</tt>
loop, that is the order in which <tt>Points</tt> will be processed.</dd>
 <dt><b>lines 6-12</b></dt>
	<dd> The interesting part of this method is the loop in lines 6
through 12, particularly line 7, where we take advantage of the ability to add
one rank-3 <tt>Point</tt> to another.  Since <tt>NBRS</tt> is the set of neighbors
of (0,0,0), forming <tt>p + NBRS</tt> gives us the neighbors of <tt>p</tt>.  We
have to be a little careful.  Points that look like (x,y,0) are at the top of
the interior. They have a neighbor (x,y,1) that is <em>above</em> the bowl. 
That is why we have a test in line 8 that the neighbor is still inside the
bowl.  <em>Exercise:</em> We wrote a relatively expensive, but general test here:
<tt>B.contains(neighbor)</tt>. Can we get away with a weaker test, "<tt>
neighbor(2) &lt;= 0</tt>"?</dd>
</dl>

<div class="p"><!----></div>
Let's look at how to display some of the statistics for the initial and final
temperature distributions. Here is one way to get the maximum over the
whole region:

<pre>
&nbsp;&nbsp;&nbsp;var&nbsp;max:&nbsp;Double&nbsp;=&nbsp;-1.0;
&nbsp;&nbsp;&nbsp;for(p&nbsp;in&nbsp;T)&nbsp;max&nbsp;=&nbsp;Math.max(max,&nbsp;T(p));

</pre>
Because the temperatures are all at least 0, the maximum has to be bigger than
-1.  So when we exit the loop, we are guaranteed that <tt>max</tt> is the maximum.
Another way of saying the same thing is:

<pre>val&nbsp;max&nbsp;=&nbsp;T.reduce((a:Double,&nbsp;b:Double)=&#62;Math.max(a,b),&nbsp;-1.0);
</pre>
The first argument is a function of two variables whose results we wish to
accumulate.  
The second argument is used as the initial value of the process. Our
assumptions about temperatures in the bowl guarantee that <tt>Math.max(T(p),-1)
== Math.max(-1,T(p)) == T(p)</tt>, so once we evaluate the function for the first
point, we get a valid value that actually occurs as an entry in the array <tt>
T</tt>. Here is another example:

<div class="p"><!----></div>

<pre>val&nbsp;sum1&nbsp;=&nbsp;T.reduce((a:Double,b:Double)=&#62;a+b,0.0);
</pre>

<div class="p"><!----></div>
This reduction computes the sum of the array elements. Using <tt>0.0</tt> as the
initial value, means that the sum of the element is exactly what we get. We
could have also evaluated

<div class="p"><!----></div>

<pre>val&nbsp;sum2&nbsp;=&nbsp;T.reduce((a:Double,b:Double)=&#62;a+b,1000.0);
</pre>

<div class="p"><!----></div>
The answer, <tt>sum2</tt> will be what you expect: <tt>sum1 + 1000.0</tt>.

<div class="p"><!----></div>
Which is preferable, the loop or the call to <tt>reduce</tt>?  From a performance
point of view, you have to favor <tt>reduce</tt>, because the implementer of <tt>
Array</tt> can write more efficient code for the traversal, particularly for
rectangular and other very regular regions.  The use of the term "reduce" in
the sense X10 does in this context is now widespread, so there is no real
readability issue.

<div class="p"><!----></div>
There are two related calls, <tt>scan</tt> and <tt>map</tt>, that are often useful. 
<tt>scan</tt> is like <tt>reduce</tt>, but instead of producing a single answer, it
creates an <tt>Array</tt> with the same <tt>Region</tt> as the one we are iterating
over, and the value at each <tt>Point p</tt> is cumulative value after we process
the element at <tt>p</tt>.

<pre>
val&nbsp;a&nbsp;=&nbsp;[1,2,3,4];
val&nbsp;scanned&nbsp;=&nbsp;a.scan((m:Int,n:Int)=&#62;m+n,&nbsp;0);
</pre>
yields the array <tt>[1, 3, 6, 10]</tt>, which is then assigned to <tt>scanned</tt>.
The method <tt>map</tt> has several variations which, in effect, provide unary and
binary operations on arrays.  The simplest form is converts a array of <tt>Ts</tt>
to an array of <tt>Us</tt>.  Suppose <tt>A</tt> is the <tt>Array</tt> and <tt>op:(t:T)=&#62;
U</tt>. Then <tt>A.map(op)</tt> is exactly the same as the result of the constructor

<pre>&nbsp;new&nbsp;Array[U](A.region,&nbsp;(p:Point(A.rank))=&#62;op(A(p)));
</pre>

<div class="p"><!----></div>
This form is the "unary operator" on <tt>Arrays</tt>.  A variation is <tt>
A.map(B, op)</tt>, in which <tt>B</tt> is an array of type <tt>U</tt>.  Instead of
constructing a new <tt>Array</tt>, the entry <tt>B(p)</tt> is set to <tt>op(A(p))</tt>
for every <tt>p</tt>.  If <tt>A == B</tt>, the effect is to modify <tt>A</tt> in place.

<div class="p"><!----></div>
The binary form for <tt>map</tt> starts with a pair of arrays <tt>A: Array[T]</tt> and
<tt>B: Array[U]</tt> with the same underlying <tt>Region</tt> and forms a new <tt>Array[V]</tt>
by applying a function <tt>op:(t:T, u:U) =&#62; V</tt> to each pair from <tt>A</tt> and
<tt>B</tt>.  As with the unary form, you can also provide a destination array as
the first argument: <tt>A.map(C, B, op)</tt>.

<div class="p"><!----></div>
<em>Exercise:</em> We've mentioned that we could replace the field <tt>where</tt>
in <tt>BlobWithBdry</tt>, which in our implementation is a function, by an <tt>
Array</tt> of <tt>Bytes</tt> whose <tt>Region</tt> is the field <tt>box</tt>, 
and whose value at a <tt>Point p</tt> is exactly the value <tt>where(p)</tt> that the
function we have now would have returned.  It is worth a few minutes to make
this change, if for no other reason than to see how <em>little</em> you do have to
change to get <tt>BlobWithBdry</tt> back and working.  What are the trade-offs
between keeping the function and pre-computing it as an <tt>Array</tt>?  

<div class="p"><!----></div>
Another variation on this theme is to create a more limited class <tt>Bowl</tt>
that really does 3-dimensional bowls and not general blobs.  In particular, you
can make <tt>where</tt> an <em>instance method</em>-or even a <em>static method</em>
with the right parameters-that does exactly the right thing for bowls, and
not an <em>instance field</em> that is generic.  Question: what else has to
change to make this approach workable? One of the
interesting things here is the trade-off between the generic closure
capturing the bowl's parameters (see the constructor for <tt>HeatXFer</tt>),
versus keeping those parameters as instance data.  Does this
change (from generic closure to method) affect the performance for your
installation? What do we really pay for allowing the generality of blobs?

<div class="p"><!----></div>
You might also want to add the mean temperature to our displayed statistics. 
It's a one-liner if you use <tt>reduce</tt>.  Again: what are the trade-offs
between n calls to <tt>map</tt>, <tt>reduce</tt>, and <tt>scan</tt>, versus a
single loop with n expressions to evaluate on each iteration- two
calls, one each for <tt>max</tt> and <tt>mean</tt>, versus a single loop that
computes both?  

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Strictly speaking, this is true, but in practice, support for
multi-byte character sets in both <tt>Char</tt> and <tt>String</tt> is very limited. 
For the moment, you would be best advised to stay with 7-bit ASCII or 8-bit ISO
character sets.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>The type <tt>
Any</tt>, as we discussed in section , page ,
is the interface all values have in common.
<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>Strictly speaking,  you only need
a subclass of the parent class of <tt>Exception</tt>, which is called "<tt>
Throwable</tt>".  As a general rule, application code should use or subclass <tt>
Exception</tt> for problems that application code can reasonably be expected to
handle.  <tt>Throwable</tt> should be reserved for X10 and for situations that
you don't expect application code to handle.
<div class="p"><!----></div>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>
See
<a href="http://dist.codehaus.org/x10/documentation/guide/src/fcns/TryArgs.x10">fcns/TryArgs.x10</a>.

<div class="p"><!----></div>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>C++ would pass <tt><br /></td><td width="150">
c</tt> as the argument value, and the argument would
be declared to be TryArgs4 *pc.  We could then say "<tt>pc-&#62;value =
1</tt>" in <tt>tryargs</tt>.  In <tt>main</tt>, what <tt>c</tt> names would be the same
piece of storage no matter what <tt>tryargs</tt> assigns to <tt>pc</tt>, but
the update of <tt>c</tt>'s value implied by the assignment "<tt>pc-&#62;value =
1</tt>" will be visible in <tt>
main</tt>, as it is X10 .
<div class="p"><!----></div>
<a name="tthFtNtAAG"></a><a href="#tthFrefAAG"><sup>6</sup></a>It may seem strange that we allow rank-0 tuples.
This a technical convenience having to do with writing code that involves
Cartesian products of regions, which we will discuss when we get to the details
on regions in section .
<div class="p"><!----></div>
<a name="tthFtNtAAH"></a><a href="#tthFrefAAH"><sup>7</sup></a>The use of
"rank" in two different senses here is perhaps unfortunate, what with a
rank-1 array turning into a rank-3 point. It's the price we pay for being able
to speak of the rank of an array's region as the array's rank.
<div class="p"><!----></div>
<a name="tthFtNtAAI"></a><a href="#tthFrefAAI"><sup>8</sup></a> It would be surprising, however, if
anybody ever passed a 3-dimensional value to a variable that only expected a
2-dimensional one-that just does not happen, and we don't expect you'll make
such a mistake, either.
<div class="p"><!----></div>
<a name="tthFtNtAAJ"></a><a href="#tthFrefAAJ"><sup>9</sup></a>
We'll describe the full syntax for describing constraints in section

<div class="p"><!----></div>
<a name="tthFtNtABA"></a><a href="#tthFrefABA"><sup>10</sup></a>  You can
think of <tt>u</tt> as being a <tt>Region</tt> of rank 0 containing a single <tt>
Point</tt> that we'll call `<tt>?</tt>'. When you form the product <tt>r*u</tt>, you get a
<tt>Point</tt> in it for each pair <tt>p,q</tt> of <tt>Points</tt> with <tt>p</tt> in <tt>
r</tt> and <tt>q</tt> in <tt>u</tt>. Since '<tt>?</tt>' is the only point in <tt>u</tt>, the
product therefore consists of one <tt>Point</tt> for each <tt>p</tt> in <tt>r</tt>.
The new <tt>Point</tt>'s coordinates are those of <tt>p</tt> followed by those of
`<tt>?</tt>'.  <em>Since <tt>u</tt> has rank 0, `<tt>?</tt>' adds <em>no</em>
coordinates,</em> so we are left with our original <tt>p</tt>. Devious, but not
unreasonable: <tt>r.equals(r*u)</tt>.
<div class="p"><!----></div>
<a name="tthFtNtABB"></a><a href="#tthFrefABB"><sup>11</sup></a>
Yes that is correct: the file's name is "<tt>_</tt>".
<div class="p"><!----></div>
<a name="tthFtNtABC"></a><a href="#tthFrefABC"><sup>12</sup></a>
Another situation where there can be ambiguity is where the type be constrained
appears in a type description involving parameters, like <tt>
Array[Array[Int]]</tt>, where <tt>region</tt> is a property of both of the <tt>
Arrays</tt> in the expression.
<br /><br /><hr />
</html>
