<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>User-Defined Operators</title>
</head>

<body>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;User-Defined Operators</h2>
<a name="sect:operators">
</a>



<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">MethodDecl ::= MethMods <b>def</b> Id TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody = </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> BinOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>this</b> BinOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> BinOp <b>this</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>this</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams <b>=</b> <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> <b>as</b> Type WhereClause<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> <b>as</b> <b>?</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a <b>Poly</b> class of
polynomials - for the sake of illustration, single-variable polynomials with
<b>Int</b> coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: <b>+</b> to add, <b>*</b> to multiply,
<b>-</b> to subtract, and <b>p(x)</b> to compute the value of the polynomial at
argument <b>x</b>.  We would like to write code thus: 

<div class="p"><!----></div>
<pre>
  public static def main(Array[String](1)):void {
     val X = new Poly([0,1]);
     val t &lt;: Poly = 7 * X + 6 * X * X * X; 
     val u &lt;: Poly = 3 + 5*X - 7*X*X;
     val v &lt;: Poly = t * u - 1;
     for( i in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Writing the same code with method calls, while possible, is far less elegant: 

<div class="p"><!----></div>
<pre>
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t &lt;: UglyPoly = X.mult(7).plus(
                          X.mult(X).mult(X).mult(6));  
     val u &lt;: UglyPoly = const(3).plus(
                           X.mult(5)).minus(X.mult(X).mult(7));
     val v &lt;: UglyPoly = t.mult(u).minus(1);
     for( i in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
</pre>

<div class="p"><!----></div>
The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as <b>1+X</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
Most X10 operators can be given definitions.<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>  (However, <b>&amp;&amp;</b> and
<b>&#124;&#124;</b> 
are only short-circuiting for <b>Boolean</b> expressions; user-defined versions
of these operators have no special execution behavior.)

<div class="p"><!----></div>
The user-definable operations are (in order of precedence): <br />

<table>
<tr><td align="left">implicit type coercions</td></tr>
<tr><td align="left">postfix <b>()</b></td></tr>
<tr><td align="left"><b>as T</b></td></tr>
<tr><td align="left">unary <b>-</b>, unary <b>+</b>, <b>!</b>, <b>&#126;</b></td></tr>
<tr><td align="left"><b>..</b></td></tr>
<tr><td align="left"><b>*     </b>  <b>/     </b>  <b>%</b> </td></tr>
<tr><td align="left"><b>+</b> <b>     -</b> </td></tr>
<tr><td align="left"><b>&lt;&lt;    </b> <b>&#62;&#62;    </b> <b>&#62;&#62;&#62;   </b> <b>-&#62;</b> </td></tr>
<tr><td align="left"><b>&#62;     </b> <b>&#62;=    </b> <b>&lt;     </b> <b>&lt;=     </b> 
<b>in     </b> 
<b>&amp;</b> </td></tr>
<tr><td align="left"><b>^</b> </td></tr>
<tr><td align="left"><b></td><td align="left">&#124;</b> </td></tr>
<tr><td align="left"><b>&amp;&amp;</b> </td></tr>
<tr><td align="left"><b></td><td align="left">&#124;</td><td align="left">&#124;</b> </td></tr></table>


<div class="p"><!----></div>
Many operators may be defined either in <b>static</b> or instance forms.  Those
defined in instance form are dynamically dispatched, just like an instance
method.  Those defined in static form are statically dispatched, just like a
static method.  

<div class="p"><!----></div>
<pre>
static class Trace(n:Int){
  public static operator !(f:Trace) = new Trace(10 * f.n + 1);
  public operator -this = new Trace (10 * this.n + 2);
}
static class Brace extends Trace{
  def this(n:Int) { super(n); }
  public operator -this = new Brace (10 * this.n + 3);
  static def example() {
     val t = new Trace(1);
     assert (!t).n == 11;
     assert (-t).n == 12 &amp;&amp; (-t instanceof Trace);
     val b = new Brace(1);
     assert (!b).n == 11;
     assert (-b).n == 13 &amp;&amp; (-b instanceof Brace);
  }
}

<div class="p"><!----></div>
</pre>


<div class="p"><!----></div>
Operators may be invoked by unambiguous syntax, loosely akin to a
fully-qualified name. For example, <b>!t</b> above may be invoked as
<b>Trace.operator !(t)</b>. This unambiguous syntax may be used even if there
are several <b>!</b> operators that could apply to <b>t</b>, rendering the
convenient short form <b>!t</b> unavailable in some context.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Binary Operators</h3>

<div class="p"><!----></div>
Binary operators, illustrated by <b>+</b>, may be defined statically in a
container <b>A</b> as:
<pre>
static operator (b:B) + (c:C) = ...;
</pre>
In this case it may be invoked as <b>A.operator +(b,c)</b>.
Or, it may be defined as  as an instance operator by one of the forms:
<pre>
operator this + (b:B) = ...;
operator (b:B) + this = ...;
</pre>
and be invoked as 
<b>a.operator +(b)</b>
and as 
<b>a.operator ()+(b)</b> 
respectively.

<div class="p"><!----></div>
Defining the sum <b>P+Q</b> of two polynomials looks much like a method
definition.  It uses the <b>operator</b> keyword instead of <b>def</b>, and
<b>this</b> appears in the definition in the place that a <b>Poly</b> would
appear in a use of the operator.  So, 
<b>operator this + (p:Poly)</b> explains how to add <b>this</b> to a
<b>Poly</b> value.
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public def degree() = coeff.size-1;
  public def  a(i:Int) = (i&lt;0 &#124;&#124; i&#62;this.degree()) ? 0 : coeff(i);

<div class="p"><!----></div>
  public operator this + (p:Poly) =  new Poly(
     new Array[Int](
        Math.max(this.coeff.size, p.coeff.size),
        (i:Int) =&#62; this.a(i) + p.a(i)
     )); 
  // ... 
</pre>

<div class="p"><!----></div>
The sum of a polynomial and an integer, <b>P+3</b>, looks like
an overloaded method definition.  
<pre>
   public operator this + (n : Int) = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
However, we want to allow the sum of an integer and a polynomial as well:
<b>3+P</b>.  It would be quite inconvenient to have to define this as a method
on <b>Int</b>; changing <b>Int</b> is far outside of normal coding.  So, we
allow it as a method on <b>Poly</b> as well.

<div class="p"><!----></div>
<pre>
   public operator (n : Int) + this = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
<b>Poly</b>s could have been written:
<pre>
  public static operator (p:Poly) + (q:Poly) =  new Poly(
     new Array[Int](
        Math.max(q.coeff.size, p.coeff.size),
        (i:Int) =&#62; q.a(i) + p.a(i)
     ));
</pre>

<div class="p"><!----></div>
When X10 attempts to typecheck a binary operator expression like <b>P+Q</b>, it
first typechecks <b>P</b> and <b>Q</b>. Then, it looks for operator declarations
for <b>+</b> in the types of <b>P</b> and <b>Q</b>. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a <em>best-matching</em> operation, <em>viz</em> one which does
not require the operands to be converted to another type. For example,
<b>operator this + (n:Long)</b> and <b>operator this + (n:Int)</b> both apply to
<b>p+1</b>, because <b>1</b> can be converted from an <b>Int</b> to a <b>Long</b>.
However, the <b>Int</b> version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Unary Operators</h3>

<div class="p"><!----></div>
Unary operators,  illustrated by <b>!</b>, may be defined statically in
container 
<b>A</b> as 
<pre>
static operator !(x:A) = ...;
</pre>
or as instance operators by: 
<pre>
operator !this = ...;
</pre>

<div class="p"><!----></div>
A statically-defined unary operator <b>!</b> may be invoked on <b>a:A</b> as 
<b>A.operator !(a)</b>.  An instance operator may be invoked as
<b>a.operator !()</b>.  

<div class="p"><!----></div>
The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

<div class="p"><!----></div>
The operator to negate a polynomial is: 

<div class="p"><!----></div>
<pre>
  public operator - this = new Poly(
    new Array[Int](coeff.size, (i:Int) =&#62; -coeff(i))
    );
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Type Conversions</h3>


<div class="p"><!----></div>
Explicit type conversions, <b>e as A</b>, can be defined as operators on
class <b>A</b>.  These must be static operators, and are defined in the 
the form: 
<pre>
static operator (x:B) as A{c} = ... 
</pre>
They may be invoked by the unambiguous syntax: 
<pre>
A.operator as[A](b)
</pre>

<div class="p"><!----></div>
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public static operator (a:Int) as Poly = new Poly([a]);
  public static def main(Array[String](1)):void {
     val three : Poly = 3 as Poly;
  }
}
</pre>


<div class="p"><!----></div>
Furthermore, <b>T</b> may be written as <b>?</b> in the definition of a type
conversion operator (and only there) to have it inferred from context: 

<div class="p"><!----></div>
<pre>
class Caster(n:Int) {
  public static operator (a:Int) as ? = new Caster(a); 
  public static def example() {
    val c : Caster{n==3} = 3 as Caster{n==3};
  }
}
</pre>

<div class="p"><!----></div>
The <b>?</b> may be given a bound, such as <b>as ? &lt;: Caster</b>, if desired.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Implicit Type Coercions</h3>
<a name="sect:ImplicitCoercion">
</a>


<div class="p"><!----></div>
An implicit type conversion from <b>U</b>  to <b>T</b> may be specified in
either <b>U</b> or <b>T</b>.  
The syntax for it, in either case, is: 
<pre>
static operator (u:U) : T = e;
</pre>
which may be invoked by the unambiguous syntax 
<b>T.operator[T](u)</b> or <b>U.operator[T](u)</b>.


<div class="p"><!----></div>
Implicit coercions are used automatically by the compiler on method calls 
() and assignments ().

<div class="p"><!----></div>
For example, we can define an implicit coercion from <b>Int</b> to <b>Poly</b>,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define <b>+</b> on
two polynomials (using a <b>static</b> operator, so that implicit coercions
will be used - they would not be for an instance method operator).  The
calculation <b>1+x</b> coerces <b>1</b> to a polynomial and uses polynomial
addition to add it to <b>x</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static operator (c : Int) : Poly = new Poly([c]);

<div class="p"><!----></div>
  public static operator (p:Poly) + (q:Poly) = new Poly(
      new Array[Int](
        Math.max(p.coeff.size, q.coeff.size),
        (i:Int) =&#62; p.a(i) + q.a(i)
     ));

<div class="p"><!----></div>
  public static def main(Array[String](1)):void {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;Assignment and Application Operators</h3>




<a name="set-and-apply">
</a>
X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The <b>Array</b>-like classes take advantage
of both of these in <b>a(i) = a(i) + 1</b>.  

<div class="p"><!----></div>
<b>a(b,c,d)</b>
is an operator call, to an operator defined with 
<b>public operator this(b:B, c:C, d:D)</b>.  It may be overloaded.
For
example, an ordered dictionary structure could allow subscripting by numbers
with <b>public operator this(i:Int)</b>, and by string-valued keys with 
<b>public operator this(s:String)</b>.  

<div class="p"><!----></div>
<b>a(i,j)=b</b> is an <b>operator</b> as well, with zero or more indices
<b>i,j</b>.  It may also be overloaded. 

<div class="p"><!----></div>
The update operations <b>a(i) += b</b> are defined to be the same as the
corresponding <b>a(i) = a(i) + b</b>. This applies for all arities of
arguments, and all types, and all binary operations. Of course to use this,
both the application and assignment <b>operator</b>s must be defined.

<div class="p"><!----></div>
The <b>Oddvec</b> class of somewhat peculiar vectors illustrates this.
<b>a()</b> returns a string representation of the oddvec, which probably should
be done by <b>toString()</b> instead.  
<b>a(i)</b> sensibly picks out one of the three
coordinates of <b>a</b>.
<b>a()=b</b> sets all the coordinates of <b>a</b> to <b>b</b>.
<b>a(i)=b</b> assigns to one of the
coordinates.  <b>a(i,j)=b</b> assigns different values to <b>a(i)</b> and
<b>a(j)</b>, purely for the sake of the example.

<div class="p"><!----></div>
<pre>
class Oddvec {
  var v : Array[Int](1) = new Array[Int](3, (Int)=&#62;0);
  public operator this () = 
      "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public operator this () = (newval: Int) { 
    for(p in v) v(p) = newval;
  }
  public operator this(i:Int) = v(i);
  public operator this(i:Int, j:Int) = [v(i),v(j)];
  public operator this(i:Int) = (newval:Int) = {v(i) = newval;}
  public operator this(i:Int, j:Int) = (newval:Int) = {
       v(i) = newval; v(j) = newval+1;} 
  public def example() {
    this(1) = 6;   assert this(1) == 6;
    this(1) += 7;  assert this(1) == 13;
  }
</pre>

<div class="p"><!----></div>

</body>
</html>