<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>Classes</title>
<a href="#tth_chAp1">Classes</a> <br/>
<ul>
<li><a href="#tth_sEc1">Principles of X10 Objects</a> <br/>
<li><a href="#tth_sEc2">Fields</a> <br/>
<li><a href="#tth_sEc3">Properties</a> <br/>
<li><a href="#tth_sEc4">Methods</a> <br/>
<li><a href="#tth_sEc5">Constructors</a> <br/>
<li><a href="#tth_sEc6">Static initialization</a> <br/>
<li><a href="#tth_sEc7">User-Defined Operators</a> <br/>
<li><a href="#tth_sEc8">Class Guards and Invariants</a> <br/>
<li><a href="#tth_sEc9">Method Resolution</a> <br/>
<li><a href="#tth_sEc10">Static Nested Classes</a> <br/>
<li><a href="#tth_sEc11">Inner Classes</a> <br/>
<li><a href="#tth_sEc12">Local Classes</a> <br/>
<li><a href="#tth_sEc13">Anonymous Classes</a> <br/>
</ul>

<div class="p"><!----></div>
 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 8 </a><br />Classes</h1>
<a name="XtenClasses">
</a>
<a name="ReferenceClasses">
</a>

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Principles of X10 Objects</h2><a name="XtenObjects">
</a>


<div class="p"><!----></div>
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Basic Design</h3>

<div class="p"><!----></div>
Objects are instances of classes: the most common and most powerful sort of
value in X10.  The other kinds of values, structs and functions, are more
specialized, better in some circumstances but not in all.
<b>x10.lang.Object</b> is the most general class; all other classes inherit
from it, directly or indirectly. 

<div class="p"><!----></div>
Classes are structured in a single-inheritance code
hierarchy.   They may have any or all of these features: 

<ul>
<li> Implementing any number of interfaces;
<div class="p"><!----></div>
</li>

<li> Static and instance <b>val</b> fields;
<div class="p"><!----></div>
</li>

<li> Instance <b>var</b> fields;
<div class="p"><!----></div>
</li>

<li> Static and instance methods;
<div class="p"><!----></div>
</li>

<li> Constructors;
<div class="p"><!----></div>
</li>

<li> Properties;
<div class="p"><!----></div>
</li>

<li> Static and instance nested containers.
<div class="p"><!----></div>
</li>

<li> Static type definitions
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
X10 objects (unlike Java objects) do not have locks associated with them.
Programmers may use atomic blocks (&#167;) for mutual
exclusion and clocks (&#167;) for sequencing multiple parallel
operations.

<div class="p"><!----></div>
An object exists in a single location: the place that it was created.  One
place cannot use or even directly refer to an object in a different place.   A
special type, <b>GlobalRef[T]</b>, allows explicit cross-place references. 

<div class="p"><!----></div>
The basic operations on objects are:

<ul>
<li> Construction (&#167;).  Objects are created, 
      their <b>var</b> and <b>val</b> fields initialized, and other invariants
      established.
<div class="p"><!----></div>
</li>

<li> Field access (&#167;). 
The static, instance, and property fields of an object can be retrieved; <b>var</b> fields
can be set.
<div class="p"><!----></div>
</li>

<li> Method invocation (&#167;).  
Static, instance, and property methods of an object can be invoked.
<div class="p"><!----></div>
</li>

<li> Casting (&#167;) and instance testing with <b>instanceof</b>
(&#167;) Objects can be cast or type-tested.
<div class="p"><!----></div>
</li>

<li> The equality operators <b>==</b> and <b>!=</b>.  
Objects can be compared for equality with the <b>==</b> operation.  This checks
object <em>identity</em>: two objects are <b>==</b> iff they are the same object.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
       <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Class Declaration Syntax</h3>

<div class="p"><!----></div>
The <em>class declaration</em> has a list of type parameters, a list of
properties, a constraint (the <em>class invariant</em>), a single superclass,
zero or more interfaces that it implements, and a class body containing the
the definition of fields, properties, methods, and member types. Each such
declaration introduces a class type (&#167;).

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">NormalClassDecl ::= Mods<sup>?</sup>&nbsp;<b>class</b> Id TypeParamsI<sup>?</sup>&nbsp;Properties<sup>?</sup>&nbsp;Guard<sup>?</sup>&nbsp;Super<sup>?</sup>&nbsp;Interfaces<sup>?</sup>&nbsp;ClassBody </td></tr>
<tr><td align="right">TypeParamsI ::= <b>[</b> TypeParamIList <b>]</b> </td></tr>
<tr><td align="right">TypeParamIList ::= TypeParamI </td></tr>
<tr><td align="right">&#124; TypeParamIList <b>,</b> TypeParamI </td></tr>
<tr><td align="right">Properties ::= <b>(</b> PropertyList <b>)</b> </td></tr>
<tr><td align="right">PropertyList ::= Property </td></tr>
<tr><td align="right">&#124; PropertyList <b>,</b> Property </td></tr>
<tr><td align="right">Property ::= Annotations<sup>?</sup>&nbsp;Id ResultType </td></tr>
<tr><td align="right">Guard ::= DepParams </td></tr>
<tr><td align="right">Super ::= <b>extends</b> ClassType </td></tr>
<tr><td align="right">Interfaces ::= <b>implements</b> InterfaceTypeList </td></tr>
<tr><td align="right">InterfaceTypeList ::= Type </td></tr>
<tr><td align="right">&#124; InterfaceTypeList <b>,</b> Type </td></tr>
<tr><td align="right">ClassBody ::= <b>{</b> ClassBodyDecls<sup>?</sup>&nbsp;<b>}</b> </td></tr>
<tr><td align="right">ClassBodyDecls ::= ClassBodyDecl </td></tr>
<tr><td align="right">&#124; ClassBodyDecls ClassBodyDecl </td></tr>
<tr><td align="right">ClassMemberDecl ::= FieldDecl </td></tr>
<tr><td align="right">&#124; MethodDecl </td></tr>
<tr><td align="right">&#124; PropertyMethodDecl </td></tr>
<tr><td align="right">&#124; TypeDefDecl </td></tr>
<tr><td align="right">&#124; ClassDecl </td></tr>
<tr><td align="right">&#124; InterfaceDecl </td></tr>
<tr><td align="right">&#124; <b>;</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Fields</h2>
<a name="FieldDefinitions">
</a>



<div class="p"><!----></div>
Objects may have <em>instance fields</em>, or simply <em>fields</em> (called
"instance variables" in C++ and Smalltalk, and "slots" in CLOS): places to
store data that is pertinent to the object.  Fields, like variables, may be
mutable (<b>var</b>) or immutable (<b>val</b>).  

<div class="p"><!----></div>
Class may have <em>static fields</em>, which store data pertinent to the
entire class of objects.  
See &#167; for more information.

<div class="p"><!----></div>
No two fields of the same class may have the same name.  A field may have the
same name as a method, although for fields of functional type there is a
subtlety (&#167;).  

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Field Initialization</h3>



<div class="p"><!----></div>
Fields may be given values via <em>field initialization expressions</em>:
<b>val f1 = E;</b> and <b>var f2 : Int = F;</b>. Other fields of <b>this</b> may
be referenced, but only those that <em>precede</em> the field being initialized.

<div class="p"><!----></div>
The following is correct, but would not be if the fields were
reversed:

<div class="p"><!----></div>
<pre>
class Fld{
  val a = 1;
  val b = 2+a;
}
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Field hiding</h3>
<a name="sect:FieldHiding">
</a>


<div class="p"><!----></div>
A subclass that defines a field <b>f</b> hides any field <b>f</b>
declared in a superclass, regardless of their types.  The
superclass field <b>f</b> may be accessed within the body of
the subclass via the reference <b>super.f</b>.

<div class="p"><!----></div>
With inner classes, it is occasionally necessary to 
write <b>Cls.super.f</b> to get at a hidden field <b>f</b> of an outer class
<b>Cls</b>. 

<div class="p"><!----></div>
The <b>f</b> field in <b>Sub</b> hides the <b>f</b> field in <b>Super</b>
The <b>superf</b> method provides access to the <b>f</b> field in <b>Super</b>.
<pre>
class Super{ 
  public val f = 1; 
}
class Sub extends Super {
  val f = true;
  def superf() : Int = super.f; // 1
}
</pre>


<div class="p"><!----></div>
Hidden fields of outer classes can be accessed by suitable forms: 
<pre>
class A {
   val f = 3;
}
class B extends A {
   val f = 4;
   class C extends B {
      // C is both a subclass and inner class of B
      val f = 5;
       def example() {
         assert f         == 5 : "field of C";
         assert super.f   == 4 : "field of superclass";
         assert B.this.f  == 4 : "field of outer instance";
         assert B.super.f == 3 : &#223;uper.f of outer instance";
       }
    }
}
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Field qualifiers</h3>
<a name="FieldQualifier">
</a>



<div class="p"><!----></div>
The behavior of a field may be changed by a field qualifier, such as
<b>static</b> or <b>transient</b>.  

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.3.1">
2.3.1</a>&nbsp;&nbsp;<b>static</b> qualifier</h4>


<div class="p"><!----></div>
A <b>val</b> field may be declared to be <em>static</em>, as described in
&#167;<a href="#FieldDefinitions">2</a>. 

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.3.2">
2.3.2</a>&nbsp;&nbsp;<b>transient</b> Qualifier</h4>
<a name="TransientFields">
</a>



<div class="p"><!----></div>
A field may be declared to be <em>transient</em>.  Transient fields are excluded
from the deep copying that happens when information is sent from place to
place in an <b>at</b> statement.    The value of a transient field of a copied
object is the default value of its type, regardless of the value of the field
in the original.  If the type of a field has no
default value, it cannot be marked <b>transient</b>.

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
<pre>
class Trans { 
   val copied = "copied";
   transient var transy : String = &#228; very long string";
   def example() {
      at (here) { // causes copying of 'this'
         assert(this.copied.equals("copied"));
         assert(this.transy == null);
      }
   }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Properties</h2>
<a name="PropertiesInClasses">
</a>


<div class="p"><!----></div>
The properties of an object (or struct) are  public <b>val</b> fields
usable at compile time in constraints.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a> 
For example,  every array has a <b>rank</b> telling
how many subscripts it takes.  User-defined classes can have whatever
properties are desired. 

<div class="p"><!----></div>
Properties are defined in parentheses, after the name of the class.  They are
given values by the <b>property</b> command in constructors.

<div class="p"><!----></div>
<b>Proper</b> has a single property, <b>t</b>.  <b>new Proper(4)</b> creates a
<b>Proper</b> object with <b>t==4</b>. 
<pre>
class Proper(t:Int) {
  def this(t:Int) {property(t);}
}
</pre>

<div class="p"><!----></div>
It is a static error for a class
defining a property <b>x: T</b> to have a subclass class that defines
a property or a field with the name <b>x</b>.

<div class="p"><!----></div>
A property <b>x:T</b> induces a field with the same name and type, 
as if defined with: 
<pre>
public val x : T;
</pre>

<div class="p"><!----></div>
Properties are initialized in a constructor by the invocation of a special <b>property</b>
statement. The requirement to use the <b>property</b> statement means that all properties
must be given values at the same time: a container either has its properties
or it does not.
<pre>
property(e1,..., en);
</pre>
The number and types of arguments to the <b>property</b> statement must match
the number and types of the properties in the class declaration, in order.  
Every constructor of a class with properties must invoke <b>property(...)</b>
precisely once; it is a static error if X10 cannot prove that this holds.

<div class="p"><!----></div>
By construction, the graph whose nodes are values and whose edges are
properties is acyclic.  <em>E.g.</em>, there cannot be values <b>a</b> and <b>b</b> with
properties <b>c</b> and <b>d</b> such that <b>a.c == b</b> and <b>b.d == a</b>.

<div class="p"><!----></div>
<pre>
class Proper(a:Int, b:String) {
  def this(a:Int, b:String) {
      property(a, b);
  }
  def this(z:Int) {
      val theA = z+5;
      val theB = "X"+z;
      property(theA, theB);
  }
  static def example() {
      val p = new Proper(1, &#246;ne");
      assert p.a == 1 &amp;&amp; p.b.equals(&#246;ne");
      val q = new Proper(10);
      assert q.a == 15 &amp;&amp; q.b.equals("X10");
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Properties and Fields</h3>

<div class="p"><!----></div>
A container with a property named <b>p</b>, or a nullary property method named
<b>p()</b>, cannot have a field named <b>p</b> - either defined in that
container, or inherited from a superclass.

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Acyclicity of Properties</h3>


<div class="p"><!----></div>
X10 has certain restrictions that, ultimately, require that properties are
simpler than their containers.  For example, <b>class A(a:A)</b> is not
allowed.  
Formally, this requirement is that there is  a total order &le; 
on all classes and
structs such that, if A extends B, then A &lt; B, and
if A has a property of type B, then A &lt; B, where A &lt; B means
A &le; B and A  &#8800; B.   
For example, the preceding class <b>A</b> is ruled out because we would need
<b>A</b>&lt;<b>A</b>, which violates the definition of &lt;.
The programmer need not (and cannot) specify
&le;, and rarely need worry about its existence.  

<div class="p"><!----></div>
Similarly, 
the type of a property may not simply be a type parameter.  
For example, <b>class A[X](x:X)</b> is illegal.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Methods</h2>






<div class="p"><!----></div>
As is common in object-oriented languages, objects can have <em>methods</em>, of
two sorts.  <em>Static methods</em> are functions, conceptually associated with a
class and defined in its namespace.  <em>Instance methods</em> are parameterized
code bodies associated with an instance of the class, which execute with
convenient access to that instance's fields. 

<div class="p"><!----></div>
Each method has a <em>signature</em>, telling what arguments it accepts, what
type it returns, and what precondition it requires. Method definitions may be
overridden by subclasses; the overriding definition may have a declared return
type that is a subtype of the return type of the definition being overridden.
Multiple methods with the same name but different signatures may be provided


on a class (called "overloading" or "ad hoc polymorphism"). Methods may be
declared <b>public</b>, <b>private</b>, <b>protected</b>, or given default package-level access
rights.

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">MethMods ::= Mods<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; MethMods <b>property</b>  </td></tr>
<tr><td align="right">&#124; MethMods Mod </td></tr>
<tr><td align="right">MethodDecl ::= MethMods <b>def</b> Id TypeParams<sup>?</sup>&nbsp;Formals Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> BinOp <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>this</b> BinOp <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> BinOp <b>this</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>this</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;Formals Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;Formals <b>=</b> <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> <b>as</b> Type Guard<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> <b>as</b> <b>?</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">TypeParams ::= <b>[</b> TypeParamList <b>]</b> </td></tr>
<tr><td align="right">Formals ::= <b>(</b> FormalList<sup>?</sup>&nbsp;<b>)</b> </td></tr>
<tr><td align="right">FormalList ::= Formal </td></tr>
<tr><td align="right">&#124; FormalList <b>,</b> Formal </td></tr>
<tr><td align="right">HasResultType ::= <b>:</b> Type </td></tr>
<tr><td align="right">&#124; <b>&lt;:</b> Type </td></tr>
<tr><td align="right">MethodBody ::= <b>=</b> LastExp <b>;</b> </td></tr>
<tr><td align="right">&#124; <b>=</b> Annotations<sup>?</sup>&nbsp;<b>{</b> BlockStatements<sup>?</sup>&nbsp;LastExp <b>}</b> </td></tr>
<tr><td align="right">&#124; <b>=</b> Annotations<sup>?</sup>&nbsp;Block </td></tr>
<tr><td align="right">&#124; Annotations<sup>?</sup>&nbsp;Block </td></tr>
<tr><td align="right">&#124; <b>;</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A formal parameter may have a <b>val</b> or <b>var</b>
modifier; <b>val</b> is the default.
The body of the method is executed in an environment in which 
each formal parameter corresponds to a local variable (<b>var</b> iff the
formal parameter is <b>var</b>)
and is initialized with the value of the actual parameter.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Forms of Method Definition</h3>

<div class="p"><!----></div>
There are several syntactic forms for definining methods.   The forms that
include a block, such as <b>def m()S</b>, allow an arbitrary block.  These
forms can define a <b>void</b> method, which does not return a value. 

<div class="p"><!----></div>
The
forms that include an expression, such as <b>def m()=E</b>, require a
syntactically and semantically valid expression.   These forms cannot define a
<b>void</b> method, because expressions cannot be <b>void</b>.  

<div class="p"><!----></div>
There are no other semantic differences between the two forms. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Method Return Types</h3>

<div class="p"><!----></div>
A method with an explicit return type returns that type.
A method without an
explicit return type is given a return type by type inference.
A <em>call</em> to a method has type given by substituting information about the
actual <b>val</b> parameters for the formals.

<div class="p"><!----></div>
In the example below, <b>met1</b> has an explicit return type <b>Retn==a</b>.
<b>met2</b> does not, so its return type is computed, also to be
<b>Retn==a</b>, because that's what the implicitly-defined constructor 
returns.

<div class="p"><!----></div>
<b>use3</b> requires that its argument have <b>n==3</b>.  
<b>example</b> shows that both <b>met1</b> and <b>met2</b> can be used to produce
such an object.  In both cases, the actual argument <b>3</b> is substituted for
the formal argument <b>a</b> in the return type expression for the method
<b>Retn==a</b>, giving the type <b>Retn==3</b> as required by <b>use3</b>.

<div class="p"><!----></div>
<pre>
class Ret(n:Int) {
  static def met1(a:Int) : Ret{n==a} = new Ret(a);
  static def met2(a:Int)             = new Ret(a);
  static def use3(Ret{n==3}) {}
  static def example() {
     use3(met1(3));
     use3(met2(3));
  }  
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Final Methods</h3>


An instance method may be given the <b>final</b> qualifier.  <b>final</b>
methods may not be overridden.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Generic Instance Methods</h3>


<div class="p"><!----></div>
<b>Limitation: </b>
In X10, an instance method may be generic: 
<pre>
class Example {
  def example[T](t:T) = &#207; like " + t;
}
</pre>

<div class="p"><!----></div>
However, the C++ back end does not currently support generic virtual instance
methods like <b>example</b>.  It does allow generic instance methods which are
<b>final</b> or <b>private</b>, and it does allow generic static methods.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Method Guards</h3>
<a name="MethodGuard">
</a>



<div class="p"><!----></div>
Often, a method will only make sense to invoke under certain
statically-determinable conditions.  These conditions may be expressed as a
guard on the method.

<div class="p"><!----></div>
For example, <b>example(x)</b> is only
well-defined when <b>x != null</b>, as <b>null.toString()</b> throws a null
pointer exception: 
<pre>
class Example {
   var f : String = "";
   def setF(x:Object){x != null} = {
      this.f = x.toString();
   }
}
</pre>

(We could have used a constrained type <b>Object{self!=null}</b> for <b>x</b>
instead; in
most cases it is a matter of personal preference or convenience of expression
which one to use.) 


<div class="p"><!----></div>
The requirement of having a method guard 
is that callers must demonstrate to
the X10
compiler that the guard is satisfied.  
With the <b>STATIC_CHECKS</b> compiler option in force (&#167;), this is
checked at compile time. 
As usual with static constraint
checking, there is no runtime cost.  Indeed, this code can be more efficient
than usual, as it is statically provable that <b>x != null</b>.

<div class="p"><!----></div>
When <b>STATIC_CHECKS</b> is not in force, dynamic checks are generated as
needed; method guards are checked at runtime. This is potentially more
expensive, but may be more convenient. 

<div class="p"><!----></div>
The following code fragment contains a line which will not compile 
with <b>STATIC_CHECKS</b> on (assuming the guarded <b>example</b> method above).  (X10's type system does not attempt to propagate 
information from <b>if</b>s.)  It will compile with <b>STATIC_CHECKS</b> off,
but it may insert an extra <b>null</b>-test for <b>x</b>.  
<pre>
  def exam(e:Example, x:Object) {
    if (x != null) 
       e.example(x as Object{x != null});
       // If STATIC_CHECKS is in force: 
       // ERROR: if (x != null) e.example(x); 
  }
</pre>


<div class="p"><!----></div>
The guard <b>{c}</b> 
in a guarded method 
<b>def m(){c} = E;</b>
specifies a constraint <b>c</b> on the
properties of the class <b>C</b> on which the method is being defined. The
method, in effect, only exists  for those instances of <b>C</b> which satisfy
<b>c</b>.  It is 
illegal for code to invoke the method on objects whose static type is
not a subtype of <b>C{c}</b>.

<div class="p"><!----></div>
Specifically: 
    the compiler checks that every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    is type correct. Each argument
    &#235;<sub>i</sub>" must have a
    static type "S<sub>i</sub>" that is a subtype of the declared type
    "T<sub>i</sub>" for the ith
    argument of the method, and the conjunction of the constraints on the
    static types 
    of the arguments must entail the guard in the parameter list
    of the method.

<div class="p"><!----></div>
    The compiler checks that in every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    the static type of <b>o</b>, <b>S</b>, is a subtype of <b>C{c}</b>, where the method
    is defined in class <b>C</b> and the guard for <b>m</b> is equivalent to
    <b>c</b>.

<div class="p"><!----></div>
    Finally, if the declared return type of the method is
    <b>D{d}</b>, the
    return type computed for the call is
    "D{a: S; x<sub>1</sub>: S<sub>1</sub>; ...; x<sub>n</sub>: S<sub>n</sub>; d[a/this]}",
    where <b>a</b> is a new
    variable that does not occur in
    "d, S, S<sub>1</sub>, ..., S<sub>n</sub>", and
    "x<sub>1</sub>, ..., x<sub>n</sub>" are the formal
    parameters of the method.

<div class="p"><!----></div>
<b><b>Limitation: </b></b> 
Using a reference to an outer class, <b>Outer.this</b>, in a constraint, is not supported.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;Property methods</h3>



<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">PropertyMethodDecl ::= MethMods Id TypeParams<sup>?</sup>&nbsp;Formals Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods Id Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Property methods are methods that can be evaluated in constraints, as
properties can.   They provide a means of abstraction over properties; <em>e.g.</em>,
interfaces can specify property methods that implementing containers must
provide, but, just as they cannot specify ordinary fields, they cannot specify
property fields.   Property methods are very limited in computing power: they
must obey the same restrictions as constraint expressions.  In particular,
they cannot have side effects, or even much code in their bodies.

<div class="p"><!----></div>
The <b>eq()</b> method below tells if the <b>x</b> and <b>y</b>
properties are equal; the <b>is(z)</b> method tells if they are both equal to
<b>z</b>.  
The <b>eq</b> and <b>is</b> property methods are used in types in the
<b>example</b> method.
<pre>
class Example(x:Int, y:Int) {
   def this(x:Int, y:Int) { property(x,y); }
   property eq() = (x==y);
   property is(z:Int) = x==z &amp;&amp; y==z;
   def example( a : Example{eq()}, b : Example{is(3)} ) {}
}
</pre>


<div class="p"><!----></div>
A property method declared in a class must have
a body and must not be <b>void</b>.  The body of the method must
consist of only a single <b>return</b> statement with an expression,  or a single
expression.  It is a static error if the expression cannot be
represented in the constraint system.   Property methods may be <b>abstract</b>
in <b>abstract</b> classes, and may be specified in interfaces, but are
implicitly <b>final</b> in 
non-<b>abstract</b> classes. 

<div class="p"><!----></div>
The expression may contain invocations of other property methods.  The
compiler ensures that there are no circularities in property methods, so
property method evaluations always terminate.

<div class="p"><!----></div>
Property methods in classes are implicitly <b>final</b>; they cannot be
overridden.  It is a static error if a superclass has a property method with a
given signature, and a subclass has a method or property method with the same
signature.   It is a static error if a superclass has a property with some
name <b>p</b>, and a subclass has a nullary method of any kind (instance,
static, or property) also named <b>p</b>. 

<div class="p"><!----></div>
A nullary property method definition may omit 
the <b>def</b> keyword.  That is, the following are equivalent:

<div class="p"><!----></div>
<pre>
property def rail(): Boolean = 
   rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
</pre>
and
<pre>
property rail(): Boolean = 
   rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
</pre>

<div class="p"><!----></div>
Similarly, nullary property methods can be inspected in constraints without
<b>()</b>. If <b>ob</b>'s type has a property <b>p</b>, then <b>ob.p</b> is that
property. Otherwise, if it has a nullary property method <b>p()</b>, <b>ob.p</b>
is equivalent to <b>ob.p()</b>. As a consequence, if the type provides both a
property <b>p</b> and a nullary method <b>p()</b>, then the property can be
accessed as <b>ob.p</b> and the method as <b>ob.p()</b>.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>

<div class="p"><!----></div>
<b>w.rail</b>, with either definition above, 
is equivalent to 
<b>w.rail()</b>

<div class="p"><!----></div>
      <h4><a name="tth_sEc4.6.1">
4.6.1</a>&nbsp;&nbsp;Limitation of Property Methods</h4>

<div class="p"><!----></div>
<b>Limitation: </b> 
Currently, X10 forbids the use of property methods which have all the
following features: 

<ul>
<li> they are abstract, and
<div class="p"><!----></div>
</li>

<li> they have one or more arguments, and
<div class="p"><!----></div>
</li>

<li> they appear as subterms in constraints.
<div class="p"><!----></div>
</li>
</ul>
Any two of these features may be combined, but the three together may not be. 

<div class="p"><!----></div>
 The constraint in <b>example1</b> is concrete, not abstract.  The constraint in
<b>example2</b> is nullary, and has no arguments.  The constraint in
<b>example3</b> appears at the top level, rather than as a subterm (<em>cf.</em>
the equality expressions <b>A==B</b> in the other examples).    However,
<b>example4</b> combines all three features, and is not allowed.
<pre>
class Cls {
  property concrete(a:Int) = 7;
}
interface Inf {
  property nullary(): Int;
  property topLevel(z:Int):Boolean;
  property allThree(z:Int):Int;
}
class Example{
  def example1(Cls{self.concrete(3)==7}) = 1;
  def example2(Inf{self.nullary()==7})   = 2;
  def example3(Inf{self.topLevel(3)})    = 3;
  //ERROR: def example4(Inf{self.allThree(3)==7}) = "fails";
}
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;Method overloading, overriding, hiding, shadowing and obscuring</h3>
<a name="MethodOverload">
</a>


<div class="p"><!----></div>
The definitions of method overloading, overriding, hiding, shadowing and
obscuring in X10 are familiar from languages such as Java, modulo the
following considerations motivated by type parameters and dependent types.

<div class="p"><!----></div>
Two or more methods of a class or interface may have the same
name if they have a different number of type parameters, or
they have formal parameters of different constraint-erased types (in some instantiation of the
generic parameters). 

<div class="p"><!----></div>
The following overloading of <b>m</b> is unproblematic.
<pre>
class Mful{
   def m() = 1;
   def m[T]() = 2;
   def m(x:Int) = 3;
   def m[T](x:Int) = 4;
}
</pre>


<div class="p"><!----></div>
A class definition may include methods which are ambiguous in <em>some</em>
generic instantiation. (It is a compile-time error if the methods are
ambiguous in <em>every</em> generic instantiation, but excluding class
definitions which are are ambiguous in <em>some</em> instantiation would exclude
useful cases.)  It is a compile-time error to <em>use</em> an ambiguous method
call. 

<div class="p"><!----></div>
The following class definition is acceptable.  However, the marked method
calls are ambiguous, and hence not acceptable.
<pre>
class Two[T,U]{
  def m(x:T)=1;
  def m(x:Int)=2;
  def m[X](x:X)=3;
  def m(x:U)=4;
  static def example() {
    val t12 = new Two[Int, Any]();
    // ERROR: t12.m(2);
    val t13  = new Two[String, Any]();
    t13.m("ferret");
    val t14 = new Two[Boolean,Boolean]();
    // ERROR: t14.m(true);
  }
}
</pre>

The call <b>t12.m(2)</b> could refer to either the <b>1</b> or <b>2</b>
definition of <b>m</b>, so it is not allowed.   
The call <b>t14.m(true)</b> could refer to either the <b>1</b> or <b>4</b>
definition, so it, too, is not allowed.

<div class="p"><!----></div>
The call <b>t13.m("ferret")</b> refers only to the <b>1</b> definition.  If
the <b>1</b> definition were absent, type argument inference would make it
refer to the <b>3</b> definition.  However, X10 will choose a fully-specified
call if there is one, before trying type inference, so this call unambiguously
refers to <b>1</b>.


<div class="p"><!----></div>
X10 v2.2 does not permit overloading based on constraints. That is, the
following is <em>not</em> legal, although either method definition individually
is legal:
<pre>
   def n(x:Int){x==1} = &#246;ne";
   def n(x:Int){x!=1} = "not";
</pre>

<div class="p"><!----></div>
The definition of a method declaration "m<sub>1</sub>" "having the same signature
as" a method declaration "m<sub>2</sub>" involves identity of types. 

<div class="p"><!----></div>
The <em>constraint erasure</em> of a type "T", 
"ce(T)",
is obtained by removing all the constraints outside of functions in <b>T</b>,
specificially: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
ce(<tt>T</tt>) = <tt>T</tt>  <span class="roman">if</span> <b><b>T</b></b> <span class="roman">is</span> <span class="roman">a</span> <span class="roman">container</span> <span class="roman">or</span> <span class="roman">interface</span></td></tr></table></td><td width="50%"></td><td width="1" align="right">(1)</td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
ce(<tt>T</tt>{<tt>c</tt>}) = ce(<tt>T</tt>)</td></tr></table></td><td width="50%"></td><td width="1" align="right">(2)</td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
ce(<tt>T</tt><tt>[</tt><tt>S</tt><sub>1</sub><tt>,</tt>&#8230;<tt>,</tt><tt>S</tt><sub>n</sub><tt>]</tt>) =ce(<tt>T</tt>)<tt>[</tt> ce(<tt>S</tt><sub>1</sub>)<tt>,</tt>&#8230;<tt>,</tt> ce(<tt>S</tt><sub>n</sub>)<tt>]</tt></td></tr></table></td><td width="50%"></td><td width="1" align="right">(3)</td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table><tr><td nowrap="nowrap" align="right" colspan="1">ce(<tt>(</tt><tt>S</tt><sub>1</sub><tt>,</tt>&#8230;<tt>,</tt><tt>S</tt><sub>n</sub><tt>)</tt><tt> = </tt> &gt;  <tt>T</tt>) =<tt>(</tt> ce(<tt>S</tt><sub>1</sub>)<tt>,</tt>&#8230;<tt>,</tt> ce(<tt>S</tt><sub>n</sub>)<tt>)</tt><tt> = </tt> &gt;   ce(<tt>T</tt>)</td></tr></table></td><td width="50%"></td><td width="1" align="right">(4)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
 Two methods are said to have <em>erasedly equivalent signatures</em> if (a) they have the
 same number of type parameters, 
(b) they have the same number of formal (value) parameters, and (c)
for each formal parameter the constraint erasure of its types are erasedly equivalent.
It is a 
compile-time error for there to be two methods with the same name and
erasedly equivalent signatures in a class (either defined in that class or in a
superclass), unless the signatures are identical (without erasures) and one of the methods is
defined in a superclass (in which case the superclass's method is overridden
by the subclass's, and the subclass's method's return type must be a subtype of
the superclass's method's return type).  

<div class="p"><!----></div>
 In addition, the guard of an overridden method
must entail
the guard of the overriding method.   This
ensures that any virtual call to the method
satisfies the guard of the callee.

<div class="p"><!----></div>
In the following example, the call to <b>s.recip(3)</b> in <b>example()</b>
will invoke <b>Sub.recip(n)</b>.  The call is legitimate because
<b>Super.recip</b>'s guard, <b>n != 0</b>, is satisfied by <b>3</b>.  
The guard on <b>Sub.recip(n)</b> is simply
<b>true</b>, which is also satisfied.  However, if we had used the <b>ERROR</b>
line's definition, the guard on <b>Sub.recip(n)</b> would be <b>n != 0, n != 3</b>, which
is not satisfied by <b>3</b>, so - despite the call statically type-checking
- at runtime the call would violate its guard and (in this case) throw an exception.
<pre>
class Super {
  def recip(n:Int){n != 0} = 1.0/n;
}
class Sub extends Super{
  //ERROR: def recip(n:Int){n != 0, n != 3} = 1.0/(n * (n-3));
  def recip(n:Int){true} = 1.0/n;
}
class Example{
  static def example() {
     val s : Super = new Sub();
     s.recip(3);
  }
}
</pre>

<div class="p"><!----></div>
  If a class <b>C</b> overrides a method of a class or interface
  <b>B</b>, the guard of the method in <b>B</b> must entail
  the guard of the method in <b>C</b>.

<div class="p"><!----></div>
A class <b>C</b> inherits from its direct superclass and superinterfaces all
their methods visible according to the access modifiers
of the superclass/superinterfaces that are not hidden or overridden. A method "M<sub>1</sub>" in a class
<b>C</b> overrides
a method  in a superclass <b>D</b> if
"M<sub>1</sub>" and "M<sub>2</sub>" have erasedly equivalent signatures.
Methods are overriden on a signature-by-signature basis.  It is a compile-time
error if an instance method overrides a static method.  (But is it permitted
for an instance <em>field</em> to hide a static <em>field</em>; that's hiding
(&#167;<a href="#sect:FieldHiding">2.2</a>), not 
overriding, and hence totally different.)

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Constructors</h2>
<a name="sect:constructors">
</a>


<div class="p"><!----></div>
Instances of classes are created by the <b>new</b> expression: <br />

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">ClassInstCreationExp ::= <b>new</b> TypeName TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; Primary <b>.</b> <b>new</b> Id TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&#124; ValueOrTypeName <b>.</b> <b>new</b> Id TypeArgs<sup>?</sup>&nbsp;<b>(</b> ArgumentList<sup>?</sup>&nbsp;<b>)</b> ClassBody<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
This constructs a new object, and calls some code, called a <em>constructor</em>,
to initialize the newly-created object properly.

<div class="p"><!----></div>
Constructors are defined like methods, except that they must be named <b>this</b>
and ordinary methods may not be.    The content of a constructor body has
certain capabilities (<em>e.g.</em>, <b>val</b> fields of the object may be initialized)
and certain restrictions (<em>e.g.</em>, most methods cannot be called); see
&#167; for the details.

<div class="p"><!----></div>
The following class provides two constructors.  The unary constructor 
<b>def this(b : Int)</b> allows initialization of the <b>a</b> field to an 
arbitrary value.  The nullary constructor <b>def this()</b> gives it a default
value of 10.  The <b>example</b> method illustrates both of these calls.

<div class="p"><!----></div>
<pre>
class C {
  public val a : Int;
  def this(b : Int) { a = b; } 
  def this()        { a = 10; }
  static def example() {
     val two = new C(2);
     assert two.a == 2;
     val ten = new C(); 
     assert ten.a == 10;
  }
}
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Automatic Generation of Constructors</h3>


<div class="p"><!----></div>
Classes that have no constructors written in the class declaration are
automatically given a constructor which sets the class properties and does
nothing else. If this automatically-generated constructor is not valid (<em>e.g.</em>,
if the class has <b>val</b> fields that need to be initialized in a
constructor), the class has no constructor, which is a static error.

<div class="p"><!----></div>
The following class has no explicit constructor.
Its implicit constructor is 
<b>def this(x:Int)property(x);</b>
This implicit constructor is valid, and so is the class. 
<pre>
class C(x:Int) {
  static def example() {
    val c : C = new C(4);
    assert c.x == 4;
  }
}
</pre>
 

<div class="p"><!----></div>
The following class has the same default constructor.  However, that
constructor does not initialize <b>d</b>, and thus is invalid.  This 
class does not compile; it needs an explicit constructor.
<pre>
// THIS CODE DOES NOT COMPILE
class Cfail(x:Int) {
  val d: Int;
  static def example() {
    val wrong = new Cfail(40);
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Calling Other Constructors</h3>
<a name="sect:call-another-ctor">
</a>

<div class="p"><!----></div>
The <em>first</em> statement of a constructor body may be a call of the form 
<b>this(a,b,c)</b> or <b>super(a,b,c)</b>.  The former will execute the body of
the matching constructor of the current class; the latter, of the superclass. 
This allows a measure of abstraction in constructor definitions; one may be
defined in terms of another.

<div class="p"><!----></div>
The following class has two constructors.  <b>new Ctors(123)</b> constructs a
new <b>Ctors</b> object with parameter 123.  <b>new Ctors()</b> constructs one
whose parameter has a default value of 100: 
<pre>
class Ctors {
  public val a : Int;
  def this(a:Int) { this.a = a; }
  def this()      { this(100);  }
}
</pre>


<div class="p"><!----></div>
In the case of a class which implements <b>operator ()</b> 
- or any other constructor and application with the same signature - 
this can be ambiguous.  If <b>this()</b> appears as the first statement of a
constructor body, it could, in principle, mean either a constructor call or an
operator evaluation.   This ambiguity is resolved so that <b>this()</b> always
means the constructor invocation.  If, for some reason, it is necessary to
invoke an application operator as the first meaningful statement of a
constructor, write the target of the application as <b>(this)</b>, <em>e.g.</em>,
<b>(this)(a,b);</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Return Type of Constructor</h3>

<div class="p"><!----></div>
A constructor for class <b>C</b> may have a return type <b>C{c}</b>.  The return
type specifies a constraint on the kind of object returned.  It cannot change
its <em>class</em> - a constructor for class <b>C</b> always returns an instance
of class <b>C</b>.  
If no explicit return type is specified, the constructor's return type is
inferred.

<div class="p"><!----></div>
The constructor <b>(A)</b> below, having no explicit return type, 
has its return type inferred.  
<b>n</b> is set by the <b>property</b> statement to <b>1</b>, so the return type
is inferred as <b>Ret{self.n==1}.</b>
The constructor <b>(B)</b> has <b>Retn==self.n</b> as an explicit return type.
The <b>example()</b> code shows both of these in action.

<div class="p"><!----></div>
<pre>
class Ret(n:Int) {
   def this()    { property(1); }     // (A)
   def this(n:Int) : Ret{n==self.n} { // (B)
      property(n);
   }
   static def typeIs[T](x:T){}
   static def example() {
     typeIs[Ret{self.n==1}](new Ret());  // uses (A)
     typeIs[Ret{self.n==3}](new Ret(3)); // uses (B)
   }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Static initialization</h2>
<a name="StaticInitialization">
</a>

The X10 runtime implements the following procedure to ensure
reliable initialization of the static state of classes.

<div class="p"><!----></div>
Execution (of an entire X10 program) commences with a single thread executing
the 
<em>initialization</em> phase of an X10 computation at place <b>0</b>. This
phase must complete successfully before the body of the <b>main</b> method is
executed.

<div class="p"><!----></div>
The initialization phase should be thought of as if it is implemented in
the following fashion. (The implementation may do something more
efficient as long as it is faithful to this semantics.)

<div class="p"><!----></div>
<pre>
finish
   for every static field f of every class C 
      (with type T and initializer e):
   async {
     val l = e; 
     ateach (Dist.makeUnique()) {
        assign l to the static f field of 
            the local C class object;
        mark the f field of the local C 
            class object as initialized;
     }
   }
</pre>

<div class="p"><!----></div>
During this phase, any read of a static field <b>C.f</b> (where <b>f</b> is of type <b>T</b>)
is replaced by a call to the method <b>C.read_f():T</b> defined on class <b>C</b>
as follows

<div class="p"><!----></div>
<pre>
def read_f():T {
   when (initialized(C.f)){};
   return C.f;
}
</pre>

<div class="p"><!----></div>
If all these activities terminate normally, all static fields have values of
their declared types, 
and the <b>finish</b> terminates normally. If
any activity throws an exception, the <b>finish</b> throws an
exception. Since no user code is executing which can catch exceptions
thrown by the finish, such exceptions are printed on the console, and
computation aborts.

<div class="p"><!----></div>
If the activities deadlock, the implementation deadlocks.

<div class="p"><!----></div>
In all cases, the main method is executed only once all static fields
have been initialized correctly.

<div class="p"><!----></div>
Since static state is immutable and is replicated to all places via 
the initialization phase as described above, it can be accessed from
any place.

<div class="p"><!----></div>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;User-Defined Operators</h2>
<a name="sect:operators">
</a>



<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">MethodDecl ::= MethMods <b>def</b> Id TypeParams<sup>?</sup>&nbsp;Formals Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> BinOp <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>this</b> BinOp <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> BinOp <b>this</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>this</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;Formals Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;Formals <b>=</b> <b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> <b>as</b> Type Guard<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> <b>as</b> <b>?</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> Formal  <b>)</b> Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a <b>Poly</b> class of
polynomials - for the sake of illustration, single-variable polynomials with
<b>Int</b> coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: <b>+</b> to add, <b>*</b> to multiply,
<b>-</b> to subtract, and <b>p(x)</b> to compute the value of the polynomial at
argument <b>x</b>.  We would like to write code thus: 

<div class="p"><!----></div>
<pre>
  public static def main(Array[String](1)):void {
     val X = new Poly([0,1]);
     val t &lt;: Poly = 7 * X + 6 * X * X * X; 
     val u &lt;: Poly = 3 + 5*X - 7*X*X;
     val v &lt;: Poly = t * u - 1;
     for( i in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Writing the same code with method calls, while possible, is far less elegant: 

<div class="p"><!----></div>
<pre>
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t &lt;: UglyPoly 
           = X.mult(7).plus(
               X.mult(X).mult(X).mult(6));  
     val u &lt;: UglyPoly 
           = const(3).plus(
               X.mult(5)).minus(X.mult(X).mult(7));
     val v &lt;: UglyPoly = t.mult(u).minus(1);
     for( i in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
</pre>

<div class="p"><!----></div>
The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as <b>1+X</b>.

<div class="p"><!----></div>
Most X10 operators can be given definitions.<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>  (However, <b>&amp;&amp;</b> and
<b>&#124;&#124;</b> 
are only short-circuiting for <b>Boolean</b> expressions; user-defined versions
of these operators have no special execution behavior.)

<div class="p"><!----></div>
The user-definable operations are (in order of precedence): <br />

<table>
<tr><td align="right">implicit type coercions</td></tr>
<tr><td align="right">postfix <b>()</b></td></tr>
<tr><td align="right"><b>as T</b></td></tr>
<tr><td align="right">these unary operators:  <b>- + ! &#126; &#124; &amp; / ^ * %</b></td></tr>
<tr><td align="right"><b>..</b></td></tr>
<tr><td align="right"><b>*      /       %      **</b></td></tr>
<tr><td align="right"><b>+</b> <b>     -</b> </td></tr>
<tr><td align="right"><b>&lt;&lt;     &#62;&#62;      &#62;&#62;&#62;    -&#62;     &lt;-     &#62;-      -&lt;      !</b></td></tr>
<tr><td align="right"><b>&#62;      </b> <b>&#62;=     </b> <b>&lt;     </b> <b>&lt;=     </b> 
<b>&#126;      !&#126;</b></td></tr>
<tr><td align="right"><b>&amp;</b> </td></tr>
<tr><td align="right"><b>^</b> </td></tr>
<tr><td align="right"><b>&#124;</b> </td></tr>
<tr><td align="right"><b>&amp;&amp;</b> </td></tr>
<tr><td align="right"><b>&#124;&#124;</b> </td></tr></table>


<div class="p"><!----></div>
Several of these operators have no standard meaning on any library type, and
are included purely for programmer convenience.  

<div class="p"><!----></div>
Many operators may be defined either in <b>static</b> or instance forms.  Those
defined in instance form are dynamically dispatched, just like an instance
method.  Those defined in static form are statically dispatched, just like a
static method.  Operators are scoped like methods; static operators are scoped
like static methods.

<div class="p"><!----></div>
<pre>
static class Trace(n:Int){
  public static operator !(f:Trace) 
      = new Trace(10 * f.n + 1);
  public operator -this = new Trace (10 * this.n + 2);
}
static class Brace extends Trace{
  def this(n:Int) { super(n); }
  public operator -this = new Brace (10 * this.n + 3);
  static def example() {
     val t = new Trace(1);
     assert (!t).n == 11;
     assert (-t).n == 12 &amp;&amp; (-t instanceof Trace);
     val b = new Brace(1);
     assert (!b).n == 11;
     assert (-b).n == 13 &amp;&amp; (-b instanceof Brace);
  }
}

<div class="p"><!----></div>
</pre>


<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Binary Operators</h3>

<div class="p"><!----></div>
Binary operators, illustrated by <b>+</b>, may be defined statically in a
container <b>A</b> as:
<pre>
static operator (b:B) + (c:C) = ...;
</pre>
Or, it may be defined as  as an instance operator by one of the forms:
<pre>
operator this + (b:B) = ...;
operator (b:B) + this = ...;
</pre>

<div class="p"><!----></div>
Defining the sum <b>P+Q</b> of two polynomials looks much like a method
definition.  It uses the <b>operator</b> keyword instead of <b>def</b>, and
<b>this</b> appears in the definition in the place that a <b>Poly</b> would
appear in a use of the operator.  So, 
<b>operator this + (p:Poly)</b> explains how to add <b>this</b> to a
<b>Poly</b> value.
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { 
    this.coeff = coeff;}
  public def degree() = coeff.size-1;
  public def  a(i:Int) 
    = (i&lt;0 &#124;&#124; i&#62;this.degree()) ? 0 : coeff(i);
  public operator this + (p:Poly) =  new Poly(
     new Array[Int](
        Math.max(this.coeff.size, p.coeff.size),
        (i:Int) =&#62; this.a(i) + p.a(i)
     )); 
  // ... 
</pre>

<div class="p"><!----></div>
The sum of a polynomial and an integer, <b>P+3</b>, looks like
an overloaded method definition.  
<pre>
   public operator this + (n : Int) 
          = new Poly([n as Int]) + this;
</pre>

<div class="p"><!----></div>
However, we want to allow the sum of an integer and a polynomial as well:
<b>3+P</b>.  It would be quite inconvenient to have to define this as a method
on <b>Int</b>; changing <b>Int</b> is far outside of normal coding.  So, we
allow it as a method on <b>Poly</b> as well.

<div class="p"><!----></div>
<pre>
   public operator (n : Int) + this 
          = new Poly([n as Int]) + this;
</pre>

<div class="p"><!----></div>
Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
<b>Poly</b>s could have been written:
<pre>
  public static operator (p:Poly) + (q:Poly) =  new Poly(
     new Array[Int](
        Math.max(q.coeff.size, p.coeff.size),
        (i:Int) =&#62; q.a(i) + p.a(i)
     ));
</pre>

<div class="p"><!----></div>
When X10 attempts to typecheck a binary operator expression like <b>P+Q</b>, it
first typechecks <b>P</b> and <b>Q</b>. Then, it looks for operator declarations
for <b>+</b> in the types of <b>P</b> and <b>Q</b>. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a <em>best-matching</em> operation, <em>viz</em> one which does
not require the operands to be converted to another type. For example,
<b>operator this + (n:Long)</b> and <b>operator this + (n:Int)</b> both apply to
<b>p+1</b>, because <b>1</b> can be converted from an <b>Int</b> to a <b>Long</b>.
However, the <b>Int</b> version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Unary Operators</h3>

<div class="p"><!----></div>
Unary operators,  illustrated by <b>!</b>, may be defined statically in
container 
<b>A</b> as 
<pre>
static operator !(x:A) = ...;
</pre>
or as instance operators by: 
<pre>
operator !this = ...;
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

<div class="p"><!----></div>
The operator to negate a polynomial is: 

<div class="p"><!----></div>
<pre>
  public operator - this = new Poly(
    new Array[Int](coeff.size, (i:Int) =&#62; -coeff(i))
    );
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Type Conversions</h3>
<a name="sect:type-conv">
</a>


<div class="p"><!----></div>
Explicit type conversions, <b>e as A</b>, can be defined as operators on
class <b>A</b>, or on the container type of <b>e</b>.  These must be static
operators.  

<div class="p"><!----></div>
To define an operator in <b>class A</b> (or <b>struct A)</b> converting values
of type <b>B</b> into type <b>A</b>, use the syntax: 
<pre>
static operator (x:B) as ? {c} = ... 
</pre>
The <b>?</b> indicates the containing type <b>A</b>.  
The guard clause <b>{c}</b> may be omitted.

<div class="p"><!----></div>
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public static operator (a:Int) as ? = new Poly([a as Int]);
  public static def main(Array[String](1)):void {
     val three : Poly = 3 as Poly;
  }
}
</pre>

The <b>?</b> may be given a bound, such as <b>as ? &lt;: Caster</b>, if desired.

<div class="p"><!----></div>
There is little difference between an explicit conversion <b>e as T</b> and a
method call <b>e.asT()</b>.  The explicit conversion does say undeniably what
the result type will be.  However, as described in &#167;,
sometimes the built-in meaning of <b>as</b> as a cast overrides the
user-defined explicit conversion.  

<div class="p"><!----></div>
Explicit casts are most suitable for cases
which resemble the use of explicit casts among the arithmetic types, where, 
for example, <b>1.0 as Int</b> is a way to turn a floating-point number into the
corresponding integer.  
While there is nothing in X10 which
requires it, <b>e as T</b> has the connotation that it gives a good
approximation of <b>e</b> in type <b>T</b>, just as <b>1</b> is a good
(indeed, perfect) approximation of <b>1.0</b> in type <b>Int</b>.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Implicit Type Coercions</h3>
<a name="sect:ImplicitCoercion">
</a>


<div class="p"><!----></div>
An implicit type conversion from <b>U</b>  to <b>T</b> may be specified in
container <b>T</b>.  
The syntax for it is: 
<pre>
static operator (u:U) : T = e;
</pre>

<div class="p"><!----></div>
Implicit coercions are used automatically by the compiler on method calls 
(&#167;) and assignments (&#167;).
Implicit coercions may be used when a value of type <b>T</b> appears in a
context expecting a value of type <b>U</b>.  If <b>T &lt;: U</b>, no implicit
coercion is needed; <em>e.g.</em>, a method <b>m</b> expecting an <b>Int</b> argument may 
be called as <b>m(3)</b>, with an argument of type <b>Int{self==3}</b>, which is
a subtype of <b>m</b>'s argument type <b>Int</b>. 
However, if it is not the case that <b>T &lt;: U</b>, but there is an implicit
coercion from <b>T</b> to <b>U</b> defined in container <b>U</b>, then this
implicit coercion will be applied.

<div class="p"><!----></div>
We can define an implicit coercion from <b>Int</b> to <b>Poly</b>,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define <b>+</b> on
two polynomials.  The
calculation <b>1+x</b> coerces <b>1</b> to a polynomial and uses polynomial
addition to add it to <b>x</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static operator (c : Int) : Poly 
     = new Poly([c as Int]);

<div class="p"><!----></div>
  public static operator (p:Poly) + (q:Poly) = new Poly(
      new Array[Int](
        Math.max(p.coeff.size, q.coeff.size),
        (i:Int) =&#62; p.a(i) + q.a(i)
     ));

<div class="p"><!----></div>
  public static def main(Array[String](1)):void {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;Assignment and Application Operators</h3>




<a name="set-and-apply">
</a>
X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The <b>Array</b>-like classes take advantage
of both of these in <b>a(i) = a(i) + 1</b>.  

<div class="p"><!----></div>
<b>a(b,c,d)</b>
is an operator call, to an operator defined with 
<b>public operator this(b:B, c:C, d:D)</b>.  It may be overloaded.
For
example, an ordered dictionary structure could allow subscripting by numbers
with <b>public operator this(i:Int)</b>, and by strings with 
<b>public operator this(s:String)</b>.  

<div class="p"><!----></div>
<b>a(i,j)=b</b> is an <b>operator</b> as well, with zero or more indices
<b>i,j</b>.  It may also be overloaded. 

<div class="p"><!----></div>
The update operations <b>a(i) += b</b> 
(for all binary operators in place of <b>+</b>)
are defined to be the same as the
corresponding <b>a(i) = a(i) + b</b>. This applies for all arities of
arguments, and all types, and all binary operations. Of course to use this,
the <b>+</b>, application and assignment <b>operator</b>s must be defined.

<div class="p"><!----></div>
The <b>Oddvec</b> class of somewhat peculiar vectors illustrates this.

<div class="p"><!----></div>
<b>a()</b> returns a string representation of the oddvec, which ordinarily
would 
be done by <b>toString()</b> instead.  
<b>a(i)</b> sensibly picks out one of the three
coordinates of <b>a</b>.
<b>a()=b</b> sets all the coordinates of <b>a</b> to <b>b</b>.
<b>a(i)=b</b> assigns to one of the
coordinates.  <b>a(i,j)=b</b> assigns different values to <b>a(i)</b> and
<b>a(j)</b>.  

<div class="p"><!----></div>
<pre>
class Oddvec {
  var v : Array[Int](1) = new Array[Int](3, (Int)=&#62;0);
  public operator this () = 
      "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public operator this () = (newval: Int) { 
    for(p in v) v(p) = newval;
  }
  public operator this(i:Int) = v(i);
  public operator this(i:Int, j:Int) = [v(i),v(j)];
  public operator this(i:Int) = (newval:Int) 
      = {v(i) = newval;}
  public operator this(i:Int, j:Int) = (newval:Int) 
      = { v(i) = newval; v(j) = newval+1;} 
  public def example() {
    this(1) = 6;   assert this(1) == 6;
    this(1) += 7;  assert this(1) == 13;
  }
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Class Guards and Invariants</h2><a name="DepType:ClassGuard">
</a>






<div class="p"><!----></div>
Classes (and structs and interfaces) may specify a <em>class guard</em>, a
constraint which must hold on all values of the class.    In the following
example, a <b>Line</b> is defined by two distinct <b>Pt</b>s<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>
<pre>
class Pt(x:Int, y:Int){}
class Line(a:Pt, b:Pt){a != b} {}
</pre>

<div class="p"><!----></div>
In most cases the class guard could be phrased as a type constraint on a property of
the class instead, if preferred.  Arguably, a symmetric constraint like two
points being different is better expressed as a class guard, rather than
asymmetrically as a constraint on one type: 
<pre>
class Line(a:Pt, b:Pt{a != b}) {}
</pre>

<div class="p"><!----></div>
<a name="DepType:TypeInvariant">
</a><a name="DepType:ClassGuardDef">
</a>With every container  or interface <b>T</b> we associate a <em>type
invariant</em> <i>inv</i>(<b>T</b>), which describes the guarantees on the
properties of values of type <b>T</b>.  

<div class="p"><!----></div>
Every value of <b>T</b> satisfies <i>inv</i>(<b>T</b>) at all times.  This
is somewhat stronger than the concept of type invariant in most languages
(which only requires that the invariant holds when no method calls are
active).  X10 invariants only concern properties, which are immutable; thus,
once established, they cannot be falsified.

<div class="p"><!----></div>
The type
invariant associated with <b>x10.lang.Any</b>
is 
<b>true</b>.

<div class="p"><!----></div>
The type invariant associated with any interface or struct <b>I</b> that extends
interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>" and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is given by:

<div class="p"><!----></div>
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) &amp;&amp;
self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
&amp;&amp; c  
</pre>

<div class="p"><!----></div>
Similarly the type invariant associated with any class <b>C</b> that
implements interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>",
extends class <b>D</b> and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is
given by the same thing with the invariant of the superclass <b>D</b> conjoined:
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) 
&amp;&amp; self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
&amp;&amp; c  
&amp;&amp; {inv}(D)
</pre>

<div class="p"><!----></div>
Note that the type invariant associated with a class entails the type
invariants of each interface that it implements (directly or indirectly), and
the type invariant of each ancestor class.
It is guaranteed that for any variable <b>v</b> of
type <b>T{c}</b> (where <b>T</b> is an interface name or a class name) the only
objects <b>o</b> that may be stored in <b>v</b> are such that <b>o</b> satisfies
<i>inv</i>(T[o/this])&#8743;c[o/self].

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Invariants for <tt>implements</tt> and <tt>extends</tt> clauses</h3><a name="DepType:Implements">
</a>
<a name="DepType:Extends">
</a>




Consider a class definition
<pre>
{<em>{</em>ClassModifiers}}<sup>{</sup>{?}}
class C(x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>){c} extends D{d}
   implements I<sub>1</sub>{c<sub>1</sub>}, ..., I<sub>k</sub>{c<sub>k</sub>}
{<em>{</em>ClassBody}}
</pre>

<div class="p"><!----></div>
These two rules must be satisfied:

<div class="p"><!----></div>

<ul>
<li> The type invariant  of <b>C</b> must entail
"c<sub>i</sub>[this/self]" for each i in {{1, ..., k}}
<div class="p"><!----></div>
</li>

<li> The return type <b>c</b> of each constructor in a class <b>C</b>
must entail the invariant "<i>inv</i>(C)".
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Invariants and constructor definitions</h3>



<div class="p"><!----></div>
A constructor for a class <b>C</b> is guaranteed to return an object of the
class on successful termination. This object must satisfy  "<i>inv</i>(C)", the
class invariant associated with <b>C</b> (&#167;<a href="#DepType:TypeInvariant">8</a>).
However,
often the objects returned by a constructor may satisfy <em>stronger</em>
properties than the class invariant. X10's dependent type system
permits these extra properties to be asserted with the constructor in
the form of a constrained type (the "return type" of the constructor):

<div class="p"><!----></div>

 
 
  
  
  
  <em>
  
<table>

<tr><td align="right">CtorDecl ::= Mods<sup>?</sup>&nbsp;<b>def</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;Formals Guard<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;CtorBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
<a name="ConstructorGuard">
</a>The parameter list for the constructor
may specify a <em>guard</em> that is to be satisfied by the parameters
to the list.

<div class="p"><!----></div>
Here is another example, constructed as a simplified 
version of <b>x10.array.Region</b>.  The <b>mockUnion</b> method 
has the type, though not the value, that a true <b>union</b> method would have.

<div class="p"><!----></div>
<pre>
class MyRegion(rank:Int) {
  static type MyRegion(n:Int)=MyRegion{rank==n};
  def this(r:Int):MyRegion(r) {
    property(r);
  }
  def this(diag:Array[Int](1)):MyRegion(diag.size){ 
    property(diag.size);
  }
  def mockUnion(r:MyRegion(rank)):MyRegion(rank) = this;
  def example() {
    val R1 : MyRegion(3) = new MyRegion([4,4,4 as Int]); 
    val R2 : MyRegion(3) = new MyRegion([5,4,1]); 
    val R3 = R1.mockUnion(R2); // inferred type MyRegion(3)
  }
}
</pre>
The first constructor returns the empty region of rank <b>r</b>.  The
second constructor takes a <b>Array[Int](1)</b> of arbitrary length
<b>n</b> and returns a <b>MyRegion(n)</b> (intended to represent the set
of points in the rectangular parallelopiped between the origin and the
<b>diag</b>.)

<div class="p"><!----></div>
The code in <b>example</b> typechecks, and <b>R3</b>'s type is inferred as
<b>MyRegion(3)</b>.  

<div class="p"><!----></div>
   Let <b>C</b> be a class with properties
   , and invariant <b>c</b>
   extending the constrained type <b>D{d}</b> (where <b>D</b> is the name of a
   class).

<div class="p"><!----></div>
   For every constructor in <b>C</b> the compiler checks that the call to
   super invokes a constructor for <b>D</b> whose return type is strong enough
   to entail <b>d</b>. Specifically, if the call to super is of the form 
     &#223;uper(e<sub>1</sub>, ..., e<sub>k</sub>)"
   and the static type of each expression &#235;<sub>i</sub>" is
   "S<sub>i</sub>", and the invocation
   is statically resolved to a constructor
"def this(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>k</sub>: T<sub>k</sub>){c}: D{d<sub>1</sub>}"
   then it must be the case that 
<pre>
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>i</sub>: S<sub>i</sub> entails x<sub>i</sub>: T<sub>i</sub>  (for i  &#8712; {1, ..., k})
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> entails c  
d<sub>1</sub>[a/self], x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> entails d[a/self]      
</pre>
 where <b>a</b> is a constant that does not appear in 
"x<sub>1</sub>: S<sub>1</sub> &#8743; ... &#8743; x<sub>k</sub>: S<sub>k</sub>".

<div class="p"><!----></div>
   The compiler checks that every constructor for <b>C</b> ensures that
   the properties "p<sub>1</sub>,..., p<sub>n</sub>" are initialized with values which satisfy
   <i>inv</i>(<b>T</b>), and its own return type <b>c'</b> as follows.  In each constructor, the
   compiler checks that the static types "T<sub>i</sub>" of the expressions &#235;<sub>i</sub>"
   assigned to "p<sub>i</sub>" are such that the following is
   true:
<pre>
p<sub>1</sub>: T<sub>1</sub>, ..., p<sub>n</sub>: T<sub>n</sub> entails {inv}(T) &#8743; c'     
</pre>

<div class="p"><!----></div>
(Note that for the assignment of &#235;<sub>i</sub>" to "p<sub>i</sub>"
to be type-correct it must be the
    case that "p<sub>i</sub>: T<sub>i</sub> &#8743; p<sub>i</sub>: P<sub>i</sub>".) 

<div class="p"><!----></div>
The compiler must check that every invocation "C(e<sub>1</sub>, ..., e<sub>n</sub>)" to a
constructor is type correct: each argument &#235;<sub>i</sub>" must have a static type
that is a subtype of the declared type "T<sub>i</sub>" for the ith
argument of the
constructor, and the conjunction of static types of the argument must
entail the constraint in the parameter list of the constructor.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;Object Initialization</h3>
<a name="ObjectInitialization">
</a>





<div class="p"><!----></div>

<div class="p"><!----></div>
X10 does object initialization safely.  It avoids certain bad things which
trouble some other languages:

<ol type="1">
<li> Use of a field before the field has been initialized.
<div class="p"><!----></div>
</li>

<li> A program reading two different values from a <b>val</b> field of a
      container.
<div class="p"><!----></div>
</li>

<li> <b>this</b> escaping from a constructor, which can cause problems as
      noted below.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
It should be unsurprising that fields must not be used before they are
initialized. At best, it is uncertain what value will be in them, as in
<b>x</b> below. Worse, the value might not even be an allowable value; <b>y</b>,
declared to be nonzero in the following example, might be zero before it is
initialized.
<pre>
// Not correct X10
class ThisIsWrong {
  val x : Int;
  val y : Int{y != 0};
  def this() {
    x10.io.Console.OUT.println("x=" + x + "; y=" + y);
    x = 1; y = 2;
  }
}
</pre>

<div class="p"><!----></div>
One particularly insidious way to read uninitialized fields is to allow
<b>this</b> to escape from a constructor. For example, the constructor could
put <b>this</b> into a data structure before initializing it, and another
activity could read it from the data structure and look at its fields:
<pre>
class Wrong {
  val shouldBe8 : Int;
  static Cell[Wrong] wrongCell = new Cell[Wrong]();
  static def doItWrong() {
     finish {
       async { new Wrong(); } // (A)
       assert( wrongCell().shouldBe8 == 8); // (B)
     }
  }
  def this() {
     wrongCell.set(this); // (C) - ILLEGAL
     this.shouldBe8 = 8; // (D)
  }
}
</pre>

In this example, the underconstructed <b>Wrong</b> object is leaked into a
storage cell at line <b>(C)</b>, and then initialized.  The <b>doItWrong</b>
method constructs a new <b>Wrong</b> object, and looks at the <b>Wrong</b>
object in the storage cell to check on its <b>shouldBe8</b> field.  One
possible order of events is the following:

<ol type="1">
<li> <b>doItWrong()</b> is called.
<div class="p"><!----></div>
</li>

<li> <b>(A)</b> is started.  Space for a new <b>Wrong</b> object is allocated.
      Its <b>shouldBe8</b> field, not yet initialized, contains some garbage
      value.
<div class="p"><!----></div>
</li>

<li> <b>(C)</b> is executed, as part of the process of constructing a new
      <b>Wrong</b> object.  The new, uninitialized object is stored in
      <b>wrongCell</b>.
<div class="p"><!----></div>
</li>

<li> Now, the initialization activity is paused, and execution of the main activity
      proceeds from <b>(B)</b>.
<div class="p"><!----></div>
</li>

<li> The value in <b>wrongCell</b> is retrieved, and is <b>shouldBe8</b> field
      is read.  This field contains garbage, and the assertion fails.
<div class="p"><!----></div>
</li>

<li> Now let the initialization activity proceed with <b>(D)</b>,
      initializing <b>shouldBe8</b> - too late.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The <b>at</b> statement (&#167;) introduces the potential for
escape as well. The following class prints an uninitialized value: 
<pre>
// This code violates this chapter's constraints
// and thus will not compile in X10.
class Example {
  val a: Int;
  def this() { 
    at(here.next()) {
      // Recall that 'this' is a copy of 'this' outside 'at'.
      Console.OUT.println("this.a = " + this.a);
    }
    this.a = 1;
  }
}
</pre>

<div class="p"><!----></div>
X10 must protect against such possibilities.  The rules explaining how
constructors can be written are somewhat intricate; they are designed to allow
as much programming as possible without leading to potential problems.
Ultimately, they simply are elaborations of the fundamental principles that
uninitialized fields must never be read, and <b>this</b> must never be leaked.

<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.4">
8.4</a>&nbsp;&nbsp;Constructors and Non-Escaping Methods</h3>

<a name="sect:nonescaping">
</a>

<div class="p"><!----></div>
In general, constructors must not be allowed to call methods with <b>this</b> as
an argument or receiver. Such calls could leak references to <b>this</b>,
either directly from a call to <b>cell.set(this)</b>, or indirectly because
<b>toString</b> leaks <b>this</b>, and the concatenation
`&#203;scaper = "+this` calls <b>toString</b>.<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>
<pre>
// This code violates this chapter's constraints
// and thus will not compile in X10.
class Escaper {
  static val Cell[Escaper] cell = new Cell[Escaper]();
  def toString() {
    cell.set(this);
    return &#203;vil!";
  }
  def this() {
    cell.set(this);
    x10.io.Console.OUT.println(&#203;scaper = " + this);
  }
}
</pre>

<div class="p"><!----></div>
However, it is convenient to be able to call methods from constructors; <em>
e.g.</em>, a class might have eleven constructors whose common behavior is best
described by three methods.
Under certain stringent conditions, it <em>is</em>
safe to call a method: the method called must not leak references to
<b>this</b>, and must not read <b>val</b>s or <b>var</b>s which might not have
been assigned.

<div class="p"><!----></div>
So, X10 performs a static dataflow analysis, sufficient to guarantee that
method calls in constructors are safe.  This analysis requires having access
to or guarantees about all the code that could possibly be called.  This can
be accomplished in two ways:

<ol type="1">
<li> Ensuring that only code from the class itself can be called, by
      forbidding overriding of
      methods called from the constructor: they can be marked <b>final</b> or
      <b>private</b>, or the whole class can be <b>final</b>.
<div class="p"><!----></div>
</li>

<li> Marking the methods called from the constructor by
      <b>@NonEscaping</b> or <b>@NoThisAccess</b>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.4.1">
8.4.1</a>&nbsp;&nbsp;Non-Escaping Methods</h4>








<div class="p"><!----></div>
A method may be annotated with <b>@NonEscaping</b>.  This
imposes several restrictions on the method body, and on all methods overriding
it.  However, it is the only way that a method can be called from
constructors.  The
<b>@NonEscaping</b> annotation makes explicit all the X10 compiler's needs for
constructor-safety.

<div class="p"><!----></div>
A method can, however, be safe to call from constructors without being marked
<b>@NonEscaping</b>. We call such methods <em>implicitly non-escaping</em>.
Implicitly non-escaping methods need to obey the same constraints on
<b>this</b>, <b>super</b>, and variable usage as <b>@NonEscaping</b> methods. An
implicitly non-escaping method <em>could</em> be marked as
<b>@NonEscaping</b>; the compiler, in
effect, infers the annotation. In addition, all non-escaping methods
must be <b>private</b> or <b>final</b> or members of a <b>final</b> class; this
corresponds to the hereditary nature of <b>@NonEscaping</b> (by forbidding
inheritance of implicitly non-escaping methods).

<div class="p"><!----></div>
We say that a method is <em>non-escaping</em> if it is either implicitly
non-escaping, or annotated <b>@NonEscaping</b>.

<div class="p"><!----></div>
The first requirement on non-escaping methods is that they do not allow
<b>this</b> to escape. Inside of their bodies, <b>this</b> and <b>super</b> may
only be used for field access and assignment, and as the receiver of
non-escaping methods.

<div class="p"><!----></div>
The following example uses the possible variations.  <b>aplomb()</b> 
explicitly forbids reading any field but
<b>a</b>. <b>boric()</b> is called after <b>a</b> and <b>b</b> are set, but
{c} is not.
The <b>@NonEscaping</b> annotation on <b>boric()</b> is optional, but the
compiler will print a warning if it is left out.
<b>cajoled()</b> is only called after all fields are set, so it
can read anything; its annotation, too, is not required.   <b>SeeAlso</b> is able to override <b>aplomb()</b>, because
<b>aplomb()</b> is <b>@NonEscaping</b>; it cannot override the final method
<b>boric()</b> or the private one <b>cajoled()</b>.  
<pre>
import x10.compiler.*;

<div class="p"><!----></div>
final class C2 {
  protected val a:Int, b:Int, c:Int;
  protected var x:Int, y:Int, z:Int;
  def this() {
    a = 1;
    this.aplomb();
    b = 2;
    this.boric();
    c = 3;
    this.cajoled();
  }
  @NonEscaping def aplomb() {
    x = a;
    // this.boric(); // not allowed; boric reads b.
    // z = b; // not allowed - only 'a' can be read here
  }
  @NonEscaping final def boric() {
    y = b;
    this.aplomb(); // allowed; 
       // a is definitely set before boric is called
    // z = c; // not allowed; c is not definitely written
  }
  @NonEscaping private def cajoled() {
    z = c;
  }
}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.4.2">
8.4.2</a>&nbsp;&nbsp;NoThisAccess Methods</h4>

<div class="p"><!----></div>
A method may be annotated <b>@NoThisAccess</b>.  <b>@NoThisAccess</b> methods
may be called from constructors, and they may be overridden in subclasses.
However, they may not refer to <b>this</b> in any way - in particular, they
cannot refer to fields of <b>this</b>, nor to <b>super</b>.

<div class="p"><!----></div>
The class <b>IDed</b> has an <b>Float</b>-valued <b>id</b> field.  The method
<b>count()</b> is used to initialize the <b>id</b>.  For <b>IDed</b> objects,
the <b>id</b> is the count of <b>IDed</b>s created with the same parity of its
<b>kind</b>.   Note that <b>count()</b> does not refer to <b>this</b>, though
it does refer to a <b>static</b> field <b>counts</b>. 

<div class="p"><!----></div>
The subclass <b>SubIDed</b> has <b>id</b>s that depend on <b>kind%3</b>
as well as the parity of <b>kind</b>.  It overrides the <b>count()</b>
method.  The body of <b>count()</b> still cannot refer to <b>this</b>.
Nor can it refer to <b>super</b> (which is <b>self</b> under another name).
This precludes the use of a <b>super</b> call.  This is why we have separated
the body of <b>count</b> out as the static method <b>kind2count</b> - without
that, we would have had to duplicate its body, as we could not call 
<b>super.count(kind)</b> in a <b>NoThisAccess</b> method, as is shown by 
the <b>ERROR</b> line <b>(A)</b>. 

<div class="p"><!----></div>
Note that <b>NoThisAccess</b> is in <b>x10.compiler</b> and must be imported,
and that the overriding method <b>SubIDed.count</b> must be declared
<b>@NoThisAccess</b> as well as the overridden method.
Line <b>(B)</b> is not allowed because <b>code</b> is a field of <b>this</b>, 
and field accesses are forbidden.   Line <b>(C)</b> references <b>this</b>
directly, which, of course, is forbidden by <b>@NoThisAccess</b>.  

<div class="p"><!----></div>
<pre>
import x10.compiler.*;
class UseNoThisAccess {
  static class IDed {
    protected static val counts = [0 as Int,0];
    protected var code : Int;
    val id: Float;
    public def this(kind:Int) { 
      code = kind;
      this.id = this.count(kind); 
    }
    protected static def kind2count(kind:Int) = ++counts(kind % 2);
    @NoThisAccess def count(kind:Int) : Float = kind2count(kind);
  }
  static class SubIDed extends IDed {
    protected static val subcounts = [0 as Int, 0, 0];
    public static val all = new x10.util.ArrayList[SubIDed]();
    public def this(kind:Int) { 
       super(kind); 
    }
    @NoThisAccess
    def count(kind:Int) : Float {
       val subcount &lt;: Int = ++subcounts(kind % 3);
       val supercount &lt;: Float = kind2count(kind);
       //ERROR: val badSuperCount = super.count(kind); //(A)
       //ERROR: code = kind;                           //(B)
       //ERROR: all.add(this);                         //(C)
       return  supercount + 1.0f / subcount;
    }
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.5">
8.5</a>&nbsp;&nbsp;Fine Structure of Constructors</h3>
<a name="SFineStructCtors">
</a>

<div class="p"><!----></div>
The code of a constructor consists of four segments, three of them optional
and one of them implicit.

<ol type="1">
<li> The first segment is an optional call to <b>this(...)</b> or
      <b>super(...)</b>.  If this is supplied, it must be the first statement
      of the constructor.  If it is not supplied, the compiler treats it as a
      nullary super-call <b>super()</b>;
<div class="p"><!----></div>
</li>

<li> If the class or struct has properties, there must be a single
      <b>property(...)</b> command in the constructor, or a <b>this(...)</b>
      constructor call.  Every execution path
      through the constructor must go through this <b>property(...)</b> command
      precisely once.   The second segment of the constructor is the code
      following the first segment, up to and including the <b>property()</b>
      statement.

<div class="p"><!----></div>
      If the class or struct has no properties, the <b>property()</b> call must
      be omitted. If it is present, the second segment is defined as before.  If
      it is absent, the second segment is empty.
<div class="p"><!----></div>
</li>

<li> The third segment is automatically generated.  Fields with initializers
      are initialized immediately after the <b>property</b> statement.
      In the following example, <b>b</b> is initialized to <b>y*9000</b> in
      segment three.  The initialization makes sense and does the right
      thing; <b>b</b> will be <b>y*9000</b> for every <b>Overdone</b> object.
      (This would not be possible if field initializers were processed
      earlier, before properties were set.)
<div class="p"><!----></div>
</li>

<li> The fourth segment is the remainder of the constructor body.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The segments in the following code are shown in the comments.
<pre>
class Overlord(x:Int) {
  def this(x:Int) { property(x); }
}//Overlord
class Overdone(y:Int) extends Overlord  {
  val a : Int;
  val b =  y * 9000;
  def this(r:Int) {
    super(r);                      // (1)
    x10.io.Console.OUT.println(r); // (2)
    val rp1 = r+1;
    property(rp1);                 // (2)
    // field initializations here  // (3)
    a = r + 2 + b;                 // (4)
  }
  def this() {
    this(10);                      // (1), (2), (3)
    val x = a + b;                 // (4)
  }
}//Overdone
</pre>

<div class="p"><!----></div>
The rules of what is allowed in the three segments are different, though
unsurprising.  For example, properties of the current class can only be read
in segment 3 or 4-naturally, because they are set at the end of segment 2.

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.5.1">
8.5.1</a>&nbsp;&nbsp;Initialization and Inner Classses</h4>


<div class="p"><!----></div>
Constructors of inner classes are tantamount to method calls on <b>this</b>.
For example, the constructor for Inner <b>is</b> acceptable.  It does not leak
<b>this</b>.  It leaks <b>Outer.this</b>, which is an utterly different object.
So, the call to <b>this.new Inner()</b> in the <b>Outer</b> constructor <em>
is</em> illegal.  It would leak <b>this</b>.  There is no special rule in effect
preventing this; a constructor call of an inner class is no
different from a method as far as leaking is concerned.
<pre>
class Outer {
  static val leak : Cell[Outer] = new Cell[Outer](null);
  class Inner {
     def this() {Outer.leak.set(Outer.this);}
  }
  def /*Outer*/this() {
     //ERROR: val inner = this.new Inner();
  }
}
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.5.2">
8.5.2</a>&nbsp;&nbsp;Initialization and Closures</h4>


<div class="p"><!----></div>
Closures in constructors may not refer to <b>this</b>.  They may not even refer
to fields of <b>this</b> that have been initialized.   For example, the
closure <b>bad1</b> is not allowed because it refers to <b>this</b>; <b>bad2</b>
is not allowed because it mentions <b>a</b> - which is, of course, identical
to <b>this.a</b>. 

<div class="p"><!----></div>
<pre>
class C {
  val a:Int;
  def this() {
    this.a = 1;
    //ERROR: val bad1 = () =&#62; this; 
    //ERROR: val bad2 = () =&#62; a*10;
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.6">
8.6</a>&nbsp;&nbsp;Definite Initialization in Constructors</h3>

<div class="p"><!----></div>
An instance field <b>var x:T</b>, when <b>T</b> has a default value, need not be
explicitly initialized.  In this case, <b>x</b> will be initialized to the
default value of type <b>T</b>.  For example, a <b>Score</b> object will have
its <b>currently</b> field initialized to zero, below:
<pre>
class Score {
  public var currently : Int;
}
</pre>

<div class="p"><!----></div>
All other sorts of instance fields do need to be initialized before they can
be used.  <b>val</b> fields must be initialized, even if their type has a
default value.  It would be silly to have a field <b>val z : Int</b> that was
always given default value of <b>0</b> and, since it is <b>val</b>, can never be
changed.  <b>var</b> fields whose type has no default value must be initialized
as well, such as <b>var y : Int{y != 0}</b>, since it cannot be assigned a
sensible initial value.

<div class="p"><!----></div>
The fundamental principles are:

<ol type="1">
<li> <b>val</b> fields must be assigned precisely once in each constructor on every
possible execution path.
<div class="p"><!----></div>
</li>

<li> <b>var</b> fields of defaultless type must be
assigned at least once on every possible execution path, but may be assigned
more than once.
<div class="p"><!----></div>
</li>

<li> No variable may be read before it is guaranteed to have been
assigned.
<div class="p"><!----></div>
</li>

<li> Initialization may be by field initialization expressions (<b>val x :
      Int = y+z</b>), or by uninitialized fields <b>val x : Int;</b> plus
an initializing assignment <b>x = y+z</b>.  Recall that field initialization
expressions are performed after the <b>property</b> statement, in segment 3 in
the terminology of &#167;<a href="#SFineStructCtors">8.5</a>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7">
8.7</a>&nbsp;&nbsp;Summary of Restrictions on Classes and Constructors</h3>

<div class="p"><!----></div>
The following table tells whether a given feature is (yes), is not (no) or is
with some conditions (note) allowed in a given context.   For example, a
property method is allowed with the type of another property, as long as it
only mentions the preceding properties. The first column of the table gives
examples, by line of the following code body.

<div class="p"><!----></div>

<table border='1'>
<tr><td align="left">&nbsp;</td>
  <td><b>Example</b></td>
  <td><b>Prop.</b></td>
  <td><b><tt><font size="-1">self==this</font></tt>(1)</b></td>
  <td><b>Prop.Meth.</b></td>
  <td><b><tt>this</tt></b></td>
  <td><b>fields</b></td>
</td></tr>
<tr><td align="left">Type of property</td>
  <td>(A)</td>
  
  <td>yes (2)</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Class Invariant</td>
  <td>(B)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Supertype (3)</td>
  <td>(C), (D)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Property Method Body</td>
  <td>(E)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Static field (4)</td>
  <td>(F) (G)</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Instance field (5)</td>
  <td>(H), (I)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">Constructor arg. type</td>
  <td>(J)</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor guard</td>
  <td>(K)</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor ret. type</td>
  <td>(L)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">Constructor segment 1</td>
  <td>(M)</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 2</td>
  <td>(N)</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 4</td>
  <td>(O)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">Methods</td>
  <td>(P)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">place</td>
  <td>(pos)</td>
  
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
</td></tr></table>


<div class="p"><!----></div>
Details:

<div class="p"><!----></div>

<ul>
<li> (1) Top-level <tt>self</tt> only.
<div class="p"><!----></div>
</li>

<li> (2) The type of the i<sup>th</sup> property may only mention
                 properties 1 through i.
<div class="p"><!----></div>
</li>

<li> (3) Super-interfaces follow the same rules as supertypes.
<div class="p"><!----></div>
</li>

<li> (4) The same rules apply to types and initializers.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The example indices refer to the following code:
<pre>
class Example (
   prop : Int,
   proq : Int{prop != proq},                    // (A)
   pror : Int
   )
   {prop != 0}                                  // (B)
   extends Supertype[Int{self != prop}]         // (C)
   implements SuperInterface[Int{self != prop}] // (D)
{
   property def propmeth() = (prop == pror);    // (E)
   static staticField
      : Cell[Int{self != 0}]                    // (F)
      = new Cell[Int{self != 0}](1);            // (G)
   var instanceField
      : Int {self != prop}                      // (H)
      = (prop + 1) as Int{self != prop};        // (I)
   def this(
      a : Int{a != 0},
      b : Int{b != a}                           // (J)
      )
      {a != b}                                  // (K)
      : Example{self.prop == a &amp;&amp; self.proq==b} // (L)
   {
      super();                                  // (M)
      property(a,b,a);                          // (N)
      // fields initialized here
      instanceField = b as Int{self != prop};   // (O)
   }

<div class="p"><!----></div>
   def someMethod() =
        prop + staticField() + instanceField;   // (P)
}
</pre>


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Method Resolution</h2>


<a name="sect:MethodResolution">
</a>

<div class="p"><!----></div>
Method resolution is the problem of determining, statically, which method (or
constructor or operator)
should be invoked, when there are several choices that could be invoked.  For
example, the following class has two overloaded <b>zap</b> methods, one taking
an <b>Object</b>, and the other a <b>Resolve</b>.  Method resolution will figure
out that the call <b>zap(1..4)</b> should call <b>zap(Object)</b>, and
<b>zap(new Resolve())</b> should call <b>zap(Resolve)</b>.  

<div class="p"><!----></div>
<pre>
class Res {
  public static interface Surface {}
  public static interface Deface {}

<div class="p"><!----></div>
  public static class Ace implements Surface {
    public static operator (Boolean) : Ace = new Ace();
    public static operator (Place) : Ace = new Ace();
  }
  public static class Face implements Surface, Deface{}

<div class="p"><!----></div>
  public static class A {}
  public static class B extends A {}
  public static class C extends B {}

<div class="p"><!----></div>
  def m(x:A) = 0;
  def m(x:Int) = 1;
  def m(x:Boolean) = 2;
  def m(x:Surface) = 3;
  def m(x:Deface) = 4; 

<div class="p"><!----></div>
  def example() {
     assert m(100) == 1 : &#207;nt"; 
     assert m(new C()) == 0 : "C";
     // An Ace is a Surface, unambiguous best choice
     assert m(new Ace()) == 3 : &#196;ce";
     // ERROR: m(new Face());

<div class="p"><!----></div>
     // The match must be exact.
     // ERROR: assert m(here) == 3 : "Place";

<div class="p"><!----></div>
     // Boolean could be handled directly, or by 
     // implicit coercion Boolean -&#62; Ace.
     // Direct matches always win.
     assert m(true) == 2 : "Boolean"; 
  }
</pre>

<div class="p"><!----></div>
In the <b>&#207;nt"</b> line, there is a very close match.  <b>100</b> is an
<b>Int</b>.  In fact, <b>100</b> is an <b>Int{self==100}</b>, so even in this
case the type of the actual parameter is not <em>precisely</em> equal to the type
of the method.

<div class="p"><!----></div>
In the <b>"C"</b> line of the example, <b>new C()</b> is an instance of <b>C</b>,
which is a subtype of <b>A</b>, so the <b>A</b> method applies.  No other method
does, and so the <b>A</b> method will be invoked.

<div class="p"><!----></div>
Similarly, in the <b>&#196;ce"</b> line, the <b>Ace</b> class implements
<b>Surface</b>, and so <b>new Ace()</b> matches the <b>Surface</b> method. 

<div class="p"><!----></div>
However, a <b>Face</b> is both a <b>Surface</b> and a <b>Deface</b>, so there is
no unique best match for the invocation <b>m(new Face())</b>.  This invocation
would be forbidden, and a compile-time error issued.

<div class="p"><!----></div>
The match must be exact.  There is an implicit coercion 
from <b>Place</b> to <b>Ace</b>, and <b>Ace</b> implements <b>Surface</b>, so the
code
<pre>
val ace : Ace = here;
assert m(ace) == 3;
</pre>
works, by using the <b>Surface</b> form of <b>m</b>.  But doing it in one step
requires a deeper search than X10 performs<a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>, and is not allowed.

<div class="p"><!----></div>
For <b>m(true)</b>, both the <b>Boolean</b> and, with the implicit coercion,
<b>Ace</b> methods could apply.  Since the <b>Boolean</b> method applies
directly, and the <b>Ace</b> method requires an implicit coercion, this call
resolves to the <b>Boolean</b> method, without an error.

<div class="p"><!----></div>
The basic concept of method resolution is:

<ol type="1">
<li> List all the methods that could possibly be used, inferring generic
      types but not performing implicit coercions.
<div class="p"><!----></div>
</li>

<li> If one possible method is more specific than all the others, that one 
      is the desired method.
<div class="p"><!----></div>
</li>

<li> If there are two or more methods neither of which is more specific than
      the others, then the method invocation is ambiguous.  Method resolution
      fails and reports an error.
<div class="p"><!----></div>
</li>

<li> Otherwise, no possible methods were found without implicit coercions.
      Try the preceding steps again, but with coercions allowed: zero or one
      implicit coercion for each argument.  If a single
      most specific method is found with coercions, it is the desired method.
      If there are several, the invocation is ambiguous and erronious.
<div class="p"><!----></div>
</li>

<li> If no methods were found even with coercions, then the method invocation
      is undetermined.  Method resolution fails and reports an error.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
After method resolution is done, there is a validation phase that checks the
legality of the call, based on the <b>STATIC_CHECKS</b> compiler flag.  
With <b>STATIC_CHECKS</b>, the method's constraints must be satisfied; that is,
they must be entailed (&#167;) by the information in
force at the point of the call.  With <b>DYNAMIC_CHECKS</b>, if the constraint
is not entailed at that point, a dynamic check is inserted to make sure that
it is true at runtime.

<div class="p"><!----></div>
In the presence of X10's highly-detailed type system, some subtleties arise. 
One point, at least, is <em>not</em> subtle. The same procedure is used, <em>
mutatis mutandis</em> for method, constructor, and operator resolution.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Space of Methods</h3>

<div class="p"><!----></div>
X10 allows some constructs, particularly <b>operator</b>s, to be defined in a
number of ways, and invoked in a number of ways. This section specifies which
forms of definition could correspond to a given definiendum.

<div class="p"><!----></div>
Method invocations <b>a.m(b)</b>, where <b>a</b> is an expression, can be either
of the following forms.  There may be any number of arguments.

<ul>
<li> An instance method on <b>a</b>, of the form <b>def m(B)</b>.
<div class="p"><!----></div>
</li>

<li> A static method on <b>a</b>'s class, of the form <b>static def m(B)</b>.

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The meaning of an invocation of the form <b>m(b)</b>, with any number of
arguments, depends slightly on its context.  Inside of a constraint, it might
mean <b>self.m(b)</b>.  Outside of a constraint, there is no <b>self</b>
defined, so it can't mean that.  The first of these that applies will be
chosen. 

<ol type="1">
<li> Invoke a method on <b>this</b>, <em>viz</em> <b>this.m(b)</b>.  Inside a
      constraint, it may also invoke a property method on <b>self</b>, <em>viz</em>.
      <b>self.m(b)</b>.  It is an error if both <b>this.m(b)</b> and
      <b>self.m(b)</b> are possible.
<div class="p"><!----></div>
</li>

<li> Invoke a function named <b>m</b> in a local or field.
<div class="p"><!----></div>
</li>

<li> Construct a structure named <b>m</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
Static method invocations, <b>A.m(b)</b>, where <b>A</b> is a container name,
can only be static.  There may be any number of arguments.

<ul>
<li> A static method on <b>A</b>, of the form <b>static def m(B)</b>.

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Constructor invocations, <b>new A(b)</b>, must invoke constructors. There may
be any number of arguments. 

<ul>
<li> A constructor on <b>A</b>, of the form <b>def this(B)</b>.

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
A unary operator "&#8727; a" may be defined as: 

<ul>
<li> An instance operator on <b>A</b>, defined as 
      &#246;perator &#8727; this()".
<div class="p"><!----></div>
</li>

<li> A static operator on <b>A</b>, defined as 
      &#246;perator &#8727;(a:A)".

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
A binary operator &#228; &#8727; b" may be defined as: 

<ul>
<li> An instance operator on <b>A</b>, defined as 
      &#246;perator this &#8727;(b:B)";
or
<div class="p"><!----></div>
</li>

<li> A right-hand operator on <b>B</b>, defined as
      &#246;perator (a:A) &#8727; this"; or
<div class="p"><!----></div>
</li>

<li> A static operator on <b>A</b>, defined as
      &#246;perator (a:A) &#8727; (b:B)", 
; or
<div class="p"><!----></div>
</li>

<li> A static operator on <b>B</b>, if <b>A</b> and <b>B</b> are different
      classes, defined as
      &#246;perator (a:A) &#8727; (b:B)"

<div class="p"><!----></div>
</li>
</ul>

If none of those resolve to a method, then either operand may be implicitly
coerced to the
other.  If one of the following two situations obtains, it will be done; if
both, the expression causes a static error.

<ul>
<li> An implicit coercion from <b>A</b> to <b>B</b>, and 
      an operator "B &#8727; B" can be used, by 
      coercing <b>a</b> to be of type <b>B</b>, and then using <b>B</b>'s
      &#8727;.
<div class="p"><!----></div>
</li>

<li> An implicit coercion from <b>B</b> to <b>A</b>, and 
      an operator &#196; &#8727; A" can be used,
      coercing <b>b</b> to be of type <b>A</b>, and then using <b>A</b>'s
      &#8727;.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
An application <b>a(b)</b>, for any number of arguments, can come from a number
of things. 

<ul>
<li> an application operator on <b>a</b>, defined as <b>operator this(b:B)</b>;
<div class="p"><!----></div>
</li>

<li> If <b>a</b> is an identifier, <b>a(b)</b> can also be a method invocation
      equivalent to <b>this.a(b)</b>, which  invokes <b>a</b> as
      either an instance or static method on <b>this</b>
<div class="p"><!----></div>
</li>

<li> If <b>a</b> is a qualified identifier, <b>a(b)</b> can also be an
      invocation of a struct constructor.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
An indexed assignment, <b>a(b)=c</b>, for any number of <b>b</b>'s, can only
come from an indexed assignment definition: 

<ul>
<li> <b>operator this(b:B)=(c:C) {...}</b>

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
An implicit coercion, in 
which a value <b>a:A</b> is used in a context which requires a value of some
other non-subtype <b>B</b>, 
can only come from implicit coercion operation defined on
<b>B</b>: 

<ul>
<li> an implicit coercion in <b>B</b>:
      <b>static operator (a:A):B</b>;

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
An explicit conversion <b>a as B</b> can come from an explicit conversion
operator, or an implicit coercion operator.  X10 tries two things, in order,
only checking 2 if 1 fails: 

<ol type="1">
<li> An <b>as</b> operator in <b>B</b>: 
      &#223;tatic operator (a:A) as ?";
<div class="p"><!----></div>
</li>

<li> or, failing that, an implicit coercion in <b>B</b>:
      <b>static operator (a:A):B</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;Possible Methods</h3>

<div class="p"><!----></div>
This section describes what it means for a method to be a <em>possible</em>
resolution of a method invocation.  

<div class="p"><!----></div>
Generics introduce several subtleties, especially with the inference of
generic types. 
For the purposes of method resolution, all that matters about a method,
constructor, or operator <b>M</b> - we use the word "method" to include all
three choices for this section - is its signature, plus which method it is.
So, a typical <b>M</b> might look like 
"def m[G<sub>1</sub>,&#8230;, G<sub>g</sub>](x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>){c} =...".  The code body <b>...</b> is irrelevant for the purpose of whether a
given method call means <b>M</b> or not, so we ignore it for this section.

<div class="p"><!----></div>
All that matters about a method definition, for the purposes of method
resolution, is: 

<ol type="1">
<li> The method name <b>m</b>;
<div class="p"><!----></div>
</li>

<li> The generic type parameters of the method <b>m</b>,  "G<sub>1</sub>,&#8230;, G<sub>g</sub>".  If there
      are no generic type parameters, g=0.
<div class="p"><!----></div>
</li>

<li> The types "x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>" of the formal parameters.  If
      there are no formal parameters, f=0. In the case of an instance
      method, the receiver will be the first formal parameter.<a href="#tthFtNtAAH" name="tthFrefAAH"><sup>7</sup></a>
<div class="p"><!----></div>
</li>

<li> A <em>unique identifier</em> <b>id</b>, sufficient to tell the compiler
      which method body is intended.  A file name and position in that file
      would suffice.  The details of the identifier are not relevant.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
For the purposes of understanding method resolution, we assume that all the
actual parameters of an invocation are simply variables: <b>x1.meth(x2,x3)</b>.
This is done routinely by the compiler in any case; the code 
<b>tbl(i).meth(true, a+1)</b> would be treated roughly as 
<pre>
val x1 = tbl(i);
val x2 = true;
val x3 = a+1;
x1.meth(x2,x3);
</pre>

<div class="p"><!----></div>
All that matters about an invocation <b>I</b> is: 

<ol type="1">
<li> The method name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> The generic type parameters "G&#8242;<sub>1</sub>,&#8230;, G&#8242;<sub>g</sub>".  If there
      are no generic type parameters, g=0.
<div class="p"><!----></div>
</li>

<li> The names and types "x<sub>1</sub>:T&#8242;<sub>1</sub>,&#8230;, x<sub>f</sub>:T&#8242;<sub>f</sub>" of the
      actual parameters.
      If
      there are no actual parameters, f=0. In the case of an instance
      method, the receiver is the first actual parameter.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The signature of the method resolution procedure is: 
<b>resolve(invo : Invocation, context: Set[Method]) : MethodID</b>.  
Given a particular invocation and the set <b>context</b> of all methods
which could be called at that point of code, method resolution either returns
the unique identifier of the method that should be called, or (conceptually)
throws an exception if the call cannot be resolved.

<div class="p"><!----></div>
The procedure for computing <b>resolve(invo, context)</b> is: 

<ol type="1">
<li> Eliminate from <b>context</b> those methods which are not <em>
      acceptable</em>; <em>viz</em>, those whose name, type parameters, and formal parameters
      do not suitably match <b>invo</b>.  In more detail:
      
<ul>
<li> The method name <b>m</b> must simply equal the invocation name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> X10 infers type parameters, by an algorithm given in &#167;.
<div class="p"><!----></div>
</li>

<li> The method's type parameters are bound to the invocation's for the
            remainder of the acceptability test.
<div class="p"><!----></div>
</li>

<li> The actual parameter types must be subtypes of the formal
            parameter types, or be coercible to such subtypes.  Parameter i
            is a subtype if "T&#8242;<sub>i</sub> &lt;: T<sub>i</sub>".  It is implicitly
            coercible to a subtype if either it is a subtype, or if there is
            an implicit coercion operator 
            defined from "T&#8242;<sub>i</sub>" to some type <b>U</b>, and 
            &#220; &lt;: T<sub>i</sub>".  .  If coercions are
            used to resolve the method, they will be called on the arguments
            before the method is invoked.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Eliminate from <b>context</b> those methods which are not <em>
      available</em>; <em>viz</em>, those which cannot be called due to visibility
      constraints, such as methods from other classes marked <b>private</b>.
      The remaining methods are both acceptable and available; they might be
      the one that is intended.
<div class="p"><!----></div>
</li>

<li> If the method invocation is a <b>super</b> invocation appearing in class
      <b>Cl</b>, methods of <b>Cl</b> and its subclasses are considered
      unavailable as well.
<div class="p"><!----></div>
</li>

<li> From the remaining methods, find the unique <b>ms</b> which is more specific than all the
      others, <em>viz</em>, for which <b>specific(ms,mo) = true</b> for all other
      methods <b>mo</b>.
      The specificity test <b>specific</b> is given next.
      
<ul>
<li> If there is a unique such <b>ms</b>, then
            <b>resolve(invo,context)</b> returns the <b>id</b> of <b>ms</b>.
<div class="p"><!----></div>
</li>

<li> If there is not a unique such <b>ms</b>, then <b>resolve</b> reports
            an error.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The subsidiary procedure <b>specific(m1, m2)</b> determines whether method
<b>m1</b> is equally or more specific than <b>m2</b>.  <b>specific</b> is not a
total order: is is possible for each one to be considered more specific than
the other, or either to be more specific.  <b>specific</b> is computed as: 

<ol type="1">
<li> Construct an invocation <b>invo1</b> based on <b>m1</b>: 
      
<ul>
<li> <b>invo1</b>'s method name is <b>m1</b>'s method name;
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s generic parameters are those of <b>m1</b>- simply
            some type variables.
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s parameters are those of <b>m1</b>.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> If <b>m2</b> is acceptable for the invocation <b>invo1</b>,
      <b>specific(m1,m2)</b> returns true;
<div class="p"><!----></div>
</li>

<li> Construct an invocation <b>invo2p</b>, which is <b>invo1</b> with the
      generic parameters erased.  Let <b>invo2</b> be <b>invo2p</b> with generic
      parameters as inferred by X10's type inference algorithm.  If type
      inference fails, <b>specific(m1,m2)</b> returns false.
<div class="p"><!----></div>
</li>

<li> If <b>m2</b> is acceptable for the invocation <b>invo2</b>,
      <b>specific(m1,m2)</b> returns true;
<div class="p"><!----></div>
</li>

<li> Otherwise, <b>specific(m1,m2)</b> returns false.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.3">
9.3</a>&nbsp;&nbsp;Field Resolution</h3>

<div class="p"><!----></div>
An identifier <b>p</b> can refer to a number of things.  The rules are somewhat
different inside and outside of a constraint.

<div class="p"><!----></div>
Outside of a constraint, the compiler chooses
the first one from the following list which applies: 

<ol type="1">
<li> A local variable named <b>p</b>.
<div class="p"><!----></div>
</li>

<li> A field of <b>this</b>, <em>viz</em> <b>this.p</b>.
<div class="p"><!----></div>
</li>

<li> A nullary property method, <b>this.p()</b>
<div class="p"><!----></div>
</li>

<li> A member type named <b>p</b>.
<div class="p"><!----></div>
</li>

<li> A package named <b>p</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
Inside of a constraint, the rules are slightly different, because <b>self</b>
is available, and packages cannot be used per se.

<ol type="1">
<li> A local variable named <b>p</b>.
<div class="p"><!----></div>
</li>

<li> A property of <b>this</b> or of <b>self</b>, <em>viz</em> <b>this.p</b> or
      <b>self.p</b>.  If both are available, report an error.
<div class="p"><!----></div>
</li>

<li> A nullary property method, <b>this.p()</b>
<div class="p"><!----></div>
</li>

<li> A member type named <b>p</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc9.4">
9.4</a>&nbsp;&nbsp;Other Disambiguations</h3>
<a name="sect:disambiguations">
</a>

<div class="p"><!----></div>
It is possible to have a field of the same name as a method.
Indeed, it is a common pattern to have private field and a public
method of the same name to access it:

<pre>
class Xhaver {
  private var x: Int = 0;
  public def x() = x;
  public def bumpX() { x ++; }
}
</pre>


<div class="p"><!----></div>
However, this can lead to syntactic ambiguity in the case where the field
<b>f</b> of object <b>a</b> is a
function, array, list, or the like, and where <b>a</b> has a method also named
<b>f</b>.  The term <b>a.f(b)</b> could either mean "call method <b>f</b> of <b>a</b> upon
<b>b</b>", or &#228;pply the function <b>a.f</b> to argument <b>b</b>".  

<div class="p"><!----></div>
<pre>
class Ambig {
  public val f : (Int)=&#62;Int =  (x:Int) =&#62; x*x;
  public def f(y:int) = y+1;
  public def example() {
      val v = this.f(10);
      // is v 100, or 11?
  }
}
</pre>


<div class="p"><!----></div>
In the case where a syntactic form &#203;.m(F<sub>1</sub>, &#8230;, F<sub>n</sub>)" could
be resolved as either a method call, or the application of a field <b>E.m</b>
to some arguments, it will be treated as a method call.  
The application of <b>E.m</b> to some arguments can be specified by adding
parentheses:  "(E.m)(F<sub>1</sub>, &#8230;, F<sub>n</sub>)".

<div class="p"><!----></div>
<pre>
class Disambig {
  public val f : (Int)=&#62;Int =  (x:Int) =&#62; x*x;
  public def f(y:int) = y+1;
  public def example() {
      assert(  this.f(10)  == 11  );
      assert( (this.f)(10) == 100 );
  }
}
</pre>

<div class="p"><!----></div>
Similarly, it is possible to have a method with the same name as a struct, say
<b>ambig</b>, giving an ambiguity as to whether <b>ambig()</b> is a struct
constructor invocation or a method invocation.  This ambiguity is resolved by
treating it as a method invocation.  If the constructor invocation is desired,
it can be achieved by including the optional <b>new</b>.  That is, 
<b>new ambig()</b> is struct constructor invocation; <b>ambig()</b> is a 
method invocation.


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

 


<div class="p"><!----></div>
 

<div class="p"><!----></div>
 

<div class="p"><!----></div>
 


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Static Nested Classes</h2>
<a name="StaticNestedClasses">
</a>




<div class="p"><!----></div>
One class (or struct or interface) may be nested within another.  The simplest
way to do this is as a <b>static</b> nested class, written by putting one class
definition at top level inside another, with the inner one having a
<b>static</b> modifier.  
For most purposes, a static nested class behaves like a top-level class.
However, a static nested class has access to private static
fields and methods of its containing class.  

<div class="p"><!----></div>
Nested interfaces and static structs are permitted as well.

<div class="p"><!----></div>
<pre>
class Outer {
  private static val priv = 1;
  private static def special(n:Int) = n*n;
  public static class StaticNested {
     static def reveal(n:Int) = special(n) + priv;
  }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Inner Classes</h2>
<a name="InnerClasses">
</a>



<div class="p"><!----></div>
Non-static nested classes are called <em>inner classes</em>. An inner class
instance can be thought of as a very elaborate member of an object - one
with a full class structure of its own.   The crucial characteristic of an
inner class instance is that it has an implicit reference to an instance of
its containing class.  

<div class="p"><!----></div>
This feature is particularly useful when an instance of the inner class makes
no sense without reference to an instance of the outer, and is closely tied to
it.  For example, consider a range class, describing a span of integers m
to n, and an iterator over the range.  The iterator might as well have
access to the range object, and there is little point to discussing
iterators-over-ranges without discussing ranges as well.
In the following example, the inner class <b>RangeIter</b> iterates over the
enclosing <b>Range</b>.  

<div class="p"><!----></div>
It has its own private cursor field <b>n</b>, telling
where it is in the iteration; different iterations over the same <b>Range</b>
can exist, and will each have their own cursor.
It is perhaps unwise to use the name <b>n</b> for a field of the inner class,
since it is also a field of the outer class, but it is legal.  (It can happen
by accident as well - <em>e.g.</em>, if a programmer were to add a field <b>n</b> to a
superclass of the  outer class, the inner class would still work.)
It does not even
interfere with the inner class's ability to refer to the outer class's <b>n</b>
field: the cursor initialization 
refers to the <b>Range</b>'s lower bound through a fully qualified name
<b>Range.this.n</b>.
The initialization of its <b>n</b> field refers to the outer class's <b>m</b> field, which is
not shadowed and can be referred to directly, as <b>m</b>.

<div class="p"><!----></div>
<pre>
class Range(m:Int, n:Int) implements Iterable[Int]{
  public def iterator ()  = new RangeIter();
  private class RangeIter implements Iterator[Int] {
     private var n : Int = m;
     public def hasNext() = n &lt;= Range.this.n;
     public def next() = n++;
  }
  public static def main(argv:Array[String](1)) {
    val r = new Range(3,5);
    for(i in r) Console.OUT.println(&#239;=" + i);
  }
}
</pre>


<div class="p"><!----></div>
An inner class has full access to the members of its enclosing class, both
static and instance.  In particular, it can access <b>private</b> information,
just as methods of the enclosing class can.  

<div class="p"><!----></div>
An inner class can have its own members.  
Inside instance methods of an inner class, <b>this</b> refers to the instance
of the <em>inner</em> class.  The instance of the outer class can be accessed as
<em>Outer</em><b>.this</b> (where <em>Outer</em> is the name of the outer class).
If, for some dire reason, it is necessary to have an inner class within an inner
class, the innermost class can refer to the <b>this</b> of either outer class
by using its name.

<div class="p"><!----></div>
An inner class can inherit from any class in scope,
with no special restrictions. <b>super</b> inside an inner class refers to the
inner class's superclass. If it is necessary to refer to the outer classes's
superclass, use a qualified name of the form <em>Outer</em><b>.super</b>.

<div class="p"><!----></div>
The members of inner classes must be instance members.  They cannot be static
members.  Classes, interfaces, static methods, static fields, and typedefs are
not allowed as members of inner classes. 
The same restriction applies to local classes (&#167;).

<div class="p"><!----></div>
Consider
an inner class <b>IC1</b> of some outer class <b>OC1</b>, being extended by 
another class <b>IC2</b>. However, since an <b>IC1</b> only exists as a
dependent of an <b>OC1</b>, each <b>IC2</b> must be associated with an <b>OC1</b>
- or a subtype thereof - as well.   So, <b>IC2</b> must be an inner class
of either <b>OC1</b> or some subclass <b>OC2 &lt;: OC1</b>.

<div class="p"><!----></div>
For example, one often extends an
inner class when one extends its outer class: 
<pre>
class OC1 {
   class IC1 {}
}
class OC2 extends OC1 {
   class IC2 extends IC1 {} 
}
</pre>


<div class="p"><!----></div>
The hiding of method names has one fine point.  If an inner class defines a
method named <b>doit</b>, then <em>all</em> methods named <b>doit</b> from the
outer class are hidden - even if they have different argument types than the
one defined in the inner class.
They are still accessible via
<b>Outer.this.doit()</b>, but not simply via <b>doit()</b>.  The following code
is correct, but would not be correct if the ERROR line were uncommented.

<div class="p"><!----></div>
<pre>
class Outer {
  def doit() {}
  def doit(String) {}
  class Inner { 
     def doit(Boolean, Outer) {}
     def example() {
        doit(true, Outer.this);
        Outer.this.doit();
        //ERROR: doit("fails");
     }
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Constructors and Inner Classes</h3>
<a name="sect:InnerClassCtor">
</a>


<div class="p"><!----></div>
If <b>IC</b> is an inner class of <b>OC</b>, then instance code in the body of
<b>OC</b> can create instances of <b>IC</b> simply by calling a constructor
<b>new IC(...)</b>: 
<pre>
class OC {
  class IC {}
  def method(){
    val ic = new IC();
  }
}
</pre>

<div class="p"><!----></div>
Instances of <b>IC</b> can be constructed from elsewhere as well.  Since every
instance of <b>IC</b> is associated with an instance of <b>OC</b>, an <b>OC</b>
must be supplied to the <b>IC</b> constructor.  The syntax for doing so is: 
<b>oc.new IC()</b>.  For example: 
<pre>
class OC {
  class IC {}
  static val oc1 = new OC();
  static val oc2 = new OC();
  static val ic1 = oc1.new IC();
  static val ic2 = oc2.new IC();
}
class Elsewhere{
  def method(oc : OC) {
    val ic = oc.new IC();
  }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Local Classes</h2>
<a name="sect:LocalClasses">
</a>

<div class="p"><!----></div>
Classes can be defined and instantiated in the middle of methods and other
code blocks.
A local class in a static method is a static class; a local class in an
instance method is an inner class.
 Local classes are local to the block in which they are defined.
They have access to almost everything defined at that point in the method; the
one exception is that they cannot use <b>var</b> variables. Local classes
cannot be <b>public</b>, <b>protected</b>, or <b>private</b>, because they are
only visible from within the block of declaration. They cannot be
<b>static</b>.

<div class="p"><!----></div>
The following example illustrates the use of a local class <b>Local</b>, 
defined inside the body of method <b>m()</b>. 
<pre>
class Outer {
  val a = 1;
  def m() {
    val a = -2; 
    val b = 2;
    class Local {
      val a = 3;
      def m() = 100*Outer.this.a + 10*b + a; 
    }
    val l : Local = new Local();
    assert l.m() == 123;
  }//end of m()
}
</pre>
Note that the middle <b>a</b>,
whose value is <b>-2</b>, is not accessible inside of <b>Local</b>; it is
shadowed by <b>Local</b>'s <b>a</b> field.  <b>Outer</b>'s <b>a</b> is also
shadowed, but the notation <b>Outer.this</b> gives a reference to the enclosing
<b>Outer</b> object.  There is no corresponding notation to access shadowed local
variables from the enclosing block; if you need to get them, rename the fields
of <b>Local</b>.    


<div class="p"><!----></div>
The members of inner classes must be instance members.  They cannot be static
members.  Classes, interfaces, static methods, static fields, and typedefs are
not allowed as members of local classes. 
The same restriction applies to inner classes (&#167;<a href="#InnerClasses">11</a>). 

<div class="p"><!----></div>
 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;Anonymous Classes</h2>



<div class="p"><!----></div>
It is possible to define a new local class and instantiate it as part of an
expression.  The new class can extend an existing class or interface.  Its body
can include all of the usual members of a local class. It can refer to any
identifiers available at that point in the expression - except for <b>var</b>
variables.  An anonymous class in a static context is a static inner class.

<div class="p"><!----></div>
Anonymous classes are useful when you want to package several pieces of
behavior together (a single piece of behavior can often be expressed as a
function, which is syntactically lighter-weight), or if you want to extend and
vary an extant class without going through the trouble of actually defining a
whole new class.

<div class="p"><!----></div>
The syntax for an anonymous class is a constructor call followed immediately
by a braced class body: <b>new C(1){def foo()=2;}</b>.

<div class="p"><!----></div>
In the following minimalist example, the abstract class <b>Choice</b>
encapsulates a decision.   A <b>Choice</b> has a <b>yes()</b> and a <b>no()</b>
method.  The <b>choose(b)</b> method will invoke one of the two.  <b>Choice</b>s
also have names.

<div class="p"><!----></div>
The <b>main()</b> method creates a specific <b>Choice</b>.  <b>c</b> is not a
immediate instance of <b>Choice</b> - as an abstract class, <b>Choice</b> has
no immediate instances. <b>c</b> is an instance of an anonymous class which
inherits from <b>Choice</b>, but supplies <b>yes()</b> and <b>no()</b> methods.
These methods modify the contents of the <b>Cell[Int]</b> <b>n</b>.  (Note that,
as <b>n</b> is a local variable, it would take a few lines more coding to
extract <b>c</b>'s class, name it, and make it an inner class.)  The call to
<b>c.choose(true)</b>  will call <b>c.yes()</b>, incrementing <b>n()</b>, in a
rather roundabout manner.

<div class="p"><!----></div>
<pre>
abstract class Choice(name: String) {
  def this(name:String) {property(name);}
  def choose(b:Boolean) { 
     if (b) this.yes(); else this.no(); }
  abstract def yes():void;
  abstract def no():void;
}

<div class="p"><!----></div>
class Example {
  static def main(Array[String]) {
    val n = new Cell[Int](0);
    val c = new Choice(&#207;nc Or Dec") {
      def yes() { n() += 1; }
      def no()  { n() -= 1; }
      };
    c.choose(true);
    Console.OUT.println("n=" + n());
  }
}

<div class="p"><!----></div>
</pre>


<div class="p"><!----></div>
Anonymous classes have many of the features of classes in general.  A few
features are unavailable because they don't make sense.

<div class="p"><!----></div>

<ul>
<li> Anonymous classes don't have constructors.  Since they don't have names,
      there's no way a constructor could get called in the ordinary way.
      Instead, the <b>new C(...)</b> expression must match a constructor of the
      parent class <b>C</b>, which will be called to initialize the
      newly-created object of the anonymous class.
<div class="p"><!----></div>
</li>

<li> The <b>public</b>,
      <b>private</b>, and <b>protected</b>  modifiers don't make sense for
      anonymous classes:  
      Anonymous classes, being anonymous,
      cannot be referenced at all, so references to them can't be public,
      private, or protected.
<div class="p"><!----></div>
</li>

<li> Anonymous classes cannot be <b>abstract</b>.  Since they only exist in
      combination with a constructor call, they must be constructable.  The
      parent class of the anonymous class may be abstract, or may be an
      interface; in this case, the anonymous class must provide all the
      methods that the parent demands.
<div class="p"><!----></div>
</li>

<li> Anonymous classes cannot have explicit <b>extends</b> or <b>implements</b>
      clauses; there's no place in the syntax for them. They have a single
      parent and that is that.
<div class="p"><!----></div>
</li>
</ul>

<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>In many cases, a 
<b>val</b> field can be upgraded to a <b>property</b>, which 
entails no compile-time or runtime cost.  Some cannot be, <em>e.g.</em>, in cases where
cyclic structures of <b>val</b> fields are required.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>This only
applies to nullary property methods, not nullary instance methods.  Nullary
property methods perform limited computations, have no side effects, and
always return the same value, since
they have to be expressed in the constraint sublanguage.  In this sense, a
nullary property method does not behave hugely different from a property.
Indeed, a compilation scheme which cached the value of the property method
would all but erase the distinction.  Other methods may
have more behavior, <em>e.g.</em>, side effects, so we keep the <b>()</b> to make it
clear that a method call is potentially large.

<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>Indeed, even for the
standard types, these operators are defined in the library.  Not even as basic
an operation as integer addition is built into the language.  Conversely, if
you define a full-featured numeric type, it will have most of the privileges that
the standard ones enjoy.  The missing priveleges are (1) literals; (2) 
the <b>..</b> operator won't compute the <b>zeroBased</b> and <b>rail</b>
properties as it does for <b>Int</b> ranges; (3) <b>*</b> won't track ranks, as
it does for <b>Region</b>s; 
(4) <b>&amp;&amp;</b> and <b>&#124;&#124;</b> won't short-circuit, as they do for <b>Boolean</b>s, 
(5) the built-in notion of equality <b>a==b</b> will only coincide with
the programmible notion <b>a.equals(b)</b>, as they do for most library types,
if coded that way; and (6) it is 
impossible to define an 
operation like <b>String.+</b> which converts both its left and right arguments
from any type.  For example, a <b>Polar</b> type might
have many representations for the origin, as radius 0 and any angle; these
will be <b>equals()</b>, but will not be <b>==</b>; whereas for the standard
<b>Complex</b> type, the two equalities are the same.
<div class="p"><!----></div>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>We use <b>Pt</b>
to avoid any possible confusion with the built-in class <b>Point</b>.
<div class="p"><!----></div>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>This is abominable behavior for
<b>toString</b>, but it cannot be prevented - save by a scheme such as we
present in this section.
<div class="p"><!----></div>
<a name="tthFtNtAAG"></a><a href="#tthFrefAAG"><sup>6</sup></a>In general this search is
unbounded, so X10 can't perform it.
<div class="p"><!----></div>
<a name="tthFtNtAAH"></a><a href="#tthFrefAAH"><sup>7</sup></a>The
      variable names are relevant because one formal can be mentioned in a
      later type, or even a constraint: <tt>def f(a:Int, b:Point{rank==a})=...</tt>.
<br /><br /><hr />
</html>
