<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>`</title>

<div class="p"><!----></div>
`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>



<div class="p"><!----></div>
                         /Author   (Vijay Saraswat, Bard Bloom, Igor Peshansky, Olivier Tardieu, and David Grove)
              /Title    (Report on the Language X10)
              /Keywords (X10)
              /Subject  ()
              /Creator  (TeX)
              /Producer (PDFLaTeX)
          


<div class="p"><!----></div>

<div class="p"><!----></div>
                         %    box containing running head.

<div class="p"><!----></div>
                         % excluding running head and foot).

<div class="p"><!----></div>
          % Space between columns 
 0pt       % Width of rule between columns.

<div class="p"><!----></div>
 % Extra vertical space between paragraphs.
                  % Width of paragraph indentation.
                                % , added above and below list and
                                % paragraphing environments.

<div class="p"><!----></div>
    % Left margin on odd-numbered pages.
    % Left margin on even-numbered pages.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<title>Report on the Programming Language \Xten \
\large Version \integerversion </title>
    
<h1 align="center">Report on the Programming Language X10<br />
<font size="+1">Version 2.1</font> </h1>

<h3 align="center"> D<font size="-2">RAFT</font> - Oct 12, 2010
<br />
<br />
Vijay Saraswat, Bard Bloom, Igor Peshansky, Olivier Tardieu, and David Grove<br />
<br />
Please send comments to 
<tt>bardb@us.ibm.com</tt> </h3>

<div class="p"><!----></div>

<div class="p"><!----></div>
This report provides a description of the programming
language X10. X10 is a class-based object-oriented
programming language designed for high-performance, high-productivity
computing on high-end computers supporting  &#8776; 10<sup>5</sup> hardware threads
and  &#8776; 10<sup>15</sup> operations per second. 

<div class="p"><!----></div>
X10 is based on state-of-the-art object-oriented programming
languages and deviates from them only as necessary to support its
design goals. The language is intended to have a simple and clear
semantics and be readily accessible to mainstream OO programmers. It
is intended to support a wide variety of concurrent programming
idioms.

<div class="p"><!----></div>

<div class="p"><!----></div>
The X10 design team consists of
Bard Bloom, 
Ganesh Bikshandi, 
David Cunningham,
Robert Fuhrer,
David Grove,
Sreedhar Kodali, 
Nathaniel Nystrom,
Igor Peshansky, 
Vijay Saraswat,
Olivier Tardieu.

<div class="p"><!----></div>
Past members include
Shivali Agarwal, 
David Bacon, 
Raj Barik, 
Bob Blainey, 
Philippe Charles, 
Perry Cheng, 
Christopher Donawa, 
Julian Dolby, 
Kemal Ebcioglu,
Patrick Gallop, 
Christian Grothoff, 
Allan Kielstra, 
Sriram Krishnamoorthy, 
Bruce Lucas,
Vivek Sarkar,
Armando Solar-Lezama,  
S. Alexander Spoon, 
Sayantan Sur, 
Christoph von Praun,
Pradeep Varma, 
Krishna Nandivada Venkata,
Jan Vitek, and
Tong Wen.

<div class="p"><!----></div>
For extended discussions and support we would like to thank: 
Gheorghe Almasi,
Robert Blackmore,
Robert Callahan, 
Calin Cascaval, 
Norman Cohen, 
Elmootaz Elnozahy, 
John Field,
Kevin Gildea,
Chulho Kim,
Orren Krieger, 
Doug Lea, 
John McCalpin, 
Paul McKenney, 
Andrew Myers,
Filip Pizlo, 
Ram Rajamony,
R.&#126;K. Shyamasundar, 
V.&#126;T. Rajan, 
Frank Tip,
Mandana Vaziri,
and
Hanhong Xue.

<div class="p"><!----></div>
We thank Jonathan Rhees and William Clinger with help in obtaining the
<span class="roman">L</span><sup><span class="roman">A</span></sup><span class="roman">T</span><sub><span class="roman">E</span></sub><span class="roman">X</span> style file and macros used in producing the Scheme report,
on which this document is based. We acknowledge the influence of
the Java<sup> <font size="-2">TM</font></sup> Language
Specification [].

<div class="p"><!----></div>
This document revises Version 1.7 of the Report, released in
September 2008.  It documents the language corresponding to Version
2.0 of the implementation. Version 1.7 of the report was co-authored by
Nathaniel Nystrom. The design of structs in X10 was led by Olivier Tardieu
and Nathaniel Nystrom.

<div class="p"><!----></div>
Earlier implementations benefited from significant contributions by
Raj Barik, 
Philippe Charles, 
David Cunningham,
Christopher Donawa, 
Robert Fuhrer,
Christian Grothoff,
Nathaniel Nystrom,  
Igor Peshansky,  
Vijay Saraswat,
Vivek Sarkar, 
Olivier Tardieu,  
Pradeep Varma, 
Krishna Nandivada Venkata, and
Christoph von Praun.
Tong Wen has written many application programs
in X10. Guojing Cong has helped in the
development of many applications.
The implementation of generics in X10 was influenced by the
implementation of PolyJ&#126;[] by Andrew Myers and Michael Clarkson.

<div class="p"><!----></div>
 



<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />Introduction</h1>

<div class="p"><!----></div>

<h3>Background</h3>
Larger computational problems require more powerful computers capable of
performing a larger number of operations per second. The era of
increasing performance by simply increasing clocking frequency now
seems to be behind us. It is becoming increasingly difficult
to mange chip power and heat.  Instead, computer
designers are starting to look at <em>scale out</em> systems in which the
system's computational capacity is increased by adding additional
nodes of comparable power to existing nodes, and connecting nodes with
a high-speed communication network.

<div class="p"><!----></div>
A central problem with scale out systems is a definition of the <em>
memory model</em>, that is, a model of the interaction between shared
memory and  simultaneous (read, write) operations on that
memory by multiple processors. The traditional "one operation at a
time, to completion" model that underlies Lamport's notion of <em>
sequential consistency</em> (SC) proves too expensive to implement in
hardware, at scale. Various models of <em>relaxed consistency</em> have
proven too difficult for programmers to work with.  

<div class="p"><!----></div>
One response to this problem has been to move to a <em>fragmented
memory model</em>. Multiple processors are made to interact via a
relatively language-neutral message-passing format such as MPI
[]. This model has enjoyed some success: several
high-performance applications have been written in this
style. Unfortunately, this model leads to a <em>loss of programmer
productivity</em>: the message-passing format is integrated into the host
language by means of an application-programming interface (API), the
programmer must explicitly represent and manage the interaction
between multiple processes and choreograph their data exchange; large
data-structures (such as distributed arrays, graphs, hash-tables) that
are conceptually unitary must be thought of as fragmented across
different nodes; all processors must generally execute the same code
(in an SPMD fashion) etc.

<div class="p"><!----></div>
One response to this problem has been the advent of the <em>
partitioned global address space</em> (PGAS) model underlying languages
such as UPC, Titanium and Co-Array Fortran [,]. These
languages permit the programmer to think of a single computation
running across multiple processors, sharing a common address
space. All data resides at some processors, which is said to have <em>
affinity</em> to the data.  Each processor may operate directly on the
data it contains but must use some indirect mechanism to access or
update data at other processors. Some kind of global <em>barriers</em>
are used to ensure that processors remain roughly in lock-step.

<div class="p"><!----></div>
X10 is a modern object-oriented programming language
in the PGAS family. The fundamental goal of X10 is to enable
scalable, high-performance, high-productivity transformational
programming for high-end computers-for traditional numerical
computation workloads (such as weather simulation, molecular dynamics,
particle transport problems etc) as well as commercial server
workloads.

<div class="p"><!----></div>
X10 is based on state-of-the-art object-oriented
programming ideas primarily to take advantage of their proven
flexibility and ease-of-use for a wide spectrum of programming
problems. X10 takes advantage of several years of research (e.g.,
in the context of the Java Grande forum,
[,]) on how to adapt such languages to the context of
high-performance numerical computing. Thus X10 provides support
for user-defined <em>struct types</em> (such as <b>Int</b>, <b>Float</b>,
<b>Complex</b> etc), supports a very
flexible form of multi-dimensional arrays (based on ideas in ZPL
[]) and supports IEEE-standard floating point arithmetic.
Some capabilities for supporting operator overloading are also provided.

<div class="p"><!----></div>
X10 introduces a flexible treatment of concurrency, distribution
and locality, within an integrated type system. X10 extends the
PGAS model with <em>asynchrony</em> (yielding the <em>APGAS</em> programming
model). X10 introduces <em>places</em> as an abstraction for a
computational context with a locally synchronous view of shared
memory. An X10 computation runs over a large collection of places.
Each place hosts some data and runs one or more <em>
activities</em>. Activities are extremely lightweight threads of
execution. An activity may synchronously (and <em>atomically</em>) use
one or more memory locations in the place in which it resides,
leveraging current symmetric multiprocessor (SMP) technology.  
To access or update memory at other places, it must 
spawn activities asynchronously (either explicitly or implicitly).
X10 provides weaker ordering guarantees for
inter-place data access, enabling applications to scale.  <em>
Immutable</em> data needs no consistency management and may be freely
copied by the implementation between places.  One or more <em>clocks</em>
may be used to order activities running in multiple
places.  Arrays may be distributed across multiple
places. Arrays support parallel collective operations. A novel
exception flow model ensures that exceptions thrown by asynchronous
activities can be caught at a suitable parent activity.  The type
system tracks which memory accesses are local. The programmer may
introduce place casts which verify the access is local at run time.
Linking with native code is supported.

<div class="p"><!----></div>
X10 v2.1builds on v1.7 to support the following features: <em>
  structs</em> (i.e., "header-less", inlinable objects), type rules for
preventing escape of  from a constructor, 
the introduction of a global object model, permitting user-specified
(immutable) fields to be replicated with the object reference.
 classes are no longer supported; their functionality is
accomplished by using structs or global fields and methods.

<div class="p"><!----></div>
Several representative idioms for concurrency and communication have
already found pleasant expression in X10. We intend to develop
several full-scale applications to get better experience with the
language, and revisit the design in the light of this experience.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp2">
Chapter 2 </a><br />Overview of X10</h1>

<div class="p"><!----></div>
X10 is a statically typed object-oriented language, extending a
sequential core language with
<em>places</em>, <em>activities</em>, <em>clocks</em>,
(distributed, multi-dimensional) <em>arrays</em> and <em>struct</em>
types. All these changes are motivated by the desire to use the new
language for high-end, high-performance, high-productivity computing.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Object-oriented features</h2>

<div class="p"><!----></div>
The sequential core of X10 is a <em>container-based</em> object-oriented language
similar to Java and C++, and more recent language such as Scala.  
Programmers write X10 code by defining containers for data and behavior called
<em>interfaces</em>
(&#167;),
<em>classes</em>
(&#167;) and
<em>structs</em>
(&#167;).
X10 provides inheritance and subtyping in fairly traditional ways. 

<div class="p"><!----></div>
<b>Normed</b> describes entities with a <b>norm()</b> method. <b>Normed</b> is
intended to be used for entities with a position in some coordinate system,
and <b>norm()</b> gives the distance between the entity and the origin. A
<b>Slider</b> is an object which can be moved around on a line; a
<b>PlanePoint</b> is a fixed position in a plane. Both <b>Slider</b>s and
<b>PlanePoint</b>s have a sensible <b>norm()</b> method, and implement
<b>Normed</b>.

<div class="p"><!----></div>
<pre>
interface Normed {
  def norm():Double;
}
class Slider implements Normed {
  var x : Double = 0;
  public def norm() = Math.abs(x);
  public def move(dx:Double) { x += dx; }
}
struct PlanePoint implements Normed {
  val x : Double, y:Double;
  public def this(x:Double, y:Double) {
    this.x = x; this.y = y;
  }
  public def norm() = Math.sqrt(x*x+y*y);
}
</pre>


<div class="p"><!----></div>

<b>Interfaces&nbsp;&nbsp;</b>

<div class="p"><!----></div>
An X10 interface specifies a collection of abstract methods; <b>Normed</b>
specifies just <b>norm()</b>. Classes and
structs can be specified to <em>implement</em> interfaces, as <b>Slider</b> and
<b>PlanePoint</b> implement <b>Normed</b> , and, when they do so, must provide
all the methods that the interface demands.

<div class="p"><!----></div>
Interfaces are
purely abstract. Every value of type <b>Normed</b> must be an instance of some
class like <b>Slider</b> or some struct like <b>PlanePoint</b> which implements
<b>Normed</b>; no value can be <b>Normed</b> and nothing else. 

<div class="p"><!----></div>

<b>Classes and Structs&nbsp;&nbsp;</b>

<div class="p"><!----></div>
There are two kinds of concrete containers: <em>classes</em>
(&#167;) and <em>structs</em> (&#167;). Concrete
containers hold data in <em>fields</em>, and give concrete implementations of
methods, as <b>Slider</b> and <b>PlainPoint</b> above.

<div class="p"><!----></div>
Classes are organized in a single-inheritance tree: a class may have only a
single parent class, though it may implement many interfaces and have many
subclasses. Classes may have mutable fields, as <b>Slider</b> does.

<div class="p"><!----></div>
In contrast, structs are headerless values, lacking the internal organs
which give objects their intricate behavior.  This makes them less powerful
than objects (&lt;em&#62;e.g.&lt;/em&#62;, structs cannot inherit methods, though objects can), but also
cheaper (&lt;em&#62;e.g.&lt;/em&#62;, they can be inlined, and they require less space than objects).  
Structs are immutable, though their fields may be immutably set to objects
which are themselves mutable.  They behave like objects in all ways consistent
with these limitations; &lt;em&#62;e.g.&lt;/em&#62;, while they cannot <em>inherit</em> methods, they can
have them - as <b>PlanePoint</b> does.

<div class="p"><!----></div>
X10 has no primitive classes per se. However, the standard library
<b>x10.lang</b> supplies structs <b>Boolean</b>, <b>Byte</b>, <b>Short</b>,
<b>Char</b>, <b>Int</b>, <b>Long</b>, <b>Float</b>, <b>Double</b>, <b>Complex</b>
and <b>String</b>. The user may defined additional arithmetic structs using the
facilities of the language.

<div class="p"><!----></div>

<b>Functions.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
X10 provides functions (&#167;) to allow code to be used
as values.  Functions are first-class data: they can be stored in lists,
passed between activities, and so on.  <b>square</b>, below, is a function
which squares an <b>Int</b>.  <b>of4</b> takes an <b>Int</b>-to-<b>Int</b>
function and applies it to the number <b>4</b>.  So, <b>fourSquared</b> computes
<b>of4(square)</b>, which is <b>square(4)</b>, which is 16, in a fairly
complicated way.
<pre>
  val square = (i:Int) =&#62; i*i;
  val of4 = (f: (Int)=&#62;Int) =&#62; f(4);
  val fourSquared = of4(square);
</pre>

<div class="p"><!----></div>
They are used extensively in X10
programs.  For example, the normal way to construct an <b>Array[Int](1)</b> -
that is, a fixed-length array of numbers, like an <b>int[]</b> in Java - is to
pass two arguments to a factory method: the first argument being the length of
the rail, and the second being a function which computes the initial value of
the <b>i</b><sup>th</sup> element.  The following code constructs a rail
initialized to the squares of 0,1,...,9: <b>r(0) == 0</b>, <b>r(5)==25</b>, etc. 
<pre>
  val r : Array[Int](1) = new Array[Int](10, square);
</pre>

<div class="p"><!----></div>

<b>Constrained Types&nbsp;&nbsp;</b>

<div class="p"><!----></div>
X10 containers may declare <em>properties</em>, which are fields bound immutably
at the creation of the container.  The static analysis system understands
properties, and can work with them logically.   

<div class="p"><!----></div>
For example, an implementation of matrices <b>Mat</b> might have the numbers of
rows and columns as properties.  A little bit of care in definitions allows
the definition of a <b>+</b> operation that works on matrices of the same
shape, and <b>*</b> that works on matrices with appropriately matching shapes
The following code typechecks, but an attempt to compute <b>axb1 + bxc</b> or
<b>bxc * axb1</b> would result in a compile-time type error:
<pre>
  static def example(a:Int, b:Int, c:Int) {
    val axb1 : Mat(a,b) = makeMat(a,b);
    val axb2 : Mat(a,b) = makeMat(a,b);
    val bxc  : Mat(b,c) = makeMat(b,c);
    val axc  : Mat(a,c) = (axb1 +axb2) * bxc;
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
The "little bit of care" shows off many of the features of constrained
types.    
The <b>(rows:Int, cols:Int)</b> in the class definition declares two
properties, <b>rows</b> and <b>cols</b>.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>  

<div class="p"><!----></div>
A constrained type looks like <b>Mat{self.rows==r &amp;&amp; self.cols==c}</b>: a type
name, followed by a Boolean expression in braces.  The special variable
<b>self</b> refers to the matrix whose number of rows and columns is being
checked.  The <b>type</b> declaration on the second line makes
<b>Mat(2,3)</b> be a synonym for <b>Mat{self.rows==r &amp;&amp; self.cols==c}</b>,
allowing for compact types in many places.

<div class="p"><!----></div>
Functions can return constrained types.  
The <b>makeMat(r,c)</b> method returns a <b>Mat(r,c)</b> - a matrix whose shape
is given by the arguments to the method.  For the sake of brevity in
the example, it returns <b>null</b>; in real code, it would actually produce a
matrix - which must be statically provable to have the right shape.  In
particular, constructors can have constrained return types to provide specific
information about the constructed values.

<div class="p"><!----></div>
The arguments of methods can have type constraints as well.  The 
<b>operator this +</b> line lets <b>A+B</b> add two matrices.  The type of the
second argument <b>y</b> is constrained to have the same number of rows and
columns as the first argument <b>this</b>. Attempts to add mismatched matrices
will be flagged as type errors at compilation.

<div class="p"><!----></div>
At times it is more convenient to put the constraint on the method as a whole,
as seen in the <b>operator this *</b> line. Unlike for <b>+</b>, there is no
need to constrain both dimensions; we simply need to check that the columns of
the left factor match the rows of the right. This constraint is written in
<b>{...}</b> after the argument list.  The shape of the result is computed from
the shapes of the arguments.

<div class="p"><!----></div>
And that is all that is necessary for a user-defined class of matrices to have
shape-checking for matrix addition and multiplication.  The <b>example</b>
method compiles under those definitions.

<div class="p"><!----></div>
<pre>
abstract class Mat(rows:Int, cols:Int) {
 static type Mat(r:Int, c:Int) = Mat{self.rows==r&amp;&amp;self.cols==c};
 static def makeMat(r:Int,c:Int) : Mat(r,c) = null;
 abstract operator this + (y:Mat(this.rows,this.cols))
                 :Mat(this.rows, this.cols);
 abstract operator this * (y:Mat) {this.cols == y.rows} 
                 :Mat(this.rows, y.cols);
</pre>

<div class="p"><!----></div>

<b>Generic types&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Containers may have type parameters, permitting the definition of
<em>generic types</em>.  Type parameters may be instantiated by any X10 type.  It
is thus possible to make a list of integers <b>List[Int]</b>, a list of
non-zero integers <b>List[Int{self != 0}]</b>, or a list of people
<b>List[Person]</b>.  In the definition of <b>List</b>, <b>T</b> is a type
parameter; it can be instantiated with any type.
<pre>
class List[T] {
    var head: T;
    var tail: List[T];
    def this(h: T, t: List[T]) { head = h; tail = t; }
    def add(x: T) {
        if (this.tail == null)
            this.tail = new List(x, null);
        else
            this.tail.add(x);
    }
}
</pre>
The constructor (<b>def this</b>) initializes the fields of the new object.
The <b>add</b> method appends an element to the list.
<b>List</b> is a generic type.  When  instances of <b>List</b> are
allocated, the type parameter <b>T</b> must be bound to a concrete
type.  <b>List[Int]</b> is the type of lists of element type
<b>Int</b>, <b>List[List[String]]</b> is the type of lists whose elements are
themselves lists of string, and so on.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;The sequential core of X10</h2>

<div class="p"><!----></div>
The sequential aspects of X10 are mostly familiar from C and its progeny.
X10 enjoys the familiar control flow constructs: <b>if</b> statements,
<b>while</b> loops, <b>for</b> loops, <b>switch</b> statements, <b>throw</b> to
raise exceptions and <b>try...catch</b> to handle them, and so on.

<div class="p"><!----></div>
X10 has both implicit coercions and explicit conversions, and both can be
defined on user-defined types.  Explicit conversions are written with the
<b>as</b> operation: <b>n as Int</b>.  The types can be constrained: 
<b>n as Int{self != 0}</b> converts <b>n</b> to a non-zero integer, and throws a
runtime exception if its value as an integer is zero.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Places and activities</h2>

<div class="p"><!----></div>
The full power of X10 starts to emerge with concurrency.
An X10 program is intended to run on a wide range of computers,
from uniprocessors to large clusters of parallel processors supporting
millions of concurrent operations. To support this scale, X10
introduces the central concept of <em>place</em> (&#167;).
A place can be thought of as a virtual shared-memory multi-processor:
a computational unit with a finite (though perhaps changing) number of
hardware threads and a bounded amount of shared memory, uniformly
accessible by all threads.

<div class="p"><!----></div>
An X10 computation acts on <em>values</em>(&#167;) through
the execution of lightweight threads called
<em>activities</em>(&#167;). 
An <em>object</em>
 has a small, statically fixed set of fields, each of
which has a distinct name. A scalar object is located at a single place and
stays at that place throughout its lifetime. An <em>aggregate</em> object has
many fields (the number may be known only when the object is created),
uniformly accessed through an index (&lt;em&#62;e.g.&lt;/em&#62;, an integer) and may be distributed
across many places. The distribution of an aggregate object remains unchanged
throughout the computation, thought different aggregates may be distributed
differently. Objects are garbage-collected when no longer useable; there are
no operations in the language to allow a programmer to explicitly release
memory.

<div class="p"><!----></div>
X10 has a <em>unified</em> or <em>global address space</em>. This means that
an activity can reference objects at other places. However, an activity may
synchronously access data items only in the current place, the place in which
it is running. It may atomically update one or more data items, but only in
the current place.   If it becomes necessary to read or modify an object at
some other place <b>q</b>, the <em>place-shifting</em> operation <b>at(q)</b> can
be used, to move part of the activity to <b>q</b>.   It is easy to compute
across multiple places, but the expensive operations (&lt;em&#62;e.g.&lt;/em&#62;, those which require
communication) are readily visible in the code. 

<div class="p"><!----></div>

<b>Atomic blocks.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
X10 has a control construct <b>atomic S</b> where <b>S</b> is a statement with
certain restrictions. <b>S</b> will be executed atomically, without
interruption by other activities. This is a common primitive used in
concurrent algorithms, though rarely provided in this degree of generality by
concurrent programming languages.

<div class="p"><!----></div>
More powerfully - and more expensively - X10 allows conditional atomic
blocks, <b>when(B)S</b>, which are executed atomically at some point when
<b>B</b> is true.  Conditional atomic blocks are one of the strongest
primitives used in concurrent algorithms, and one of the least-often
available. 

<div class="p"><!----></div>

<b>Asynchronous activities.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
An asynchronous activity is created by a statement <b>async S</b>, which starts
up a new activity running <b>S</b>.  It does not wait for the new activity to
finish; there is a separate statement (<b>finish</b>) to do that.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;Clocks</h2>
The MPI style of coordinating the activity of multiple processes with
a single barrier is not suitable for the dynamic network of heterogeneous
activities in an X10 computation.  
X10 allows multiple barriers in a form that supports determinate,
deadlock-free parallel computation, via the <b>Clock</b> type.

<div class="p"><!----></div>
A single <b>Clock</b> represents a computation that occurs in phases.
At any given time, an activity is <em>registered</em> with zero or more clocks.
The X10 statement <b>next</b> tells all of an activity's registered clocks that
the activity has finished the current phase, and causes it to wait for the
next phase.  Other operations allow waiting on a single clock, starting
new clocks or new activities registered on an extant clock, and so on. 

<div class="p"><!----></div>

<div class="p"><!----></div>
Clocks act as barriers for a dynamically varying collection of activities.
They generalize the barriers found in MPI style program in that an activity
may use multiple clocks simultaneously. Yet programs using clocks properly are
guaranteed not to suffer from deadlock.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2.5">
2.5</a>&nbsp;&nbsp;Arrays, regions and distributions</h2>

<div class="p"><!----></div>
X10 provides <b>DistArray</b>s, <em>distributed arrays</em>, which spread data
across many places. An underlying <b>Dist</b> object provides the <em>
distribution</em>, telling which elements of the <b>DistArray</b> go in which
place. <b>Dist</b> uses subsidiary <b>Region</b> objects to abstract over the
shape and even the dimensionality of arrays.
Specialized X10 control statements such as <b>ateach</b> provide efficient
parallel iteration over distributed arrays.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2.6">
2.6</a>&nbsp;&nbsp;Annotations</h2>

<div class="p"><!----></div>
X10 supports annotations on classes and interfaces, methods
and constructors,
variables, types, expressions and statements.
These annotations may be processed by compiler plugins.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2.7">
2.7</a>&nbsp;&nbsp;Translating MPI programs to X10</h2>

<div class="p"><!----></div>
While X10 permits considerably greater flexibility in writing
distributed programs and data structures than MPI, it is instructive
to examine how to translate MPI programs to X10.

<div class="p"><!----></div>
Each separate MPI process can be translated into an X10
place. Async activities may be used to read and write variables
located at different processes. A single clock may be used for barrier
synchronization between multiple MPI processes. X10 collective
operations may be used to implement MPI collective operations.
X10 is more general than MPI in (a)&#241;ot requiring synchronization
between two processes in order to enable one to read and write the
other's values, (b)&#126;permitting the use of high-level atomic blocks
within a process to obtain mutual exclusion between multiple
activities running in the same node (c)&#126;permitting the use of multiple
clocks to combine the expression of different physics (e.g.,
computations modeling blood coagulation together with computations
involving the flow of blood), (d)&#241;ot requiring an SPMD style of
computation.

<div class="p"><!----></div>

 <h2><a name="tth_sEc2.8">
2.8</a>&nbsp;&nbsp;Summary and future work</h2>

     <h3><a name="tth_sEc2.8.1">
2.8.1</a>&nbsp;&nbsp;Design for scalability</h3>
X10 is designed for scalability, by encouraging working with local data,
and limiting the ability of events at one place to delay those at another. For
example, an activity may atomically access only multiple locations in the
current place. Unconditional atomic blocks are statically guaranteed to be
non-blocking, and may be implemented using non-blocking techniques that avoid
mutual exclusion bottlenecks. Data-flow synchronization permits point-to-point
coordination between reader/writer activities, obviating the need for
barrier-based or lock-based synchronization in many cases.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.8.2">
2.8.2</a>&nbsp;&nbsp;Design for productivity</h3>
X10 is designed for productivity.

<div class="p"><!----></div>

<b>Safety and correctness.&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Programs written in X10 are guaranteed to be statically
<em>type safe</em>, <em>memory safe</em> and <em>pointer safe</em>. 

<div class="p"><!----></div>
Static type safety guarantees that every location contains only values whose
dynamic type agrees with the location's static type. The compiler allows a
choice of how to handle method calls. In strict mode, method calls are
statically checked to be permitted by the static types of operands. In lax
mode, dynamic checks are inserted when calls may or may not be correct,
providing weaker static correctness guarantees but more programming
convenience. 

<div class="p"><!----></div>
Memory safety guarantees that an object may only access memory within its
representation, and other objects it has a reference to. X10 supports no
pointer arithmetic, and bound-checks array accesses dynamically if necessary.
X10 uses garbage collection to collect objects no longer referenced by any
activity. X10 guarantees that no object can retain a reference to an
object whose memory has been reclaimed. Further, X10 guarantees that every
location is initialized at run time before it is read, and every value read
from a word of memory has previously been written into that word.

<div class="p"><!----></div>

<div class="p"><!----></div>
Because places are reflected in the type system, static type safety
also implies <em>place safety</em>. All operations that need to be performed
locally are, in fact, performed locally.  All data which is declared to be
stored locally are, in fact, stored locally.

<div class="p"><!----></div>
X10 programs that use only clocks and unconditional atomic
blocks are guaranteed not to deadlock. Unconditional atomic blocks
are non-blocking, hence cannot introduce deadlocks.
Many concurrent programs can be shown to be determinate (hence
race-free) statically.

<div class="p"><!----></div>

<b>Integration.&nbsp;&nbsp;</b>
A key issue for any new programming language is how well it can be
integrated with existing (external) languages, system environments,
libraries and tools.

<div class="p"><!----></div>
We believe that X10, like Java, will be able to support a large
number of libraries and tools. An area where we expect future versions
of X10 to improve on Java like languages is <em>native
integration</em> (&#167;). Specifically, X10 will permit
permit multi-dimensional local arrays to be operated on natively by
native code.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.8.3">
2.8.3</a>&nbsp;&nbsp;Conclusion</h3>
X10 is considerably higher-level than thread-based languages in
that it supports dynamically spawning very lightweight activities, the
use of atomic operations for mutual exclusion, and the use of clocks
for repeated quiescence detection.

<div class="p"><!----></div>
Yet it is much more concrete than languages like HPF in that it forces
the programmer to explicitly deal with distribution of data
objects. In this the language reflects the designers' belief that
issues of locality and distribution cannot be hidden from the
programmer of high-performance code in high-end computing.  A
performance model that distinguishes between computation and
communication must be made explicit and transparent.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>
At the same time we believe that the place-based type system and
support for generic programming will allow the X10 programmer to
be highly productive; many of the tedious details of
distribution-specific code can be handled in a generic fashion.

<div class="p"><!----></div>
We expect the next version of the language to be significantly
informed by experience in implementing and using the language. We
expect it to have constructs to support continuous program
optimization, and allow the programmer to provide guidance on
clustering places to (hardware) nodes. 




<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp3">
Chapter 3 </a><br />Lexical structure</h1>

<div class="p"><!----></div>
In general, X10 follows Java rules [,Chapter 3] for
lexical structure.

<div class="p"><!----></div>
Lexically a program consists of a stream of white space, comments,
identifiers, keywords, literals, separators and operators.

<div class="p"><!----></div>

<b>Whitespace&nbsp;&nbsp;</b>
ASCII space, horizontal tab (HT), form feed (FF) and line
terminators constitute white space.

<div class="p"><!----></div>

<b>Comments&nbsp;&nbsp;</b>
All text included within the ASCII characters "<b>/*</b>" and
"<b>*/</b>" is
considered a comment and ignored; nested comments are not
allowed.  All text from the ASCII characters
"<b>//</b>" to the end of line is considered a comment and is ignored.

<div class="p"><!----></div>

<b>Identifiers&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Identifiers <a name="identifier30">
</a> are defined as in Java.
Identifiers consist of a single letter followed by zero or more
letters or digits.
Letters are defined as the characters for which the Java
method <b>Character.isJavaIdentifierStart</b> returns true.
Digits are defined as the ASCII characters <b>0</b> through <b>9</b>.

<div class="p"><!----></div>

<b>Keywords&nbsp;&nbsp;</b>
X10 reserves the following keywords:
<pre>
abstract        any             as              async
at              ateach          atomic          await
break           case            catch           class
clocked         continue        current
def             default         do              else
extends         extern          final           finally
finish          for             foreach         future
global
goto            has             here            if             
implements      import          in
instanceof      interface
native          new             next            nonblocking     
offer           offers
or              package         pinned          private        
protected       property        public          return
safe            self            sequential      shared
static
super           switch          this            throw
throws          to              try             type
val             value           var             when
while
</pre>
Note that the primitive types are not considered keywords.
The keyword  is reserved, but not used.

<div class="p"><!----></div>

<b>Literals&nbsp;&nbsp;</b><a name="Literals">
</a><a name="literals30">
</a>

<div class="p"><!----></div>
Briefly, X10 v2.1 uses fairly standard syntax for its literals:
integers, unsigned integers, floating point numbers, booleans, 
characters, strings, and <b>null</b>.  The most exotic points are (1) unsigned
numbers are marked by a <b>u</b> and cannot have a sign; (2) <b>true</b> and
<b>false</b> are the literals for the booleans; and (3) floating point numbers
are <b>Double</b> unless marked with an <b>f</b> for <b>Float</b>. 

<div class="p"><!----></div>
Less briefly, we use the following abbreviations: 

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#948; = <span class="roman">one</span> <span class="roman">or</span> <span class="roman">more</span> <span class="roman">decimal</span> <span class="roman">digits</span></td></tr></table></td></tr>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#948;<sub>8</sub> = <span class="roman">one</span> <span class="roman">or</span> <span class="roman">more</span> <span class="roman">octal</span> <span class="roman">digits</span></td></tr></table></td></tr>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#948;<sub>16</sub> = <span class="roman">one</span> <span class="roman">or</span> <span class="roman">more</span> <span class="roman">hexadecimal</span> <span class="roman">digits</span><span class="roman">,</span> <span class="roman">using</span> <b><b>a</b></b>&#8722;<b><b>f</b></b><span class="roman">for</span> <span class="roman">10</span>&#8722;<span class="roman">15</span></td></tr></table></td></tr>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#953; = &#948; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124; <tt>0</tt> &#948;<sub>8</sub>  </td></tr></table></td><td align="left"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124; <tt>0</tt><tt>x</tt> &#948;<sub>16</sub> </td></tr></table></td><td align="left"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124; <tt>0</tt><tt>X</tt> &#948;<sub>16</sub></td></tr></table></td></tr>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#963; = <span class="roman">optional</span> <b><b>+</b></b> <span class="roman">or</span> <b>&#8722;</b></td></tr></table></td></tr>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#946; = &#948; </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124; &#948;<tt>.</tt> </td></tr></table></td><td align="left"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124; &#948;<tt>.</tt> &#948; </td></tr></table></td><td align="left"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124; <tt>.</tt> &#948;</td></tr></table></td></tr>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#958; = (<tt>e</tt>  </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#124; <tt>E</tt>) &#963; &#948;</td></tr></table></td></tr>
<tr><td align="right"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
&#981; = &#946;&#958;</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>

<ul>
<li> <b>true</b> and <b>false</b> are the <b>Boolean</b> literals.
<div class="p"><!----></div>
</li>

<li> <b>null</b> is a literal for the null value.  It has type
      <b>Anyself==null</b>.
<div class="p"><!----></div>
</li>

<li> <b>Int</b> literals have the form &#963;&#953;; , <b>123</b>,
      <b>-321</b> are decimal <b>Int</b>s, <b>0123</b> and <b>-0321</b> are octal
      <b>Int</b>s, and <b>0x123</b>, <b>-0X321</b>,  <b>0xBED</b>, and <b>0XEBEC</b> are
      hexadecimal <b>Int</b>s.
<div class="p"><!----></div>
</li>

<li> <b>Long</b> literals have the form &#963;&#953;<tt>l</tt> or
      &#963;&#953;<tt>L</tt>. , <b>1234567890L</b>  and <b>0xBAGEL</b> are <b>Long</b> literals.
<div class="p"><!----></div>
</li>

<li> <b>UInt</b> literals have the form &#953;<tt>u</tt> or &#953;<tt>U</tt>.
      , <b>123u</b>, <b>0123u</b>, and <b>0xBEAU</b> are <b>UInt</b> literals.
<div class="p"><!----></div>
</li>

<li> <b>ULong</b> literals have the form &#953;<tt>ul</tt> or &#953; <tt>lu</tt>, or capital versions of those.  For example, 
      <b>123ul</b>, <b>0124567012ul</b>,  <b>0xFLU</b>, <b>OXba1eful</b>, and <b>0xDecafC0ffeefUL</b> are <b>ULong</b>
      literals.
<div class="p"><!----></div>
</li>

<li> <b>Float</b> literals have the form &#963;&#981;<tt>f</tt> or  &#963; &#981;<tt>F</tt>.  Note that the floating-point marker letter <b>f</b> is
      required: unmarked floating-point-looking literals are <b>Double</b>. 
      , <b>1f</b>, <b>6.023E+32f</b>, <b>6.626068E-34F</b> are <b>Float</b>
      literals.
<div class="p"><!----></div>
</li>

<li> <b>Double</b> literals have the form &#963;&#981;<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>, &#963;&#981; <tt>D</tt>, and &#963;&#981;<tt>d</tt>.  
      , <b>0.0</b>, <b>0e100</b>, <b>229792458d</b>, and <b>314159265e-8</b>
      are <b>Double</b> literals.
<div class="p"><!----></div>
</li>

<li> <b>Char</b> literals have one of the following forms: 
      
<ul>
<li> <b>'</b><i>c</i><b>'</b> where <em>c</em> is any printing ASCII
            character other than 
            <b>} or <b>'</b>, representing the character <em>c</em> itself; 
            , <b>'!'</b>;</b>
<li> <b>'\b'</b>, representing backspace;
<div class="p"><!----></div>
</li>

<li> <b>'\t'</b>, representing tab;
<div class="p"><!----></div>
</li>

<li> <b>'\n'</b>, representing newline;
<div class="p"><!----></div>
</li>

<li> <b>'\f'</b>, representing form feed;
<div class="p"><!----></div>
</li>

<li> <b>'\r'</b>, representing return;
<div class="p"><!----></div>
</li>

<li> <b>'\''</b>, representing single-quote;
<div class="p"><!----></div>
</li>

<li> <b>'\''</b>, representing double-quote;
<div class="p"><!----></div>
</li>

<li> <b>'\\'</b>, representing backslash;
<div class="p"><!----></div>
</li>

<li> <b>'\<em>dd</em><b>'</b>, where <em>dd</em> is one or more octal
            digits, representing the one-byte character numbered <em>dd</em>; it
            is an error if <em>dd</em> &gt; 255.</b></ul>
<div class="p"><!----></div>
</li>

<li> <b>String</b> literals consist of a double-quote <b>"</b>, followed by
      zero or more of the contents of a <b>Char</b> literal, followed by
      another double quote.  , <b>"hi!"</b>, <b>""</b>.
<div class="p"><!----></div>
</li>

<li> There are no literals of type <b>Byte</b> or <b>UByte</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<b>Separators&nbsp;&nbsp;</b>
X10 has the following separators and delimiters:
<pre>
( )  { }  [ ]  ;  ,  .
</pre>

<div class="p"><!----></div>

<b>Operators&nbsp;&nbsp;</b>
X10 has the following operators:
<pre>
==  !=  &lt;   &#62;   &lt;=  &#62;=
&amp;&amp;  </td><td width="150">
&#124;</td><td width="150">
&#124;  &amp;   </td><td width="150">
&#124;   ^
&lt;&lt;  &#62;&#62;  &#62;&#62;&#62;
+   -   *   /   %
++  -  !   &#126;
&amp;=  </td><td width="150">
&#124;=  ^=
&lt;&lt;= &#62;&#62;= &#62;&#62;&#62;=
+=  -=  *=  /=  %=
=   ?   :   =&#62;  -&#62;
&lt;:  :&#62;  @   ..
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp4">
Chapter 4 </a><br />Types</h1>
<a name="XtenTypes">
</a><a name="types40">
</a>

<div class="p"><!----></div>
X10 is a <em>strongly typed</em> object-oriented language: every
variable and expression has a type that is known at compile-time.
Types limit the values that variables can hold and specify the places
at which these values can lie.

<div class="p"><!----></div>
X10 supports three kinds of runtime entities, <em>objects</em>,
<em>structs</em>, and <em>functions</em>. Objects are instances of <em>
  classes</em> (&#167;). They may contain mutable fields
and stay resident in the place in which they were
created. 
Objects are said to be <em>boxed</em> in that variables of a
class type are implemented through a single memory location that
contains a reference to the memory containing the declared state of
the object (and other meta-information such as the list of methods of
the object). Thus objects are represented through an extra level of
indirection. A consequence of this flexibility is that every class
type contains the value <b>null</b> corresponding to the invalid
reference. <b>null</b> is often useful as a default value. Further, two
objects may be compared for identity (<b>==</b>) in constant time by
simply containing references to the memory used to represent the
objects.

<div class="p"><!----></div>
Structs are instances of <em>struct types</em> (&#167;). They are a
restricted variant of classes, lacking meta-information; this makes them less
flexible, but in many cases more efficient. When it is semantically
meaningful, converting a class into a struct or vice-versa is quite easy.
Structs are immutable and may be freely copied from place to place. Further,
they may be allocated inline, using only as much memory as necessary to hold
and align the fields of the struct.

<div class="p"><!----></div>
Functions, called closures or lambda-expressions in other languages, are
instances of <em>function types</td><td width="150">
&#124;</em> (&#167;). Functions can refer to
variables from the surrounding environment; &lt;em&#62;e.g.&lt;/em&#62;, <b>(x:Int)=&#62;x*y</b> is a unary
integer function which multiplies its argument by the variable <b>y</b> from
the surrounding block.  
Functions may be freely copied from place to place and may be repeatedly
applied to a set of arguments.

<div class="p"><!----></div>
These runtime entities are classified by <em>types</em>. Types are used in
variable declarations, explicit coercions and conversions, object creation,
array creation, class literals, static state and method accessors, and
<b>instanceof</b> expressions.

<div class="p"><!----></div>
The basic relationship between values and types is <em>instantiation</em>. For
example, <b>1</b> is an instance of type of integers, <b>Int</b>. It is also an
instance of type of all entities <b>Any</b>, and of type of nonzero integers
<b>Int{self != 0}</b>, and many others.

<div class="p"><!----></div>
The basic relationship between types is <em>subtyping</em>: <b>T &lt;: U</b> holds if
every instance of <b>T</b> is also an instance of <b>U</b>. Two important kinds
of subtyping are <em>subclassing</em> and <em>strengthening</em>.  Subclassing is a
familiar notion from object-oriented programming.  In a class
hierarchy with classes <b>Animal</b> and <b>Cat</b> arranged in the usual way,
every <b>Cat</b> is an <b>Animal</b>, so <b>Cat &lt;: Animal</b> by subclassing.  
Strengthening is an equally familiar notion from logic.   The instances of
<b>Int{self != 0}</b> are all elements of <b>Int{true}</b> as well, because
<b>self != 0</b> logically implies <b>true</b>; so 
<b>Int{self != 0} &lt;: Int{true} == Int</b> by strengthening.  X10 uses both
notions of subtyping.  See &#167; for the full definition
of subtyping in X10.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.0.4">
4.0.4</a>&nbsp;&nbsp;Type System</h3>
<a name="type system40">
</a>
The types in X10 are as follows.  These are the <em>semantic</em> types. Other
syntactic forms for types exist, but they are simply abbreviations for types
in the following system.  For example, <b>Array[Int](1)</b> is the type of
one-dimensional integer-valued arrays; it is an abbreviation for
<b>Array[Int]{rank==1}</b>.<br />

  :
  |
  
  
  
  <em>
  
<table>

<tr><td align="right">
<div class="p"><!----></div>
Type ::= TypeName </td></tr>
<tr><td align="right">&#124; TypeName <b>[</b> Types<sup>?</sup>&nbsp;<b>]</b> </td></tr>
<tr><td align="right">&#124; Type <b> Constraint <b></b></b> </td></tr>
<tr><td align="right">&#124; Type <b>.</b> Type </td></tr>
<tr><td align="right">&#124; TypeVar </td></tr>
<tr><td align="right">&#124; FunctionType</td></tr>
<tr><td align="right">&#124; VoidFunctionType </td></tr>
<tr><td align="right">TypeName ::= Id </td></tr>
<tr><td align="right">TypeVar ::= Id </td></tr>
<tr><td align="right">Types ::= Type </td></tr>
<tr><td align="right">&#124; Type <b>,</b> Types </td></tr>
<tr><td align="right">FunctionType ::= <b>(</b> Formals<sup>?</sup>&nbsp;<b>) =&#62;</b>  Type </td></tr>
<tr><td align="right">VoidFunctionType ::= <b>(</b> Formals<sup>?</sup>&nbsp;<b>) =&#62; void</b> </td></tr>
<tr><td align="right">Formal ::= Id <b>:</b> Type </td></tr>
<tr><td align="right">Formals ::= Formal </td></tr>
<tr><td align="right">&#124; Formal <b>,</b> Formals      
</td></tr></table>
</em>

<div class="p"><!----></div>
The type <em>TypeName</em> refers to a defined type.  For example, 
<b>Int</b>
is the type of 32-bit integers.
Given a class declaration 
<pre>
class Tripe { /* ... */ }
</pre>
the identifier <b>Tripe</b> may be used as a type.

<div class="p"><!----></div>
The type <em>TypeName <b>[</b> Types<sup>?</sup> <b>]</b></em> refers to an instance of a
generic (or parameterized) type.  For example, <b>Array[X]</b> is the built-in
type of arrays whose elements are some unspecified type <b>X</b>.
<b>Array[Int]</b> is the type of arrays of integers. 

<div class="p"><!----></div>
The type <em>Type <b> Constraint <b></b></b></em> refers to a constrained type.
<em>Constraint</em> is a Boolean expression - written in a <em>very</em> limited
subset of X10 - describing the acceptable values of the constrained type.
For example, <b>var n : Int{self != 0};</b> guarantees that <b>n</b> is always a
non-zero integer. 
Similarly, <b>var x : Tripe{x != null};</b> defines a <b>Tripe</b>-valued
variable <b>x</b> whose value is never null.

<div class="p"><!----></div>
The qualified type <em>Type <b>.</b> Type</em> refers to an instance of an <em>
inner</em> type; that is, a class or struct defined inside of another class or
struct, and holding an implicit reference to the outer.  For example, given
the type declaration 
<pre>
class Outer {
  class Inner { /* ... */ }
}
</pre>
then 
<b>(new Outer()).new Inner()</b> creates a value of type 
<b>Outer.Inner</b>.

<div class="p"><!----></div>
Type variables, <em>TypeVar</em>, refer to types that are parameters.  For
example, the following class defines a cell in a linked list.  
<pre>
class LinkedList[X] {
  val head : X;
  val tail : LinkedList[X];
  def this(head:X, tail:LinkedList[X]) {
     this.head = head; this.tail = tail;
  }
}
</pre>
It doesn't
matter what type the cell is, but it has to have <em>some</em> type.
<b>LinkedList[Int]</b> is a linked list of integers;
<b>LinkedList[LinkedList[String]]</b> a list of lists of strings.

<div class="p"><!----></div>
The function type 
<em><b>(</b> Formals<sup>?</sup> <b>) =&#62;</b>  Type</em> 
refers to functions taking the
listed formal parameters and returning a result of <em>Type</em>.  
The closely-related void function type 
<em><b>(</b> Formals<sup>?</sup> <b>) =&#62;</b>  <b>Void</b></em>  takes the listed
parameters and returns no value.
For example, 
<b>(x:Int) =&#62; Int{self != x}</b> 
is the type of integer-valued functions which have no fixed points.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Classes and interfaces</h2>
<a name="ReferenceTypes">
</a>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.1.1">
4.1.1</a>&nbsp;&nbsp;Class types</h3>

<div class="p"><!----></div>
<a name="types+class types41">
</a><a name="class41">
</a><a name="class declaration41">
</a><a name="declaration+class declaration41">
</a><a name="declaration+reference class declaration41">
</a>A <em>class declaration</em> (&#167;) introduces a <em>class type</em>
containing all instances of the class.  The <b>Position</b> class below
could describe the position of a slider control, for example.

<div class="p"><!----></div>
<pre>
class Position {
  private var x : Int = 0;
  public def move(dx:Int) { x += dx; }
  public def pos() : Int = x;
}
</pre>

<div class="p"><!----></div>
Class instances, also called objects, are created via constructor calls. Class
instances have fields and methods, type members, and value properties bound at
construction time. In addition, classes have static members: static <b>val</b> fields,
type definitions, and member classes and member interfaces.

<div class="p"><!----></div>
A class with type parameters is <em>generic</em>. A class type is instantiatable
only if all of its parameters are instantiated on concrete types.  The
<b>Cell[T]</b> class provides a container capable of holding a value of type
<b>T</b>, or being empty.

<div class="p"><!----></div>
<pre>
class Cell[T] {
  var empty : Boolean = true;
  var contents : T;
  public def this(t:T) { 
     contents = t; empty = false; 
  }
  public def putIn(t:T) { 
    contents = t; empty = false; 
  }
  public def emptyOut() { empty = true; }
  public def isEmpty() = empty;
  public def getOut():T {
     if (empty) throw new Exception(&#203;mpty!");
     return contents ;
  }
}
</pre>

<div class="p"><!----></div>
X10 does not permit mutable static state. A fundamental principle of the
X10 model of computation is that all mutable state be local to some place
(&#167;), and, as static variables are globally available, they
cannot be mutable. When mutable global state is necessary, programmers should
use singleton classes, putting the state in an object and using place-shifting
commands (&#167;) and atomicity (&#167;) as necessary
to mutate it safely.

<div class="p"><!----></div>
<a name="\textbf{Object}41">
</a><a name="\textbf{x10.lang.Object}41">
</a>Classes are structured in a single-inheritance hierarchy. All classes extend
the class <b>x10.lang.Object</b>, directly or indirectly. Each class other than
<b>Object</b> extends a single parent class.  <b>Object</b> provides no behavior
of its own, beyond that required by <b>Any</b>.

<div class="p"><!----></div>
<a name="class+reference class41">
</a><a name="reference class type41">
</a><a name="\textbf{Object}41">
</a><a name="\textbf{x10.lang.Object}41">
</a><a name="null41">
</a>Variables of class type may contain the value <b>null</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.1.2">
4.1.2</a>&nbsp;&nbsp;Interface types</h3>
<a name="InterfaceTypes">
</a>

<div class="p"><!----></div>
<a name="types+interface types41">
</a><a name="interface41">
</a><a name="interface declaration41">
</a><a name="declaration+interface declaration41">
</a>An <em>interface declaration</em> (&#167;) defines an <em>
interface type</em>, specifying a set of methods, type members, and
properties which must be provided by any class declared to implement the
interface. 

<div class="p"><!----></div>
Interfaces can also have static members: constant fields, type definitions,
and member classes and interfaces.  However, interfaces cannot specify that
implementing classes must provide static members.

<div class="p"><!----></div>
An interface may extend multiple interfaces.  
<pre>
interface Named {
  def name():String;
}
interface Mobile {
  def move(howFar:Int):Void;
}
interface Person extends Named, Mobile {}
interface NamedPoint extends Named, Mobile{} 
</pre>

<div class="p"><!----></div>
Classes may be declared to implement multiple interfaces.
Semantically, the interface type is the set of all objects that are
instances of classes that implement the interface. A class implements
an interface if it is declared to and if it implements all the methods
and properties defined in the interface.  For example, <b>KimThePoint</b>
implements <b>Person</b>, and hence <b>Named</b> and <b>Mobile</b>.  It would be
a static error if <b>KimThePoint</b> had no <b>name</b> method.

<div class="p"><!----></div>
<pre>
class KimThePoint implements Person {
   var pos : Int = 0;
   public def name() = "Kim (" + pos + ")";
   public def move(dPos:Int) { pos += dPos; }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.1.3">
4.1.3</a>&nbsp;&nbsp;Properties</h3>
<a name="properties41">
</a>
<a name="properties">
</a>

<div class="p"><!----></div>
Classes, interfaces, and structs may have <em>properties</em>, public <b>val</b> instance
fields bound on object creation. For example, the following code declares a
class named <b>Coords</b> with properties <b>x</b> and <b>y</b> and a <b>move</b>
method. The properties are bound using the <b>property</b> statement in the
constructor.

<div class="p"><!----></div>
<pre>
class Coords(x: Int, y: Int) {
  def this(x: Int, y: Int) : Coords{self.x==x, self.y==y} 
    = { property(x, y); }
  def move(dx: Int, dy: Int) = new Coords(x+dx, y+dy);
}
</pre>

<div class="p"><!----></div>
Properties, unlike other public <b>val</b> fields, can be used  
at compile time in <em>constraints</em>. This allows us
to specify subtypes based on properties, by appending a boolean expression to
the type. For example, the type <b>Coords{x==0}</b> is the set of all points
whose <b>x</b> property is <b>0</b>.  Details of this substantial topic are
found in &#167;.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Type parameters and Generic Types</h2>
<a name="TypeParameters">
</a>

<div class="p"><!----></div>
<a name="types+type parameters42">
</a><a name="methods+parametrized methods42">
</a><a name="constructors+parametrized constructors42">
</a><a name="closures+parametrized closures42">
</a><a name="Generics">
</a><a name="types+generic types42">
</a>A class, interface, method, closure, or type definition  may have type
parameters.  Type parameters can be used as types, and will be bound to types
on instantiation.  For example, a generic stack class may be defined as 
<b>Stack[T]{...}</b>.  Stacks can hold values of any type; &lt;em&#62;e.g.&lt;/em&#62;, 
<b>Stack[Int]</b> is a stack of integers, and 
<b>Stack[Point{self!=null}]</b>is a stack of non-null <b>Point</b>s.
Generics <em>must</em> be instantiated when they are used: <b>Stack</b>, by
itself, is not a valid type.
Type parameters may be constrained by a guard on the declaration
(&#167;,
&#167;,&#167;).

<div class="p"><!----></div>
<a name="types+concrete types42">
</a><a name="concrete type42">
</a>A <em>generic type</em> is a class, struct,  interface, or type declared with one or
more type parameters.  When instantiated with concrete (&lt;em&#62;viz&lt;/em&#62;, non-generic)
types for its parameters, a generic type becomes a concrete type and can be
used like any other type. For example,
<b>Stack</b> is a generic type, 
<b>Stack[Int]</b> is a concrete type, and can be used as one: 
<b>var stack : Stack[Int];</b>

<div class="p"><!----></div>
A <b>Cell[T]</b> is a generic object, capable of holding a value of type
<b>T</b>.  For example, a <b>Cell[Int]</b> can hold an <b>Int</b>, and a
<b>Cell[Cell[Int{self!=0}]]</b> can hold a <b>Cell</b> which in turn can
only hold non-zero numbers.  <b>Cell</b>s are actually useful in situations
where values must be bound immutably for one reason, but need to be mutable.
<pre>
class Cell[T] {
    var x: T;
    def this(x: T) { this.x = x; }
    def get(): T = x;
    def set(x: T) = { this.x = x; }
}
</pre>

<div class="p"><!----></div>
<b>Cell[Int]</b> is the type of <b>Int</b>-holding cells.  
The <b>get</b> method on a <b>Cell[Int]</b> returns an <b>Int</b>; the
<b>set</b> method takes an <b>Int</b> as argument.  Note that
<b>Cell</b> alone is not a legal type because the parameter is
not bound.

<div class="p"><!----></div>
Methods may be generic, even methods in non-generic classes: 
<pre>
class NonGeneric {
  static def first[T](x:List[T]):T = x(0);
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.2.1">
4.2.1</a>&nbsp;&nbsp;Variance of Type Parameters</h3>
<a name="covariant42">
</a>
<a name="contravariant42">
</a>
<a name="invariant42">
</a>
<a name="type parameter+covariant42">
</a>
<a name="type parameter+contravariant42">
</a>
<a name="type parameter+invariant42">
</a>

<div class="p"><!----></div>
Consider classes <b>Person :&#62; Child</b>.  Every child is a person, but there
are people who are not children.  What is the relationship between
<b>Cell[Person]</b> and <b>Cell[Child]</b>?  

<div class="p"><!----></div>

<h4>Why Variance Is Necessary</h4>

<div class="p"><!----></div>
In this case, <b>Cell[Person]</b> and <b>Cell[Child]</b> should be unrelated.  
If we had <b>Cell[Person] :&#62; Cell[Child]</b>, the following code would let us
assign a <b>old</b> (a <b>Person</b> but not a <b>Child</b>) to a
variable <b>young</b> of type <b>Child</b>, thereby breaking the type system: 
<pre>
// INCORRECTLY assuming Cell[Person] :&#62; Cell[Child]
val cc : Cell[Child] = new Cell[Child]();
val cp : Cell[Person] = cc; // legal upcast
cp.set(old);       // legal since old : Person
val young : Child = cc.get(); 
</pre>

<div class="p"><!----></div>
Similarly, if <b>Cell[Person] &lt;: Cell[Child]</b>: 
<pre>
// INCORRECTLY assuming Cell[Person] &lt;: Cell[Child]
val cp : Cell[Person] = new Cell[Person];
val cc : Cell[Child] = cp; // legal upcast
val cp.set(old); 
val young : Child = cc.get();
</pre>

<div class="p"><!----></div>
So, there cannot be a subtyping relationship in either direction between the
two. And indeed, neither of these programs passes the X10 typechecker.

<div class="p"><!----></div>

<h4>Legitimate Variance</h4>

<div class="p"><!----></div>
The <b>Cell[Person]</b>-vs-<b>Cell[Child]</b> problems occur because it is
possible to both store and retrieve values from the same object. However,
entities with only one of the two capabilities <em>can</em> sensibly have some
subtyping relations. Furthermore, both sorts of entity are useful. An entity
which can store values but not retrieve them can nonetheless summarize them.
An object which can retrieve values but not store values can be constructed
with an initial value, providing a read-only cell.

<div class="p"><!----></div>
So, X10 provides <em>variance</em> to support these options.  Type parameters
may be defined in one of three forms.  

<ol type="1">
<li> <em>invariant</em>: Given a definition <b>class C[T]{...}</b>, <b>C[Person]</b> and
      <b>C[Child]</b> are unrelated classes; neither is a subclass of the
      other.
<div class="p"><!----></div>
</li>

<li> <em>covariant</em>: Given a definition <b>class C[+T]{...}</b> (the <b>+</b> indicates
      covariance), <b>C[Person] :&#62; C[Child]</b>.  This is appropriate when
      <b>C</b> allows retrieving values but not setting them.
<div class="p"><!----></div>
</li>

<li> <em>contravariant</em>: Given a definition <b>class C[-T]{...}</b> (the <b>-</b> indicates
      contravariance), <b>C[Person] &lt;: C[Child]</b>.  This is appropriate when
      <b>C</b> allows storing values but not retrieving them.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The <b>T</b> parameter of <b>Cell</b> above is
invariant.  

<div class="p"><!----></div>
A typical example of covariance is <b>Get</b>.  As the <b>example()</b> method
shows, a <b>Get[T]</b> must be constructed with its value, and will return that
value whenever desired.
<pre>
class Get[+T] {
  val x: T;
  def this(x: T) { this.x = x; }
  def get(): T = x;
  static def example() {
     val g : Get[Int] = new Get[Int](31);
     val n : Int = g.get();
     x10.io.Console.OUT.print(&#207;t's " + n);
     x10.io.Console.OUT.print(&#207;t's still " + g.get());
  }
}
</pre>

<div class="p"><!----></div>
A typical example of contravariance is <b>Set</b>.  As the <b>example()</b>
method shows,  a variety of objects<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>  can be put into a
<b>Set[Object]</b>.  While the object itself cannot be retrieved, some summary
information about it - in this case, its <b>typeName</b> - can be.  
<pre>
class Set[-T] {
  var x: T;
  def this(x: T) { this.x = x; }
  def set(x: T) = { this.x = x; } 
  def summary(): String = this.x.typeName();
  static def example() {
    val s : Set[Object] = new Set[Object](new Throwable());
    s.summary(); // == "x10.lang.Throwable"
    s.set(&#196; String");
    s.summary(); // == "x10.lang.String";
  }    
}
</pre>

<div class="p"><!----></div>
Given types <b>S</b> and <b>T</b>: 

<ul>
<li>If the parameter of <b>Get</b> is covariant, then
<b>Get[S]</b> is a subtype of <b>Get[T]</b> if
<b>S</b> is a <em>subtype</em> of <b>T</b>.
<div class="p"><!----></div>
</li>

<li>
If the parameter of <b>Set</b> is contravariant, then
<b>Set[S]</b> is a subtype of <b>Set[T]</b> if
<b>S</b> is a <em>supertype</em> of <b>T</b>.
<div class="p"><!----></div>
</li>

<li>
If the parameter of <b>Cell</b> is invariant, then
<b>Cell[S]</b> is a subtype of <b>Cell[T]</b> if
<b>S</b> is a <em>equal</em> to <b>T</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
In order to make types marked as covariant and contravariant semantically
sound, X10 performs extra checks.  
A covariant type parameter is permitted to appear only in covariant type positions,
and a contravariant type parameter in contravariant positions. 

<ul>
<li> The return type of a method is a covariant position.
<div class="p"><!----></div>
</li>

<li> The argument types of a method are contravariant positions.
<div class="p"><!----></div>
</li>

<li> Whether a type argument position of a generic class, interface or struct type <b>C</b>
is covariant or contravariant is determined by the <b>+</b> or <b>-</b> annotation
at that position in the declaration of <b>C</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
There are similar restrictions on use of covariant and contravariant values. 


<div class="p"><!----></div>
 <h2><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Function Types</h2>

<div class="p"><!----></div>
For every sequence of types <b>T1,..., Tn,T</b>, and <b>n</b> distinct variables
<b>x1,...,xn</b> and constraint <b>c</b>, the expression
<b>(x1:T1,...,xn:Tn){c}=&#62;T</b> is a <em>function type</em>. It stands for
 the set of all functions <b>f</b> which can be applied to a
 list of values <b>(v1,...,vn)</b> provided that the constraint
 <b>c[v1,...,vn,p/x1,...,xn]</b> is true, and which returns a value of
 type <b>T[v1,...vn/x1,...,xn]</b>. When <b>c</b> is true, the clause <b>{c}</b> can be
 omitted. When <b>x1,...,xn</b> do not occur in <b>c</b> or <b>T</b>, they can be
 omitted. Thus the type <b>(T1,...,Tn)=&#62;T</b> is actually shorthand for
 <b>(x1:T1,...,xn:Tn){true}=&#62;T</b>, for some variables <b>x1,...,xn</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Type definitions</h2>
<a name="TypeDefs">
</a>

<div class="p"><!----></div>
<a name="types+type definitions44">
</a><a name="declarations+type definitions44">
</a>With value arguments, type arguments, and constraints, the syntax for X10
types can often be verbose. 
For example, a non-null list of non-null strings is <br />
<b>List[String{self!=null}]{self!=null}</b>.
X10 provides <em>type definitions</em>
to allow users to give short names to long types, and to commonly-used
combinations of types. 
We could name that type: 
<pre>
type LnSn = List[String{self!=null}]{self!=null};
</pre>
Or, we could abstract it somewhat, defining a type constructor
<b>Nonnull[T]</b> for the type of <b>T</b>'s which are not null:
<pre>
type Nonnull[T] = T{self!=null};
type LnSn = Nonnull[List[Nonnull[String]]];
var example : LnSn;
</pre>

<div class="p"><!----></div>
Type definitions can also refer to values, in particular, inside of
constraints.  The type of <b>n</b>-element <b>Array[Int](1)</b>s  is 
<b>Array[Int]self.rank==1 &amp;&amp; self.size == n</b>
but it is often convenient to give a shorter name: 
<pre>
type Vec(n:Int) = Array[Int]{self.rank==1 &amp;&amp; self.size == n}; 
var example : Vec(78); 
</pre>

<div class="p"><!----></div>
Type definitions, like many other X10 abstractions, can have constraints on
their use. 

<pre>

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Type definitions have the following syntax:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">TypeDefinition ::= 
                <b>type</b>&#126;Identifier
                           ( <b>[</b> TypeParameters <b>]</b> )<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&amp;&amp; ( <b>(</b> Formals <b>)</b> )<sup>?</sup>&nbsp;
Constraint<sup>?</sup>&nbsp;<b>=</b> Type </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A type definition can be thought of as a type-valued function,
mapping type parameters and value parameters to a concrete type.
The following examples are legal type definitions, given <b>import x10.util.*</b>:
<pre>
type StringSet = Set[String];
type MapToList[K,V] = Map[K,List[V]];
type Int(x: Int) = Int{self==x};
type Dist(r: Int) = Dist{self.rank==r};
type Dist(r: Region) = Dist{self.region==r};
type Redund(n:Int, r:Region){r.rank==n} = Dist{rank==n &amp;&amp; region==r};
</pre>
<a name="TypeDefGuard">
</a>
As the two definitions of <b>Dist</b> demonstrate, type definitions may 
be overloaded: two type definitions with different numbers of type
parameters or with different types of value
parameters, according to the method overloading rules
(&#167;), define distinct type constructors.

<div class="p"><!----></div>
Type definitions may appear as (static) class or interface member or
in a block statement.

<div class="p"><!----></div>
Type definitions are applicative, not generative; that is, they
define aliases for types but do not introduce new types.
Thus, the following code is legal:
<pre>
type A = Int;
type B = String;
type C = String;
a: A = 3;
b: B = new C("Hi");
c: C = b + ", Mom!";
</pre>
If a type definition has no type parameters and no value
parameters and is an alias for a class type, a <b>new</b>
expression may be used to create an instance of the class using
the type definition's name.
Given the following type definition:
<pre>
type A = C[T<sub>1</sub>, ..., T<sub>k</sub>]{c};
</pre>
where 
"C[T<sub>1</sub>, ..., T<sub>k</sub>]" is a
class type, a constructor of "C" may be invoked with
"new A(e<sub>1</sub>, ..., e<sub>n</sub>)", if the
invocation
"new C[T<sub>1</sub>, ..., T<sub>k</sub>](e<sub>1</sub>, ..., e<sub>n</sub>)" is
legal and if the constructor return type is a subtype of
<b>A</b>.

<div class="p"><!----></div>
The collection of type definitions in
"x10.lang._" is automatically imported in every compilation unit.
<a name="import,type definitions44">
</a><a name="X10LangUnderscore">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
<em><em>Limitation</em>  Unbounded recursive type definitions can cause compiler and
  programming environment problems. The compiler therefore only expands type
  definitions a predetermined number of times, 15 by default.  This limit is
  adjustable by compiler flags if necessary.
</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Constrained types</h2>
<a name="ConstrainedTypes">
</a>
<a name="DepType:DepType">
</a>
<a name="DepTypes">
</a>

<div class="p"><!----></div>
<a name="dependent types45">
</a><a name="constrained types45">
</a><a name="generic types45">
</a><a name="types+constrained types45">
</a><a name="types+dependent types45">
</a><a name="types+generic types45">
</a>Basic types, like <b>Int</b> and <b>List[String]</b>, provide useful
descriptions of data.  Indeed, most typed programming languages get by with no
more specific descriptions.

<div class="p"><!----></div>
However, there are a lot of things that one frequently wants to say about
data.  One might want to know that a <b>String</b> variable is not <b>null</b>,
or that a matrix is square, or that one matrix has the same number of columns
that another has rows (so they can be multiplied).  In the multicore setting,
one might wish to know that two values are located at the same processor, or
that one is located at the same place as the current computation.

<div class="p"><!----></div>
In most languages, there is simply no way to say these things statically.
Programmers must made do with comments, <b>assert</b> statements, and dynamic
tests.  X10 can do better, with <em>constraints</em> on types (and methods and
other things).

<div class="p"><!----></div>
A constraint is a boolean expression <b>e</b> attached to a basic type <b>T</b>,
written <b>T{e}</b>.  (Only a limited selection of boolean expressions is
available.)  The values of type <b>T{e}</b> are the values of <b>T</b> for which
<b>e</b> is true.  For example: 

<div class="p"><!----></div>

<ul>
<li> <b>String{self != null}</b> is the type of non-null strings.  <b>self</b>
      is a special variable available only in constraints; it refers to the
      datum being constrained.
<div class="p"><!----></div>
</li>

<li> If <b>Matrix</b> has properties <b>rows</b> and <b>cols</b>, 
      <b>Matrixrows == cols</b> is the type of square matrices.
<div class="p"><!----></div>
</li>

<li> One way to say that <b>a</b> has the same number of columns that <b>b</b>
      has rows (so that <b>a*b</b> is a valid matrix product), one could say: 
<pre>
  val a : Matrix = someMatrix() ;
  var b : Matrix{b.rows == a.cols} ;
</pre>

<div class="p"><!----></div>
<a name="self45">
</a>When constraining a value of type <b>T</b>, <b>self</b> refers to the object of
type <b>T</b> which is being constrained.  For example, <b>Int{self == 4}</b> is
the type of <b>Int</b>s which are equal to 4 - the best possible description
of <b>4</b>, and a very difficult type to express without using <b>self</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<b>T{e}</b> is a <em>dependent type</em>, that is, a type dependent on values. The
type <b>T</b> is called the <em>base type</em> and <b>e</b> is called the <em>
  constraint</em>. If the constraint is omitted, it is <b>true</b>-that is, the
  base type is unconstrained.

<div class="p"><!----></div>
Constraints may refer to values in the local environment: 
<pre>
     val n = 1;
     var p : Point{rank == n};
</pre>
Indeed, there is technically no need for a constraint to refer to the
properties of its type; it can refer entirely to the environment, thus: 
<pre>
     val m = 1;
     val n = 2;
     var p : Point{m != n};
</pre>

<div class="p"><!----></div>
Constraints on properties induce a natural subtyping relationship:
<b>C{c}</b> is a subtype of
<b>D{d}</b> if <b>C</b> is a subclass of <b>D</b> and
<b>c</b> entails <b>d</b>.
For example: 

<ul>
<li> <b>Int{self == 3} &lt;: Int{self != 14}</b>.  The only value of
      <b>Int{self ==3}</b> is 3.  All integers but 14 are members of
      <b>Int{self != 14}</b>, and in particular 3 is.
<div class="p"><!----></div>
</li>

<li> Suppose we have classes <b>Child &lt;: Person</b>, and <b>Person</b> has a
      long <b>ssn</b> property.  If <b>rhys : Child{ssn == 123456789}</b>, then
      <b>rhys</b> is also a <b>Person</b> and still has <b>ssn==123456789</b>, so 
      <b>rhys : Person{ssn==123456789}</b> as well.  
      So, <b>Child{ssn == 123456789} &lt;: Person{ssn == 123456789}</b>.
<div class="p"><!----></div>
</li>

<li> Furthermore, since <b>123456789 != 555555555</b>, 
      <b>rhys : Person{ssn != 555555555}</b>.  
      So, <b>Child{ssn == 123456789} &lt;: Person{ssn != 555555555}</b>.
<div class="p"><!----></div>
</li>

<li> <b>T{e} &lt;: T</b> for any type <b>T</b>.  That is, if you have a value
      <b>v</b> of some base type <b>T</b> which satisfied <b>e</b>, then <b>v</b>
      is of that base type <b>T</b> (with the constraint ignored).
<div class="p"><!----></div>
</li>

<li> If <b>A &lt;: B</b>, then <b>A{c} &lt;: B{c}</b> for every constraint <b>{c}</b>
      for which <b>A{c}</b> and <b>B{c}</b> are defined.  That is, if every
      <b>A</b> is also a <b>B</b>, and <b>a : A{c}</b>, then 
      <b>a</b> is an <b>A</b> and <b>c</b> is true of it. So <b>a</b> is also a
      <b>B</b> (and <b>c</b> is still true of 
      it), so <b>a : B{c}</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.5.1">
4.5.1</a>&nbsp;&nbsp;Constraint Expressions</h3>

<div class="p"><!----></div>
Only a few kinds of expressions can appear in constraints.  For fundamental
reasons of mathematical logic, the more kinds of expressions that can appear
in constraints, the harder it is to compute the essential properties of
constrained type - in particular, the harder it is to compute 
<b>A{c} &lt;: B{d}</b>.  It doesn't take much to make this basic fact undecidable.
In order to
make sure that it stays decidable, X10 places quite stringent restrictions on
constraints.  

<div class="p"><!----></div>
Only the following forms of expression are allowed in constraints.  

<div class="p"><!----></div>
<b>Value expressions in constraints</b> may be: 

<ol type="1">
<li> Literal constants, like <b>3</b> and <b>true</b>;
<div class="p"><!----></div>
</li>

<li> Expressions computable at compile time, like <b>3*4+5</b>;
<div class="p"><!----></div>
</li>

<li> Accessible and immutable variables and parameters;
<div class="p"><!----></div>
</li>

<li> Accessible and immutable fields of the containing object;
<div class="p"><!----></div>
</li>

<li> Properties of the type being constrained;
<div class="p"><!----></div>
</li>

<li> Property methods;
<div class="p"><!----></div>
</li>

<li> <b>this</b>, if the constraint is in a place where <b>this</b> is defined;
<div class="p"><!----></div>
</li>

<li> <b>here</b>;
<div class="p"><!----></div>
</li>

<li> <b>self</b>;
<div class="p"><!----></div>
</li>

<li> Calls to property methods, where the receiver and arguments must be
      value expressions acceptable in constraints.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
<b>Constraints</b>, and <b>Boolean expressions in constraints</b>  may be any of
the following, where 
all value expressions are of the forms which may appear in constraints: 

<ol type="1">
<li> Equalities <b>e == f</b>;
<div class="p"><!----></div>
</li>

<li> Inequalities of the form <b>e != f</b>;<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>
<div class="p"><!----></div>
</li>

<li> Conjunctions of Boolean expressions that may appear in constraints;
<div class="p"><!----></div>
</li>

<li> Subtyping and supertyping expressions: <b>T &lt;: U</b> and <b>T :&#62; U</b>;
<div class="p"><!----></div>
</li>

<li> Type equalities and inequalities: <b>T == U</b> and <b>T != U</b>;
<div class="p"><!----></div>
</li>

<li> Testing a type for a default: <b>hasZero T</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
All variables appearing in a constraint expression must be visible wherever
that expression can used.  &lt;em&#62;E.g.&lt;/em&#62;, properties and public fields of an object are
always permitted, but private fields of an object can only constrain private
members.  (Consider a class <b>PriVio</b> with a private field <b>p</b> and a
public method <b>m(x: Int{self != p})</b>, and a call <b>ob.m(10)</b> made
outside of the class. Since <b>p</b> is only visible inside the class, there is
no way to tell if <b>10</b> is of type <b>Int{self != p}</b> at the call site.)

<div class="p"><!----></div>
<em><em>Limitation</em> 
Currently <b>hasZero T</b> is not supported.  
Certain spurious syntactic forms are accepted by the compiler but treated
incorrectly. 
</em>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
The static constraint checker approximates computational reality in some
cases.  For example, it assumes that built-in types are infinite. This is a
good approximation for <b>Int</b>.  It is a poor approximation for <b>Boolean</b>,
as the checker believes that <b>a != b &amp;&amp; a != c &amp;&amp; b != c</b> is satisfiable
over <b>Boolean</b>, which it is not.  However, the checker is always correct
when computing the truth or falsehood of a constraint.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<h4>Acyclicity restriction</h4>

<div class="p"><!----></div>
To ensure that type-checking is decidable, we require that property graphs be
acyclic.  The property graph, at an instant in an X10 execution, is the graph
whose nodes are all objects in existence at that instance, with an edge from
x to y if x is an object with a property whose value is y. 

<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.5.2">
4.5.2</a>&nbsp;&nbsp;Variables in Constraints</h3>

<div class="p"><!----></div>
X10 permits a <b>val</b> variable to appear in constraints on its own type as
it is being declared.  For example, <b>val nz: Int{nz != 0} = 1;</b> declares a
non-zero variable <b>nz</b>.


<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.5.3">
4.5.3</a>&nbsp;&nbsp;Membership in Constrained Types</h3>

<div class="p"><!----></div>
An instance <b>o</b> of <b>C</b> is said to be of type <b>C{c}</b> (or: <em>
belong to</em> <b>C{c}</b>) if the constraint <b>c</b> evaluates to <b>true</b> in
the current lexical environment, augmented with the binding <b>self</b>
&#8594; <b>o</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.5.4">
4.5.4</a>&nbsp;&nbsp;Example of Constraints</h3>

<div class="p"><!----></div>
Constraints can be used to express simple relationships between objects,
enforcing some class invariants statically.  For example, in geometry, a line
is determined by two <em>distinct</em> points; a <b>Line</b> class can specify the
distinctness in a type constraint:<a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>

<div class="p"><!----></div>
<pre>
class Position(x: Int, y: Int) {
   def this(x:Int,y:Int){property(x,y);}
   }
class Line(start: Position, 
           end: Position{self != start}) {}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Extending this concept, a <b>Triangle</b> can be defined as a figure with three
line segments which match up end-to-end.  Note that the degenerate case in
which two or three of the triangle's vertices coincide is excluded by the
constraint on <b>Line</b>.  However, not all degenerate cases can be excluded
by the type system; in particular, it is impossible to check that the three
vertices are not collinear. 

<div class="p"><!----></div>
<pre>
class Triangle 
 (a: Line, 
  b: Line{a.end == b.start}, 
  c: Line{b.end == c.start &amp;&amp; c.end == a.start})  {
   def this(a:Line,
            b: Line{a.end == b.start}, 
            c: Line{b.end == c.start &amp;&amp; c.end == a.start}) 
   {property(a,b,c);}
 }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.5.5">
4.5.5</a>&nbsp;&nbsp;Entailment of Constraints</h3>
<a name="constraints+entailment45">
</a>
<a name="constraints+subtyping45">
</a>

<div class="p"><!----></div>
Recall that <b>T{c}</b> is a subtype of <b>T{d}</b> if every value of type
<b>T{c}</b> is also a value of type <b>T{d}</b>.  This is true if, whenever
<b>c</b> is true, <b>d</b> is also true.  Logicians call this concept <em>
entailment</em>: in this case, <b>c</b> entails <b>d</b>.  

<div class="p"><!----></div>
So, computing subtyping in X10 requires computing entailment of constraints.
One crucial reason why the constraint language is so limited is that computing
entailment in richer sets of expressions quickly becomes computationally
prohibitive, and, with a small number of innocuous-looking operations, becomes
actually undecidable.  

<div class="p"><!----></div>
<em><em>Limitation</em> X10's Entailment Algorithm is Incomplete</em>

<div class="p"><!----></div>
Even with the restricted constraints available in X10, certain
constraint entailments are prohibitively expensive to calculate.  The issues
concern constraints that connect different levels of recursively-defined
types.  
<pre>
class Listlike(x:Int) {
  val kid : Listlike{self.x == this.x};
  def this(x:Int, kid:Listlike) { 
     property(x); 
     this.kid = kid as Listlike{self.x == this.x};}
}
</pre>

<div class="p"><!----></div>
The entailment algorithm of X10 2.0 imposes a certain limit on the number of
times such types will be unwound.   If this limit is exceeded, the compiler
will print a warning, and type-checking will fail in a situation where it is
semantically allowed.  In this case, insert a dynamic cast at the point where
type-checking failed.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;Function types</h2>
<a name="FunctionTypes">
</a>
<a name="FunctionType">
</a>
<a name="function+types46">
</a>
<a name="types+function types46">
</a>

<div class="p"><!----></div>
X10 functions, like mathematical functions, take some arguments and produce a
result.  X10 functions, like other X10 code, can change mutable state and
throw exceptions.  Closures (&#167;) and method
selectors (&#167;) are of function type.
Typical functions are the reciprocal function: 
<pre>
val recip = (x : Double) =&#62; 1/x;
</pre>
and a function which increments  element <b>i</b> of a rail <b>r</b>, or throws an exception
if there is no such element, where, for the sake of example, we constrain the
type of <b>i</b>:  
<pre>
val inc = (r:Rail[Int], i: Int{i != r.length}) =&#62; {
  if (i &lt; 0 </td><td width="150">
&#124;</td><td width="150">
&#124; i &#62;= r.length) throw new DoomExn();
  r(i)++;
};
</pre>

<div class="p"><!----></div>
So, in general, a function type needs to list the types 
"T<sub>i</sub>"
of all the formal parameters,
and their distinct names "x<sub>i</sub>" in case other types refer to them; a
constraint 
<b>c</b> on the
function as a whole; a return type <b>T</b>.

<div class="p"><!----></div>
<pre>
(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} =&#62; T
</pre>

<div class="p"><!----></div>
The names "x<sub>i</sub>" of the formal parameters are not relevant.  Types
which differ only in the names of formals (following the usual rules for
renaming of variables, as in &#945;-renaming in the &#955; calculus
) are considered equal.  &lt;em&#62;E.g.&lt;/em&#62;, 
<b>(a:Int, b:Rail[String]{b.length==a}) =&#62; Boolean</b>
and 
<b>(b:Int, a:Rail[String]{a.length==b}) =&#62; Boolean</b>
are equivalent types.

<div class="p"><!----></div>
The formal parameter names are in scope from the point of definition to the
end of the function type-they may be used in the types of other formal parameters
and in the return type. 
Value parameters names may be
omitted if they are not used; the type of the reciprocal function can be
written as
<b>(Double)=&#62;Double</b>. 

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">FunctionType ::= TypeParameters<sup>?</sup>&nbsp;<b>(</b> Formals<sup>?</sup>&nbsp;<b>)</b> Constraint<sup>?</sup>&nbsp;
<b>=&#62;</b> Type Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">TypeParameters ::= <b>[</b> TypeParameter ( <b>,</b> TypeParameter
)<sup>*</sup>&nbsp;<b>]</b> </td></tr>
<tr><td align="right">TypeParameter ::= Identifier </td></tr>
<tr><td align="right">Formals ::= Formal ( <b>,</b> Formal )<sup>*</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A function type is covariant in its result type and contravariant in
each of its argument types. That is, let 
<b>S1,...,Sn,S,T1,...Tn,T</b> be any
types satisfying <b>Si &lt;: Ti</b> and <b>S &lt;: T</b>. Then
<b>(x1:T1,...,xn:Tn){c}=&#62;S</b> is a subtype of
<b>(x1:S1,...,xn:Sn){c}=&#62;T</b>.

<div class="p"><!----></div>
A class or struct definition may use a function type 
<b>F = (x1:T1,...,xn:Tn){c}=&#62;T</b> in its 
implements clause; 
this is equivalent to implementing an interface requiring the single method
<b>def apply(x1:T1,...,xn:Tn){c}:T</b>. 
Similarly, an interface
definition may specify a function type <b>F</b> in its <b>extends</b> clause.
Values of a class or struct implementing <b>F</b> 
can be used as functions of type <b>F</b> in all ways.  
In particular, applying one to suitable arguments calls the <b>apply</b>
method. 

<div class="p"><!----></div>
A function type <b>F</b> is not a class type in that it does not extend any
type or implement any interfaces, or support equality tests. 
<b>F</b> may be implemented, but not extended, by a class or function type. 
Nor is it a struct type, for it has no predefined notion of equality.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;Annotated types</h2>
<a name="AnnotatedTypes">
</a>

<div class="p"><!----></div>
<a name="types+annotated types47">
</a><a name="annotations+type annotations47">
</a>        Any X10 type may be annotated with zero or more
        user-defined <em>type annotations</em>
        (&#167;).  

<div class="p"><!----></div>
        Annotations are defined as (constrained) interface types and are
        processed by compiler plugins, which may interpret the
        annotation symbolically.

<div class="p"><!----></div>
        A type <b>T</b> is annotated by interface types
        &#196;<sub>1</sub>", ...,
        &#196;<sub>n</sub>"
        using the syntax
        "@A<sub>1</sub> ... @A<sub>n</sub> T".

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.8">
4.8</a>&nbsp;&nbsp;Subtyping and type equivalence</h2><a name="DepType:Equivalence">
</a>
<a name="type equivalence48">
</a>
<a name="subtyping48">
</a>

<div class="p"><!----></div>
Intuitively, type "T<sub>1</sub>" is a subtype of type "T<sub>2</sub>", 
written "T<sub>1</sub> &lt;: T<sub>2</sub>", 
if
every instance of "T<sub>1</sub>" is also an instance of "T<sub>2</sub>".  For
example, <b>Child</b> is a subtype of <b>Person</b> (assuming a suitably defined
class hierarchy): every child is a person.  Similarly, <b>Int{self != 0}</b>
is a subtype of <b>Int</b> - every non-zero integer is an integer.  

<div class="p"><!----></div>
This section formalizes the concept of subtyping. Subtyping of types depends
on a <em>type context</em>, &lt;em&#62;viz&lt;/em&#62;. a set of constraints which may say something
about types.   For example: 

<div class="p"><!----></div>
<pre>
class ConsTy[T,U] {
   def upcast(t:T){T &lt;: U} :U = t;
}
</pre>

Inside <b>upcast</b>, <b>T</b> is constrained to be a subtype of <b>U</b>, and so
<b>T &lt;: U</b> is true, and <b>t</b> can be treated as a value of type <b>U</b>.  
Outside of <b>upcast</b>, there is no reason to expect any relationship between
them, and <b>T &lt;: U</b> may be false.
However, subtyping of types that have no free variables does not depend
on the context.    <b>Int{self != 0} &lt;: Int</b> is always
true, regardless of what else is going on.

<div class="p"><!----></div>
<em><em>Limitation</em> Subtyping of type variables does not currently work.</em>

<div class="p"><!----></div>

<ul>
<li> <b>Reflexivity:</b> Every type <b>T</b> is a subtype of itself: <b>T &lt;: T</b>.
<div class="p"><!----></div>
</li>

<li> <b>Transitivity:</b> If <b>T &lt;: U</b> and <b>U &lt;: V</b>, then <b>T &lt;: V</b>. 

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>

<li> <b>Direct Subclassing:</b> 
Let <span class="overacc2">&#8594;</span>X be a (possibly empty) vector of type variables, and
<span class="overacc2">&#8594;</span>Y, <span class="overacc2">&#8594;</span>Y<sub>i</sub> be vectors of type terms over <span class="overacc2">&#8594;</span>X.
Let <span class="overacc2">&#8594;</span>T be an instantiation of <span class="overacc2">&#8594;</span>X, 
and <span class="overacc2">&#8594;</span>U, <span class="overacc2">&#8594;</span>U<sub>i</sub> the corresponding instantiation of 
<span class="overacc2">&#8594;</span>Y, <span class="overacc2">&#8594;</span>Y<sub>i</sub>.  Let <b>c</b> be a constraint, and "c&#8242;"
be the corresponding instantiation.
We elide properties, and interpret empty vectors as absence of the relevant
clauses. 
Suppose that <b>C</b> is declared by one of the
forms: 

<ol type="1">
<li> "class C[<span class="overacc2">&#8594;</span>X]{c} extends D[<span class="overacc2">&#8594;</span>Y]{d} implements I<sub>1</sub>[<span class="overacc2">&#8594;</span>Y<sub>1</sub>]{i<sub>1</sub>},...,I<sub>n</sub>[<span class="overacc2">&#8594;</span>Y<sub>n</sub>]{i<sub>n</sub>}"
<li> &#239;nterface C[<span class="overacc2">&#8594;</span>X]{c} extends I<sub>1</sub>[<span class="overacc2">&#8594;</span>Y<sub>1</sub>]{i<sub>1</sub>},...,I<sub>n</sub>[<span class="overacc2">&#8594;</span>Y<sub>n</sub>]{i<sub>n</sub>}"
<li> &#223;truct C[<span class="overacc2">&#8594;</span>X]{c} implements I<sub>1</sub>[<span class="overacc2">&#8594;</span>Y<sub>1</sub>]{i<sub>1</sub>},...,I<sub>n</sub>[<span class="overacc2">&#8594;</span>Y<sub>n</sub>]{i<sub>n</sub>}"</ol>
Then: 

<ol type="1">
<li> "C[<span class="overacc2">&#8594;</span>T] &lt;: D[<span class="overacc2">&#8594;</span>U]{d}" for a class
<div class="p"><!----></div>
</li>

<li> "C[<span class="overacc2">&#8594;</span>T] &lt;: I<sub>i</sub>[<span class="overacc2">&#8594;</span>U<sub>i</sub>]{i<sub>i</sub>}" for all cases.
<div class="p"><!----></div>
</li>

<li> "C[<span class="overacc2">&#8594;</span>T] &lt;: C[<span class="overacc2">&#8594;</span>T]{c&#8242;}" for all cases.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li>
<b>Function types:</b>
"(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} =&#62; T"
is a  subtype of 
"(x&#8242;<sub>1</sub>: T&#8242;<sub>1</sub>, ..., x&#8242;<sub>n</sub>: T&#8242;<sub>n</sub>){c&#8242;} =&#62; T&#8242; "
if: 

<ol type="1">
<li> Each "T<sub>i</sub> &lt;: T&#8242;<sub>i</sub>";
<div class="p"><!----></div>
</li>

<li> <b>c</b> entails "c&#8242;";
<div class="p"><!----></div>
</li>

<li> "T&#8242; &lt;: T";
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li>
<b>Constrained types:</b>
<b>T{c}</b> is a subtype of <b>T{d}</b> if <b>c</b> entails <b>d</b>.
<div class="p"><!----></div>
</li>

<li> <b>Any:</b> 
Every type <b>T</b> is a subtype of <b>x10.lang.Any</b>.
<div class="p"><!----></div>
</li>

<li> 
<b>Type Variables:</b>
Inside the scope of a constraint <b>c</b> which entails <b>A &lt;: B</b>, we have
<b>A &lt;: B</b>.  &lt;em&#62;e.g.&lt;/em&#62;, <b>upcast</b> above.
<div class="p"><!----></div>
</li>

<li> 
<b>Covariant Generic Types:</b> 
If <b>C</b> is a generic type whose ith type parameter is covariant, 
and "T&#8242;<sub>i</sub> &lt;: T<sub>i</sub>"
and  "T&#8242;<sub>j</sub> == T<sub>j</sub>" for all j  &#8800; i, 
then "C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>] &lt;: C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>]".
&lt;em&#62;E.g.&lt;/em&#62;, <b>class C[T1, +T2, T3]</b> with i=2, and <b>U2 &lt;: T2</b>, then
<b>C[T1,U2,T3] &lt;: C[T1,T2,T3]</b>.
<div class="p"><!----></div>
</li>

<li> 
<b>Contravariant Generic Types:</b> 
If <b>C</b> is a generic type whose ith type parameter is contravariant, 
and "T&#8242;<sub>i</sub> &lt;: T<sub>i</sub>"
and  "T&#8242;<sub>j</sub> == T<sub>j</sub>" for all j  &#8800; i, 
then "C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>] :&#62; C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>]".
&lt;em&#62;E.g.&lt;/em&#62;, <b>class C[T1, -T2, T3]</b> with i=2, and &#220;2 &lt;: T2", then
<b>C[T1,U2,T3] :&#62; C[T1,T2,T3]</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Two types are <em>equivalent</em>, <b>T == U</b>, if <b>T &lt;: U</b> and <b>U &lt;: T</b>. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.9">
4.9</a>&nbsp;&nbsp;Common ancestors of types</h2>
<a name="LCA">
</a>

<div class="p"><!----></div>
There are several situations where X10 must find a type <b>T</b> that describes
values of two or more different types.  This arises when X10 is trying to find
a good type to describe: 

<ul>
<li> Conditional expressions, like <b>test ? 0 : "non-zero"</b> or even 
      <b>test ? 0 : 1</b>;
<div class="p"><!----></div>
</li>

<li> Array construction, like <b>[0, "non-zero"]</b> and 
      <b>[0,1]</b>;
<div class="p"><!----></div>
</li>

<li> Functions with multiple returns, like
<pre>
def f(a:Int) {
  if (a == 0) return 0;
  else return "non-zero";
}
</pre>

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
In some cases, there is a unique best type describing the expression.  For
example, if <b>B</b> and <b>C</b> are direct subclasses of <b>A</b>, <b>pick</b>
will have return type <b>A</b>: 
<pre>
static def pick(t:Boolean, b:B, c:C) = t ? b : c;  
</pre>

<div class="p"><!----></div>
However, in many common cases, there is no unique best type describing the
expression.  For example, consider the expression E= <b>b ? 0 : 1</b>.  The
best type of <b>0</b> 
is <b>Int{self==0}</b>, and the best type of 1 is <b>Int{self==1}</b>.
Certainly E could be given the type <b>Int</b>, or even <b>Any</b>, and that
would describe all possible results.  However, we actually know more.
<b>Int{self != 2}</b> is a better description of the type of E-certainly
the result of E can never be <b>2</b>.   <b>Int{self != 2, self != 3}</b> is
an even better description; E can't be <b>3</b> either.  We can continue
this process forever, adding integers which E will definitely not return
and getting better and better approximations. (If the constraint
sublanguage had <b></td><td width="150">
&#124;</td><td width="150">
&#124;</b>, we could give it the type 
<b>Int{self == 0 </td><td width="150">
&#124;</td><td width="150">
&#124; self == 1}</b>, which would be nearly perfect.  But 
<b></td><td width="150">
&#124;</td><td width="150">
&#124;</b> makes typechecking far more expensive, so it is excluded.)
No X10 type is the best description of E; there is always a better one.

<div class="p"><!----></div>
Similarly, consider two unrelated interfaces: 
<pre>
interface I1 {}
interface I2 {}
class A implements I1, I2 {}
class B implements I1, I2 {}
class C {
  static def example(t:Boolean, a:A, b:B) = t ? a : b;
}
</pre>
<b>I1</b> and <b>I2</b> are both perfectly good descriptions of <b>t ? a : b</b>, 
but neither one is better than the other, and there is no single X10 type
which is better than both. (Some languages have <em>conjunctive
    types</em>, and could say that the return type of <b>example</b> was 
<b>I1 &amp;&amp; I2</b>.  This, too, complicates typechecking.)

<div class="p"><!----></div>
So, when confronted with expressions like this, X10 computes <em>some</em>
satisfactory type for the expression, but not necessarily the <em>best</em> type.  
X10 provides certain guarantees about the common type <b>V{v}</b> computed for 
<b>T{t}</b> and <b>U{u}</b>: 

<ul>
<li> If <b>T{t} == U{u}</b>, then <b>V{v} == T{t} == U{u}</b>.  So, if X10's
      algorithm produces an utterly untenable type for <b>a ? b : c</b>, and
      you want the result to have type <b>T{t}</b>, you can 
      (in the worst case) rewrite it to 
      <b>a ? b as T{t} : c as T{t}</b>.
<div class="p"><!----></div>
</li>

<li> If <b>T == U</b>, then <b>V == T == U</b>.  For example, 
      X10 will compute the type of <b>b ? 0 : 1</b> as 
      <b>Int{c}</b> for some constraint <b>c</b>-perhaps simply 
      picking <b>Int{true}</b>, &lt;em&#62;viz&lt;/em&#62;, <b>Int</b>.
<div class="p"><!----></div>
</li>

<li> X10 preserves place information, because it is so important. If both
      <b>t</b> and <b>u</b> entail <b>self.home==p</b>, then  
      <b>v</b> will also entail <b>self.home==p</b>.
<div class="p"><!----></div>
</li>

<li> X10 similarly preserves nullity information.  If <b>t</b> and <b>u</b>
      both entail <b>x == null</b> or <b>x != null</b> for some variable
      <b>x</b>, then <b>v</b> will also entail it as well.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.10">
4.10</a>&nbsp;&nbsp;Fundamental types</h2>

<div class="p"><!----></div>
Certain types are used in fundamental ways by X10.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.10.1">
4.10.1</a>&nbsp;&nbsp;The interface <b>Any</b></h3>

<div class="p"><!----></div>
It is quite convenient to have a type which all values are instances of; that
is, a supertype of all types.<a href="#tthFtNtAAH" name="tthFrefAAH"><sup>7</sup></a>  X10's universal supertype is the
  interface <b>Any</b>. 

<div class="p"><!----></div>
<pre>
package x10.lang;
public interface Any {
  def toString():String;
  def typeName():String;
  def equals(Any):Boolean;
  def hashCode():Int;
}
</pre>

<div class="p"><!----></div>
<b>Any</b> provides a handful of essential methods that make sense and are
useful for everything.<a href="#tthFtNtAAI" name="tthFrefAAI"><sup>8</sup></a> <b>a.toString()</b> produces a
string representation of <b>a</b>, and <b>a.typeName()</b> the string
representation of its type; both are useful for debugging.  <b>aequals(b)</b>
is the programmer-overridable equality test, and <b>a.hashCode()</b> an integer
useful for hashing.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.10.2">
4.10.2</a>&nbsp;&nbsp;The class <b>Object</b></h3>
<a name="Object">
</a>
<a name="\textbf{Object}410">
</a>
<a name="\textbf{x10.lang.Object}410">
</a>

<div class="p"><!----></div>
The class <b>x10.lang.Object</b> is the supertype of all classes.
A variable of this type can hold a reference to any object.
<b>Object</b> implements <b>Any</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4.11">
4.11</a>&nbsp;&nbsp;Type inference</h2>
<a name="TypeInference">
</a>
<a name="types+inference411">
</a>
<a name="type inference411">
</a>

<div class="p"><!----></div>
X10 v2.1 supports limited local type inference, permitting
certain variable types and return types to be elided.
It is a static error if an omitted type cannot be inferred or
uniquely determined.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.11.1">
4.11.1</a>&nbsp;&nbsp;Variable declarations</h3>

<div class="p"><!----></div>
The type of a <b>val</b> variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.
For example, 
<b>val seven = 7;</b>
is identical to 
<b>val seven: Int{self==7} = 7;</b>
Note that type inference gives the most precise X10 type, which might be more
specific than the type that a programmer would write.

<div class="p"><!----></div>
<em><em>Limitation</em> At the moment, only <b>val</b> declarations can have their types
elided in this way.  
</em>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.11.2">
4.11.2</a>&nbsp;&nbsp;Return types</h3>

<div class="p"><!----></div>
The return type of a method can be omitted if the method has a body (, is
not <b>abstract</b> or <b>native</b>). The inferred return type is the computed
type of the body.  In the following example, the return type inferred for
<b>isTriangle</b> is 
<b>Boolean{self==false}</b>
<pre>
class Shape {
  def isTriangle() = false; 
}  
</pre>
Note that, as with other type inference, methods are given the most specific
type.  In many cases, this interferes with subtyping.  For example, if one
tried to write: 
<pre>
class Triangle extends Shape {
  def isTriangle() = true;
}
</pre>

the X10 compiler would reject this program for attempting to override
<b>isTriangle()</b> by a method with the wrong type, &lt;em&#62;viz&lt;/em&#62;,
<b>Boolean{self==true}</b>.  In this case, supply the type that is actually
intended for <b>isTriangle</b>, such as 
<b>def isTriangle() :Boolean =false;</b>. 

<div class="p"><!----></div>
The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a constructor can be omitted if the
constructor has a body.
The inferred return type is the enclosing class type with
properties bound to the arguments in the constructor's <b>property</b>
statement, if any, or to the unconstrained class type.
For example, the <b>Spot</b> class has two constructors, the first of which has
inferred return type <b>Spot{x==0}</b> and the second of which has 
inferred return type <b>Spot{x==xx}</b>. 
<pre>
class Spot(x:Int) {
  def this() {property(0);}
  def this(xx: Int) { property(xx); }
}
</pre>

<div class="p"><!----></div>
<a name="Void411">
</a>A method or closure that has expression-free <b>return</b> statements
(<b>return;</b> rather than <b>return e;</b>) is said to return <b>Void</b>.
<b>Void</b> is not a type; there are no <b>Void</b> values, nor can <b>Void</b>
be used as the argument of a generic type. However, <b>Void</b> takes the
syntactic place of a type. A method returning <b>Void</b> can be specified by
<b>def m():Void</b>: 

<div class="p"><!----></div>
<pre>
val f : () =&#62; Void = () =&#62; {return;};
</pre>

<div class="p"><!----></div>
By a convenient abuse of language, <b>Void</b> is sometimes
lumped in with types; &lt;em&#62;e.g.&lt;/em&#62;, we may say "return type of a method" rather than
the formally correct but rather more awkward "return type of a method, or
<b>Void</b>".   Despite this informal usage, <b>Void</b> is not a type.  For
example, given 
<pre>
  static def eval[T] (f:()=&#62;T):T = f();
</pre>

The call <b>eval[Void](f)</b> does <em>not</em> typecheck; <b>Void</b> is not a
type and thus cannot be used as a type argument.  There is no way in X10 to
write a generic function which works with both functions which return a value
and functions which do not.  In most cases, functions which have no sensible
return value can be provided with a dummy return value.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.11.3">
4.11.3</a>&nbsp;&nbsp;Type arguments</h3>

<div class="p"><!----></div>
<em><em>Limitation</em> This does not seem to work at all currently.</em>

<div class="p"><!----></div>
A call to a polymorphic method %, closure, or constructor 
may omit the
explicit type arguments.  If the method has a type parameter
<b>T</b>, the type argument corresponding to <b>T</b> is inferred
to be the least common ancestor of the types of any formal
parameters of type <b>T</b>.


<div class="p"><!----></div>
Consider the following method:
<pre>
def choose[T](a: T, b: T): T { ... }
</pre>
Given <b>Set[T] &lt;: Collection[T]</b>, 
<b>List[T] &lt;: Collection[T]</b>,
and <b>SubClass &lt;: SuperClass</b>,
in the following snippet, the algorithm will infer the type
<b>Collection[Any]</b> for <b>x</b>.
<pre>
def m(intSet: Set[Int], stringList: List[String]) {
  val x = choose(intSet, stringList);
...
}
</pre>
And in this snippet, the algorithm should infer the type
<b>Collection[Int]</b> for <b>y</b>.
<pre>
def m(intSet: Set[Int], intList: List[Int]) {
  val y = choose(intSet, intList);
  ...
}
</pre>
Finally, in this snippet, the algorithm should infer the type
<b>CollectionT &lt;: SuperClass</b> for <b>z</b>.
<pre>
def m(intSet: Set[SubClass], numList: List{T &lt;: SuperClass}) {
  val z = choose(intSet, numList);
  ...
}
</pre>

<div class="p"><!----></div>
	
<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp5">
Chapter 5 </a><br />Variables</h1><a name="XtenVariables">
</a><a name="variables50">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
A <em>variable</em> is an X10 identifier associated with a value within some
context. Variable bindings have these essential properties:

<ul>
<li> <b>Type:</b> What sorts of values can be bound to the identifier;
<div class="p"><!----></div>
</li>

<li> <b>Scope:</b> The region of code in which the identifier is associated
      with the entity;
<div class="p"><!----></div>
</li>

<li> <b>Lifetime:</b> The interval of time in which the identifier is
      associated with the entity.
<div class="p"><!----></div>
</li>

<li> <b>Visibility:</b> Which parts of the program can read or manipulate the
      value through the variable.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
X10 has many varieties of variables, used for a number of purposes. They will
be described in more detail in this chapter.  

<ul>
<li> Class variables, also known as the static fields of a class, which hold
      their values for the lifetime of the class.
<div class="p"><!----></div>
</li>

<li> Instance variables, which hold their values for the lifetime of an
      object;
<div class="p"><!----></div>
</li>

<li> Array elements, which are not individually named and hold their values
      for the lifetime of an array;
<div class="p"><!----></div>
</li>

<li> Formal parameters to methods, functions, and constructors, which hold
      their values for the duration of method (etc.) invocation;
<div class="p"><!----></div>
</li>

<li> Local variables, which hold their values for the duration of execution
      of a block.
<div class="p"><!----></div>
</li>

<li> Exception-handler parameters, which hold their values for the execution
      of the exception being handled.
<div class="p"><!----></div>
</li>
</ul>
A few other kinds of things are called variables for historical reasons; &lt;em&#62;e.g.&lt;/em&#62;,
type parameters are often called type variables, despite not being variables
in this sense because they do not refer to X10 values.  Other named entities,
such as classes and methods, are not called variables.  However, all
name-to-whatever bindings enjoy similar concepts of scope and visibility.  

<div class="p"><!----></div>
In the following example, <b>n</b> is an instance variable, and <b>next</b> is a
local variable defined within the method <b>bump</b>.<a href="#tthFtNtAAJ" name="tthFrefAAJ"><sup>9</sup></a>
<pre>
class Counter {
  private var n : Int = 0;
  public def bump() : Int {
    val next = n+1;
    n = next;
    return next;
    }
}
</pre>
Both variables have type <b>Int</b> (or
perhaps something more specific).    The scope of <b>n</b> is the body of
<b>Counter</b>; the scope of <b>next</b> is the body of <b>bump</b>.  The
lifetime of <b>n</b> is the lifetime of the <b>Counter</b> object holding it;
the lifetime of <b>next</b> is the duration of the call to <b>bump</b>. Neither
variable can be seen from outside of its scope.

<div class="p"><!----></div>
<a name="exploded-syntax">
</a><a name="VariableDeclarations">
</a><a name="variable declaration50">
</a>Variables whose value may not be changed after initialization are said to be
<em>immutable</em>, or <em>constants</em> (&#167;), or simply
<b>val</b> variables. Variables whose value may change are <em>mutable</em> or
simply <b>var</b> variables. <b>var</b> variables are declared by the <b>var</b>
keyword. <b>val</b> variables may be declared by the <b>val</b> keyword; when a
variable declaration does not include either <b>var</b> or <b>val</b>, it is
considered <b>val</b>. 

<div class="p"><!----></div>
<pre>
val a : Int = 0;               // Full 'val' syntax
b : Int = 0;                   // 'val' implied
val c = 0;                     // Type inferred
var d : Int = 0;               // Full 'var' syntax
var e : Int;                   // Not initialized
var f : Int{self != 100} = 0;  // Constrained type
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Immutable variables</h2>
<a name="FinalVariables">
</a>
<a name="variable+immutable51">
</a>
<a name="immutable variable51">
</a>

<div class="p"><!----></div>
Immutable variables can be given values (by initialization or assignment) at
most once, and must be given values before they are used.  Usually this is
achieved by declaring and initializing the variable in a single statement.
<pre>
val a : Int = 10;
val b = (a+1)*(a-1);
</pre>
<b>a</b> and <b>b</b> cannot be assigned to further.

<div class="p"><!----></div>
In other cases, the declaration and assignment are separate.  One such
case is how constructors give values to <b>val</b> fields of objects.  The
<b>Example</b> class has an immutable field <b>n</b>, which is given different
values depending on which constructor was called. <b>n</b> can't be given its
value by initialization when it is declared, since it is not knowable which
constructor is called at that point.  
<pre>
class Example {
  val n : Int; // not initialized here
  def this() { n = 1; }
  def this(dummy:Boolean) { n = 2;}
}
</pre>

<div class="p"><!----></div>
Another common case of separating declaration and assignment is in function
and method call.  The formal parameters are bound to the corresponding actual
parameters, but the binding does not happen until the function is called.  In
the code below, <b>x</b> is initialized to <b>3</b> in the first call and
<b>4</b> in the second.
<pre>
val sq = (x:Int) =&#62; x*x;
x10.io.Console.OUT.println("3 squared = " + sq(3));
x10.io.Console.OUT.println("4 squared = " + sq(4));
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Initial values of variables</h2>
<a name="NullaryConstructor">
</a><a name="nullary constructor52">
</a>

<div class="p"><!----></div>
Every assignment, binding, or initialization to a variable of type <b>T{c}</b>
must be an instance of type <b>T</b> satisfying the constraint <b>{c}</b>.
Variables must be given a value before they are used. This may be done by
initialization, which is the only way for immutable (<b>val</b>) variables and
one option for mutable (<b>var</b>) ones: 

<div class="p"><!----></div>
<pre>
  val immut : Int = 3;
  var mutab : Int = immut;
  val use = immut + mutab;
</pre>
Or, for mutable variables, it may be done by a later assignment.  

<div class="p"><!----></div>
<pre>
  var muta2 : Int;
  muta2 = 4;
  val use = muta2 * 10;
</pre>

<div class="p"><!----></div>
Every class variable must be initialized before it is read, through
the execution of an explicit initializer or a static block. Every
instance variable must be initialized before it is read, through the
execution of an explicit initializer or a constructor.

Mutable instance variables of class type are initialized to 
to <b>null</b>.
Mutable instance variables of struct type are 
assumed to have an initializer that sets the value to the
result of invoking the nullary constructor on the class. 
An initializer is required if the default initial value of the variable's type
is not
assignable to the variable's type, &lt;em&#62;e.g.&lt;/em&#62;, <b>Int</b> variables are initialized to
zero, but that doesn't work for <b>val x:Int{x!=0}</b>.

<div class="p"><!----></div>
Each method and constructor parameter is initialized to the
corresponding argument value provided by the invoker of the method. An
exception-handling parameter is initialized to the object thrown by
the exception. A local variable must be explicitly given a value by
initialization or assignment, in a way that the compiler can verify
using the rules for definite assignment [,&#167;&#126;16].

<div class="p"><!----></div>
 <h2><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Destructuring syntax</h2>
<a name="variable declarator+destructuring53">
</a>
<a name="destructuring53">
</a>
X10 permits a <em>destructuring</em> syntax for local variable
declarations and formal parameters of type <b>Point</b>, &#167;.
(Future versions of X10 may allow destructuring of other types as well.) 
A point is a sequence of r  &#8805; 0 <b>Int</b>-valued coordinates.  
It is often useful to get at the coordinates directly, in variables. 

<div class="p"><!----></div>
The following code makes an anonymous point with one coordinate <b>11</b>, and
binds <b>i</b> to <b>11</b>.  Then it makes a point with coordinates <b>22</b>
and <b>33</b>, binds <b>p</b> to that point, and <b>j</b> and <b>k</b> to <b>22</b>
and <b>33</b> respectively.
<pre>
val [i] : Point = Point.make(11);
val p[j,k] = Point.make(22,33);
val q[l,m] = [44,55]; // coerces an array to a point.
</pre>

<div class="p"><!----></div>
A useful idiom for iterating over a range of numbers is: 
<pre>
var sum : Int = 0;
for ([i] in 1..100) sum += i;
</pre>

The brackets in <b>[i]</b> introduce destructuring, making X10 treat <b>i</b>
as an <b>Int</b>; without them, it would be a <b>Point</b>.  

<div class="p"><!----></div>
In general, a pattern of the form "[i<sub>1</sub>,&#8230;,i<sub>n</sub>]" matches a
point with n coordinates, binding &#239;<sub>j</sub>" to coordinate j.  
A pattern of the form "p[i<sub>1</sub>,&#8230;,i<sub>n</sub>]" does the same,  but
also binds <b>p</b> to the point.

<div class="p"><!----></div>
 <h2><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;Formal parameters</h2>

<div class="p"><!----></div>
Formal parameters are the variables which hold values transmitted into a
method or function.  
They are always declared with a type.  (Type inference is not
advisable, because there is no single expression to deduce a type from.)
The variable name can be omitted if it is not to be used in the
scope of the declaration, as in the type of the method 
<b>static def main(Rail[String]):Void</b> executed at the start of a program that
does not use its command-line arguments.

<div class="p"><!----></div>

<div class="p"><!----></div>
<b>var</b> and <b>val</b> behave just as they do for local
variables, &#167;.  In particular, the following <b>inc</b>
method is allowed, but, unlike some languages, does <em>not</em> increment its
actual parameter.  <b>inc(j)</b> creates a new local 
variable <b>i</b> for the method call, initializes <b>i</b> with the value of
<b>j</b>, increments <b>i</b>, and then returns.  <b>j</b> is never changed.
<pre>
static def inc(var i:Int) { i += 1; }
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5.5">
5.5</a>&nbsp;&nbsp;Local variables</h2><a name="local-variables">
</a>
Local variables are declared in a limited scope, and, dynamically, keep their
values only for so long as the scope is being executed.  They may be <b>var</b>
or <b>val</b>.  
They may have 
initializer expressions: <b>var i:Int = 1;</b> introduces 
a variable <b>i</b> and initializes it to 1.
If the variable is immutable
(<b>val</b>)
the type may be omitted and
inferred from the initializer type (&#167;<a href="#TypeInference">4.11</a>).

<div class="p"><!----></div>
The variable declaration <b>val x:T=e;</b> confirms that <b>e</b>'s value is of
type <b>T</b>, and then introduces the variable <b>x</b> with type <b>T</b>.  For
example, consider a class Tub with a property <b>p</b>.
<pre>
class Tub(p:Int){
  def this(pp:Int):Tub{self.p==pp} {property(pp);}
  def example() {
    val t : Tub = new Tub(3);
  }
}
</pre>

produces a variable <b>t</b> of type <b>Tub</b>, even though the expression
<b>new Tub(3)</b> produces a value of type <b>Tubself.p==3</b> - that is, a
<b>Tub</b>  whose <b>p</b> field is 3.  This can be inconvenient when the
constraint information is required.

<div class="p"><!----></div>
Including type information in variable declarations is generally good
programming practice: it explains to both the compiler and human readers
something of the intent of the variable.  However, including types in 
<b>val t:T=e</b> can obliterate helpful information.  So, X10 allows a <em>
documentation type declaration</em>, written <b>val t &lt;: T = e</b>.  This 
has the same effect as <b>val t = e</b>, giving <b>t</b> the full type inferred
from <b>e</b>; but it also confirms statically that that type is at least
<b>T</b>.  For example, the following gives <b>t</b> the type <b>Tubself.p==3</b> as
desired: 
<pre>
   val t &lt;: Tub = new Tub(3);
</pre>

However, replacing <b>Tub</b> by <b>Int</b> would result in a compilation error. 

<div class="p"><!----></div>
Variables do not need to be initialized at the time of definition - not even
<b>val</b>s. They must be initialized by the time of use, and <b>val</b>s may
only be assigned to once. The X10 compiler performs static checks guaranteeing
this restriction. The following is correct, albeit obtuse: 
<pre>
static def main(r: Array[String](1)):Void {
  val a : Int;
  a = r.size;
  val b : String;
  if (a == 5) b = "five?"; else b = "" + a + " args"; 
  // ... 
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5.6">
5.6</a>&nbsp;&nbsp;Fields</h2>

<div class="p"><!----></div>
Like most other kinds of variables in X10, 
the fields of an object can be either <b>val</b> or <b>var</b>. 
Fields can be <b>static</b>,<b>global</b>, or <b>property</b>; see
&#167; and &#167;.
Field declarations may have optional
initializer expressions, as for local variables, &#167;<a href="#local-variables">5.5</a>.
<b>var</b> fields without an initializer are initialized with the default value
of their type. <b>val</b> fields without an initializer must be initialized by
each constructor.

<div class="p"><!----></div>
For <b>val</b> fields, as for <b>val</b> local variables, the type may be
omitted and inferred from the initializer type (&#167;<a href="#TypeInference">4.11</a>).
<b>var</b> files, like <b>var</b> local variables, must be declared with a type.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>




<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp6">
Chapter 6 </a><br />Names and packages</h1>
<a name="packages">
</a> <a name="names60">
</a><a name="packages60">
</a><a name="public60">
</a><a name="protected60">
</a><a name="private60">
</a>

<div class="p"><!----></div>
X10 supports mechanisms for names and packages in the style of Java
[,&#167; 6,&#167; 7], including <b>public</b>, <b>protected</b>, <b>private</b>
and package-specific access control.

<div class="p"><!----></div>
 <h2><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Packages</h2>

<div class="p"><!----></div>
A package is a named collection of top-level type declarations, , class,
interface, and struct declarations. Package names are sequences of
identifiers, like <b>x10.lang</b> and <b>com.ibm.museum</b>. The multiple names
are simply a convenience. Packages <b>a</b>, <b>a.b</b>, and <b>a.c</b> have only
a very tenuous relationship, despite the similarity of their names.

<div class="p"><!----></div>
Packages and protection modifiers determine which top-level names can be used
where. Only the <b>public</b> members of package <b>pack.age</b> can be accessed
outside of <b>pack.age</b> itself.  
<pre>
package pack.age;
class Deal {
  public def make() {}
}
public class Stimulus {
  private def taxCut() = true;
  protected def benefits() = true;
  public def jobCreation() = true;
  /*package*/ def jumpstart() = true;
}
</pre>

<div class="p"><!----></div>
The class <b>Stimulus</b> can be referred to from anywhere outside of
<b>pack.age</b> by its full name of <b>pack.age.Stimulus</b>, or can be imported
and referred to simply as <b>Stimulus</b>.  The public <b>jobCreation()</b>
method of a <b>Stimulus</b> can be referred to from anywhere as well; the other
methods have smaller visibility.  The non-<b>public</b> class <b>Deal</b> cannot
be used from outside of <b>pack.age</b>.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1.1">
6.1.1</a>&nbsp;&nbsp;Name Collisions</h3>

<div class="p"><!----></div>
It is a static error for a package to have two members, or apparent members,
with the same name.  For example, package <b>pack.age</b> cannot define two
classes both named <b>Crash</b>, nor a class and an interface with that name.

<div class="p"><!----></div>
Furthermore, <b>pack.age</b> cannot define a member <b>Crash</b> if there is
another package named <b>pack.age.Crash</b>, nor vice-versa. (This prohibition
is the only actual relationship between the two packages.)  This prevents the
ambiguity of whether <b>pack.age.Crash</b> refers to the class or the package.  
Note that the naming convention that package names are lower-case and package
members are capitalized prevents such collisions.

<div class="p"><!----></div>
 <h2><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;<b>import</b> Declarations</h2>

<div class="p"><!----></div>
Any public member of a package can be referred to from anywhere through a
fully-qualified name: <b>pack.age.Stimulus</b>.    

<div class="p"><!----></div>
Often, this is too awkward.  X10 has two ways to allow code outside of a class
to refer to the class by its short name (<b>Stimulus</b>): single-type imports
and on-demand imports.   

<div class="p"><!----></div>
Imports of either kind appear at the start of the file, immediately after the
<b>package</b> directive if there is one; their scope is the whole file.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2.1">
6.2.1</a>&nbsp;&nbsp;Single-Type Import</h3>

<div class="p"><!----></div>
The declaration <b>import </b> <em>TypeName</em> <b>;</b> imports a single type
into the current namespace.  The type it imports must be a fully-qualified
name of an extant type, and it must either be in the same package (in which
case the <b>import</b> is redundant) or be declared <b>public</b>.  

<div class="p"><!----></div>
Furthermore, when importing <b>pack.age.T</b>, there must not be another type
named <b>T</b> at that point: neither a  <b>T</b> declared in <b>pack.age</b>,
nor a <b>inst.ant.T</b> imported from some other package.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2.2">
6.2.2</a>&nbsp;&nbsp;Automatic Import</h3>

<div class="p"><!----></div>
The automatic import <b>import pack.age.*;</b>, loosely, imports all the public
members of <b>pack.age</b>.  In fact, it does so somewhat carefully, avoiding
certain errors that could occur if it were done naively.  Types defined in the
current package, and those imported by single-type imports, shadow those
imported by automatic imports.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2.3">
6.2.3</a>&nbsp;&nbsp;Implicit Imports</h3>

<div class="p"><!----></div>
The packages <b>x10.lang</b> and <b>x10.array</b> are imported in all files
without need for further specification.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Conventions on Type Names</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">TypeName   ::= Identifier </td></tr>
<tr><td align="right">&#124; TypeName <b>.</b> Identifier </td></tr>
<tr><td align="right">&#124; PackageName <b>.</b> Identifier </td></tr>
<tr><td align="right">PackageName   ::= Identifier </td></tr>
<tr><td align="right">&#124; PackageName <b>.</b> Identifier </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
While not enforced by the compiler, classes and interfaces
in the X10 library follow the following naming conventions.
Names of types-including classes,
type parameters, and types specified by type definitions-are in
CamelCase and begin with an uppercase letter.  (Type variables are often
single capital letters, such as <b>T</b>.)
For backward
compatibility with languages such as C and Java, type
definitions are provided to allow primitive types
such as <b>int</b> and <b>boolean</b> to be written in lowercase.
Names of methods, fields, value properties, and packages are in camelCase and
begin with a lowercase letter. 
Names of <b>static val</b> fields are in all uppercase with words
separated by `<b>_</b>"s.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp7">
Chapter 7 </a><br />Interfaces</h1>
<a name="XtenInterfaces">
</a><a name="interfaces70">
</a>

<div class="p"><!----></div>
X10 v2.1 interfaces are generally modelled on Java interfaces [,&#167;
  9]. An interface specifies signatures for public methods, properties,
<b>static val</b>s, and an invariant. It may extend several interfaces, giving
X10 a large fraction of the power of multiple inheritance at a tiny fraction
of the cost.

<div class="p"><!----></div>
The following puny example illustrates all these features: 
<pre>
interface Pushable(text:String, prio:Int) {
  def push(): Void;
  static val MAX_PRIO = 100;
}
class MessageButton(text:String, prio:Int) 
  implements Pushable{self.prio==Pushable.MAX_PRIO} {
  public def push() { 
    x10.io.Console.OUT.println(text + " pushed");
  }
}
</pre>

<b>Pushable</b> defines two properties, a method, and a static value.  
<b>MessageButton</b> implements a constrained version of <b>Pushable</b>,
&lt;em&#62;viz&lt;/em&#62;&nbsp;one with maximum priority.  It also has <b>Pushable</b>'s properties.  It
defines the <b>push()</b> method given in the interface, as a <b>public</b>
method-interface methods are implicitly <b>public</b>.

<div class="p"><!----></div>
A concrete type-a class or struct-can <em>implement</em> an interface,
typically by having all the methods and properties that the interface
requires.

<div class="p"><!----></div>
A variable may be declared to be of interface type.  Such a variable has all
the fields and methods declared (directly or indirectly) by the interface;
nothing else is statically available.  Values of a concrete type which
implement the interface may be stored in the variable.  

<div class="p"><!----></div>
<a name="DepType:Interface">
</a>  :  |        <em>  
<table>
<tr><td align="right">NormalInterfaceDeclaration ::=
      InterfaceModifiers<sup>?</sup>&nbsp;<b>interface</b> Identifier  </td></tr>
<tr><td align="right">&amp;&amp; TypePropertyList<sup>?</sup>&nbsp;PropertyList<sup>?</sup>&nbsp;Constraint<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">&amp;&amp; ExtendsInterfaces<sup>?</sup>&nbsp;InterfaceBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>

The invariant associated with an interface is the conjunction of the
invariants associated with its superinterfaces and the invariant
defined at the interface. 

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
The compiler declares an error if this constraint
is not consistent.  


<div class="p"><!----></div>
Each interface implicitly defines a nullary getter method
<b>def p(): T</b> for each property <b>p: T</b>. The interface may not have
another definition of a method <b>p()</b>. 

<div class="p"><!----></div>
A class <b>C</b> is said to implement an interface <b>I</b> if

<ul>
<li> <b>I</b>, or a subtype of <b>I</b>, appears in the <b>implements</b> list
      of <b>C</b>,
<div class="p"><!----></div>
</li>

<li> <b>C</b>'s properties include all the properties of <b>I</b>,
<div class="p"><!----></div>
</li>

<li> <b>C</b>'s class invariant <i>inv</i>(<b>C</b>) implies
<i>inv</i>(<b>I</b>).
<div class="p"><!----></div>
</li>

<li> Each method <b>m</b> defined by <b>I</b> is also a method of <b>C</b> -
      with the <em><b>public</b></em> modifier added.   These methods may be
      <b>abstract</b> if <b>C</b> is <b>abstract</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
 <h2><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Field Definitions</h2>

<div class="p"><!----></div>
An interface may declare a <b>val</b> field, with a value.  This field is implicitly
<b>public static val</b>: 
<pre>
interface KnowsPi {
  PI = 3.14159265358;
}
</pre>

<div class="p"><!----></div>
Classes and structs implementing such an interface get the interface's fields as
<b>public static</b> fields.  Unlike properties and methods, there is no need
for the implementing class to declare them. 
<pre>
class Circle implements KnowsPi {
  static def area(r:Double) = PI * r * r;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1.1">
7.1.1</a>&nbsp;&nbsp;Fine Points of Fields</h3>

<div class="p"><!----></div>
It can happen that two parent interfaces give fields of the same name.  In
that case, those fields must be referred to by qualified names.
<pre>
interface E1 {static val a = 1;}
interface E2 {static val a = 2;}
interface E3 extends E1, E2{}
class Example implements E3 {
  def example() = E1.a + E2.a;
}
</pre>

<div class="p"><!----></div>
If the <em>same</em> field <b>a</b> is inherited through many paths, there is no need to
disambiguate it:
<pre>
interface I1 { static val a = 1;} 
interface I2 extends I1 {}
interface I3 extends I1 {}
interface I4 extends I2,I3 {}
class Example implements I4 {
  def example() = a;
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp8">
Chapter 8 </a><br />Classes</h1>
<a name="XtenClasses">
</a><a name="class80">
</a>
<a name="ReferenceClasses">
</a>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Principles of X10 Objects</h2><a name="XtenObjects">
</a><a name="Object81">
</a>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.1.1">
8.1.1</a>&nbsp;&nbsp;Basic Design</h3>

<div class="p"><!----></div>
Objects are instances of classes: the most common and most powerful sort of
value in X10.  The other kinds of values, structs and functions, are more
specialized, better in some circumstances but not in all.
<b>x10.lang.Object</b> is the most general class; all other classes inherit
from it, directly or indirectly. 

<div class="p"><!----></div>
Classes are structured in a single-inheritance code
hierarchy, may implement multiple interfaces, may have static and
instance fields, may have static and instance methods, may have
constructors, may have static and instance initializers, may have
static and instance inner classes and interfaces. X10 does not
permit mutable static state.

<div class="p"><!----></div>
X10 objects do not have locks associated with them.
Programmers should use atomic blocks (&#167;) for mutual
exclusion and clocks (&#167;) for sequencing multiple parallel
operations.

<div class="p"><!----></div>
An object exists in a single location: the place that it was created.  One
place cannot directly refer to an object in a different place.   A
special type, <b>GlobalRef[T]</b>, allows explicit cross-place references. 

<div class="p"><!----></div>
The basic operations on objects are:

<ul>
<li> Field access (&#167;). 
The static and instance fields of an object can be retrieved; <b>var</b> fields
can be set.  Accumulator fields can be updated, but only in limited contexts. 

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>

<li> Method invocation (&#167;).  
Static and instance methods of an object can be invoked.

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>

<li> Casting (&#167;) and instance testing with <b>instanceof</b>
(&#167;) Objects can be cast or type-tested.
<div class="p"><!----></div>
</li>

<li> The equality operators <b>==</b> and <b>!=</b>
Objects can be compared for equality with the <b>==</b> operation.  This checks
object <em>identity</em>: two objects are <b>==</b> iff they are the same object.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
        <h3><a name="tth_sEc8.1.2">
8.1.2</a>&nbsp;&nbsp;Class Declaration Syntax</h3>

<div class="p"><!----></div>
The <em>class declaration</em> has a list of type parameters, properties, a
constraint (the <em>class invariant</em>), a single superclass, zero or more
interfaces, and a class body containing the the definition of fields,
properties, methods, and member types. Each such declaration introduces a
class type (&#167;<a href="#ReferenceTypes">4.1</a>).

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Fields</h2>
<a name="FieldDefinitions">
</a>

<div class="p"><!----></div>
Objects may have <em>instance fields</em>, or simply <em>fields</em>: places to
store data that is pertinent to the object. Fields, like variables, may be
mutable (<b>val</b>), immutable (<b>var</b>)
.

<div class="p"><!----></div>
Class may have <em>static fields</em>, which store data pertinent to the
entire class of objects.  
See &#167; for more information.

<div class="p"><!----></div>
No two fields of the same class may have the same name.
To avoid an ambiguity, it is a static error for a class to
declare a field with a function type (&#167;<a href="#FunctionTypes">4.6</a>) with
the same name and signature  as a method of the same class.  
(Consider the class 
<pre>
class Crash {
  val f : (Int) =&#62; Boolean = (Int)=&#62;true;
  def f(Int) = false;
}
</pre>

Then <b>crash.f(3)</b> might either mean "call the function <b>crash.f</b> on
argument <b>3</b>", or &#239;nvoke the method <b>f</b> on argument <b>3</b>".)

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2.1">
8.2.1</a>&nbsp;&nbsp;Field Initialization</h3>

<div class="p"><!----></div>
Fields may be given values via <em>field initialization expressions</em>:
<b>val f1 = E;</b> and <b>var f2 : Int = F;</b>. Other fields of <b>this</b> may
be referenced, but only those that <em>precede</em> the field being initialized.
For example, the following is correct, but would not be if the fields were
reversed:

<div class="p"><!----></div>
<pre>
class Fld{
  val a = 1;
  val b = 2+a;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2.2">
8.2.2</a>&nbsp;&nbsp;Field hiding</h3>

<div class="p"><!----></div>
A subclass that defines a field <b>f</b> hides any field <b>f</b>
declared in a superclass, regardless of their types.  The
superclass field <b>f</b> may be accessed within the body of
the subclass via the reference <b>super.f</b>.

<div class="p"><!----></div>
<pre>
class Super{ 
  val f = 1; 
}
class Sub extends Super {
  val f = true;
  def superf() : Int = super.f; // 1
}
</pre>

<div class="p"><!----></div>
With inner classes, it is occasionally necessary to 
write <b>Cls.super.f</b> to get at a hidden field <b>f</b> of an outer class
<b>Cls</b>, as in 
<pre>
class A {
   val f = 3;
}
class B extends A {
   val f = 4;
   class C extends B {
      // C is both a subclass and inner class of B
      val f = 5;
      def foo()
         = f          // 5
         + super.f    // 4
         + B.this.f   // 4 (the "f" of the outer instance)
         + B.super.f; // 3 (the &#223;uper.f" of the outer instance)
    }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2.3">
8.2.3</a>&nbsp;&nbsp;Field qualifiers</h3>
<a name="FieldQualifier">
</a>
<a name="Qualifier+field82">
</a>

<div class="p"><!----></div>
The behavior of a field may be changed by a field qualifier, such as
<b>static</b> or <b>transient</b>.  

<div class="p"><!----></div>

<h4><b>static</b> qualifier</h4>

<div class="p"><!----></div>
A <b>val</b> field may be declared to be <em>static</em>, as described in
&#167;<a href="#FieldDefinitions">8.2</a>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2.4">
8.2.4</a>&nbsp;&nbsp;<b>transient</b> Qualifier</h3>
<a name="transient82">
</a>
<a name="field+transient82">
</a>

<div class="p"><!----></div>
A field may be declared to be <em>transient</em>.  Transient fields are excluded
from the deep copying that happens when information is sent from place to
place in an <b>at</b> statement.    The value of a transient field of a copied
object is the default value of its type, regardless of the value of the field
in the original.  If the type of a field has no
default value, it cannot be marked <b>transient</b>.
<pre>
class Trans { 
   val copied = "copied";
   transient val transy : String = &#228; very long string";
   def example() {
      at (here) { // causes copying
         assert(this.copied == "copied");
         assert(this.transy == null);
      }
   }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;Properties</h2>
<a name="PropertiesInClasses">
</a>

<div class="p"><!----></div>
The properties of an object (or struct) are  public <b>val</b> fields
usable at compile time in constraints.<a href="#tthFtNtABA" name="tthFrefABA"><sup>10</sup></a> 
For example,  every array has a <b>rank</b> telling
how many subscripts it takes.  User-defined classes can have whatever
properties are desired. 

<div class="p"><!----></div>
Properties are defined in parentheses, after the name of the class.  They are
given values by the <b>property</b> command in constructors.
<pre>
class Proper(t:Int) {
  def this(t:Int) {property(t);}
}
</pre>

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
It is a compile-time error for a class
defining a property <b>x: T</b> to have an ancestor class that defines
a property with the name <b>x</b>.  


<div class="p"><!----></div>
A property <b>x:T</b> induces a field with the same name and type, 
as if defined with: 
<pre>
public val x : T;
</pre>
 It also defines a nullary getter method, 
<pre>
public final def x()=x;
</pre>

<div class="p"><!----></div>
 (As noted in &#167;<a href="#DepType:Interface">7</a>, interfaces can define
properties too. They define the same nullary getter methods, though they do
not require fields.)

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
It is a compile-time error for a class or
interface defining a property <b>x :T</b> to have an existing method with
the signature <b>x(): T</b>.


<div class="p"><!----></div>
Properties are initialized by the invocation of a special <b>property</b>
statement, which must be performed in each constructor of the class:
<pre>
property(e1,..., en);
</pre>
The number and types of arguments to the <b>property</b> statement must match
the number and types of the properties in the class declaration.  
Every constructor of a class with properties must invoke <b>property(...)</b>
precisely once; it is a static error if X10 cannot prove that this holds.

<div class="p"><!----></div>
The requirement to use the <b>property</b> statement means that all properties
must be given values at the same time.  

<div class="p"><!----></div>
By construction, the graph whose nodes are values and whose edges are
properties is acyclic.  &lt;em&#62;E.g.&lt;/em&#62;, there cannot be values <b>a</b> and <b>b</b> with
properties <b>c</b> and <b>d</b> such that <b>a.c == b</b> and <b>b.d == a</b>.
(The similar graph whose edges are <b>public val</b> fields <em>can</em> have
cycles.) 

<div class="p"><!----></div>
<a name="property+call83">
</a><a name="property+initialization83">
</a><a name="PropertyCall">
</a> <h2><a name="tth_sEc8.4">
8.4</a>&nbsp;&nbsp;Methods</h2>

<div class="p"><!----></div>
As is common in object-oriented languages, objects can have <em>methods</em>, of
two sorts.  <em>Static methods</em> are functions, conceptually associated with a
class and defined in its namespace.  <em>Instance methods</em> are parameterized
code bodies associated with an instance of the class, which execute with
priveleged access to that instance's fields. 

<div class="p"><!----></div>
Each method has a <em>signature</em>, telling what arguments it accepts, what
type it returns, what precondition it requires. Method definitions may be
overridden by subclasses; the overriding definition may have a declared return
type that is a subclass of the return type of the definition being overridden.
Multiple methods with the same name but different signatures may be provided
on a class (ad hoc polymorphism). Methods may be declared <b>public</b>,
<b>private</b>, <b>protected</b>, or given default access rights.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="parameter+var84">
</a><a name="parameter+val84">
</a>A formal parameter may have a <b>val</b>, <b>var</b>, or <b>ref</b>
modifier; <b>val</b> is the default.
The body of the method is executed in an environment in which 
each formal parameter corresponds to a local variable (<b>var</b> iff the
formal parameter is <b>var</b>)
and is initialized with the value of the actual parameter.
Call-by-reference, <b>ref</b> parameters, allows passing in variables for a
method to update, as described in &#167;. 

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.4.1">
8.4.1</a>&nbsp;&nbsp;Method Guards</h3>
<a name="MethodGuard">
</a>

<div class="p"><!----></div>
Often, a method will only make sense to invoke under certain
statically-determinable conditions.  For example, <b>example(x)</b> is only
well-defined when <b>x != null</b>, as <b>null.toString()</b> throws a null
pointer exception: 
<pre>
class Example {
   var f : String = "";
   def example(x:Object){x != null} = {
      this.f = x.toString();
   }
}
</pre>

(We could have used a constrained type <b>Object{self!=null}</b> instead; in
most cases it is a matter of personal preference or convenience of expression
which one to use.) 

<div class="p"><!----></div>
The requirement of having a method guard is that callers must demonstrate to
the X10
compiler that the guard is satisfied.  (As usual with static constraint
checking, there is no runtime cost.  Indeed, this code can be more efficient
than usual, as it is statically provable that <b>x != null</b>.)
This may require a cast: 
<pre>
  def exam(e:Example, x:Object) {
    if (x != null) 
       e.example(x as Object{x != null});
    // WRONG: if (x != null) e.example(x);
  }
</pre>

<div class="p"><!----></div>
The guard <b>{c}</b> 
in a guarded method 
<b>def m(){c} = E;</b>
specifies a constraint <b>c</b> on the
properties of the class <b>C</b> on which the method is being defined. The
method exists only for those instances of <b>C</b> which satisfy <b>c</b>.  It is
illegal for code to invoke the method on objects whose static type is
not a subtype of <b>C{c}</b>.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
The compiler checks that every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    for a method is type correct. Each argument
    &#235;<sub>i</sub>" must have a
    static type "S<sub>i</sub>" that is a subtype of the declared type
    "T<sub>i</sub>" for the ith
    argument of the method, and the conjunction of the constraints on the
    static types 
    of the arguments must entail the guard in the parameter list
    of the method.

<div class="p"><!----></div>
    The compiler checks that in every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    the static type of <b>o</b>, <b>S</b>, is a subtype of <b>C{c}</b>, where the method
    is defined in class <b>C</b> and the guard for <b>m</b> is equivalent to
    <b>c</b>.

<div class="p"><!----></div>
    Finally, if the declared return type of the method is
    <b>D{d}</b>, the
    return type computed for the call is
    "D{a: S; x<sub>1</sub>: S<sub>1</sub>; ...; x<sub>n</sub>: S<sub>n</sub>; d[a/this]}",
    where <b>a</b> is a new
    variable that does not occur in
    "d, S, S<sub>1</sub>, ..., S<sub>n</sub>", and
    "x<sub>1</sub>, ..., x<sub>n</sub>" are the formal
    parameters of the method.


<div class="p"><!----></div>
     <h3><a name="tth_sEc8.4.2">
8.4.2</a>&nbsp;&nbsp;Property methods</h3>

<div class="p"><!----></div>
Property methods are methods that can be evaluated in constraints.  
For example, the <b>eq()</b> method below tells if the <b>x</b> and <b>y</b>
properties are equal; the <b>is(z)</b> method tells if they are both equal to
<b>z</b>.  These can be used in constraints, as illustrated in the
<b>example()</b> method.
<pre>
class Example(x:Int, y:Int) {
   def this(x:Int, y:Int) { property(x,y); }
   property eq() = (x==y);
   property is(z:Int) = x==z &amp;&amp; y==z;
   def example( a : Example{eq()}, b : Example{is(3)} ) {}
}
</pre>

<div class="p"><!----></div>
A method declared with the modifier <b>property</b> may be used
in constraints.  A property method declared in a class must have
a body and must not be <b>Void</b>.  The body of the method must
consist of only a single <b>return</b> statement or a single
expression.  It is a static error if the expression cannot be
represented in the constraint system. 

<div class="p"><!----></div>
The expression may contain invocations of other property methods. It is the
responsibility of the programmer to ensure that the evaluation of a property
terminates at compile-time, otherwise the type-checker will not terminate and
the program will fail to compile in a potentially most unfortunate way.

<div class="p"><!----></div>
Property methods in classes are implicitly <b>final</b>; they cannot be
overridden.

<div class="p"><!----></div>
A nullary property method definition may omit the formal parameters and
the <b>def</b> keyword.  That is, the following are equivalent:

<div class="p"><!----></div>
<pre>
property def rail(): Boolean = rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
</pre>
and
<pre>
property rail: Boolean = rect &amp;&amp; onePlace == here &amp;&amp; zeroBased;
</pre>

<div class="p"><!----></div>
Similarly, nullary property methods can be inspected in constraints without
<b>()</b>.  
<b>w.rail</b>, with either definition above, 
is equivalent to 
<b>w.rail()</b>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.4.3">
8.4.3</a>&nbsp;&nbsp;Method overloading, overriding, hiding, shadowing and obscuring</h3>
<a name="MethodOverload">
</a>

<div class="p"><!----></div>
The definitions of method overloading, overriding, hiding, shadowing
and obscuring in X10 are the same as in Java, modulo the following
considerations motivated by type parameters and dependent types.

<div class="p"><!----></div>
Two or more methods of a class or interface may have the same
name if they have a different number of type parameters, or
they have formal parameters of different types.  &lt;em&#62;E.g.&lt;/em&#62;, the following is legal: 

<div class="p"><!----></div>
<pre>
class Mful{
   def m() = 1;
   def m[T]() = 2;
   def m(x:Int) = 3;
   def m[T](x:Int) = 4;
}
</pre>

<div class="p"><!----></div>
X10 v2.1 does not permit overloading based on constraints. That is, the
following is <em>not</em> legal, although either method definition individually
is legal:
<pre>
   def n(x:Int){x==1} = &#246;ne";
   def n(x:Int){x!=1} = "not";
</pre>

<div class="p"><!----></div>
The definition of a method declaration "m<sub>1</sub>" "having the same signature
as" a method declaration "m<sub>2</sub>" involves identity of types. 

<div class="p"><!----></div>
The <em>constraint erasure</em> of a type "T" is defined as follows.
The constraint erasure of  (a)&#227; class, interface or struct type "T" is 
"T"; (b)&#227; type "T{c}" is the constraint erasure of 
"T"; (b)&#227; type "T[S<sub>1</sub>,&#8230;,S<sub>n</sub>]" 
is "T'[S<sub>1</sub>',&#8230;,S<sub>n</sub>']" where each primed type is the erasure of 
the corresponding unprimed type.
 Two methods are said to have <em>the
  same signature</em> if (a) they have the same number of type parameters,
(b) they have the same number of formal (value) parameters, and (c)
for each formal parameter the constraint erasure of its types are equivalent. It is a
compile-time error for there to be two methods with the same name and
same signature in a class (either defined in that class or in a
superclass).

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
A class <b>C</b> may not have two declarations for a method named <b>m</b>-either
  defined at <b>C</b> or inherited:
<pre>
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: T<sub>1</sub>, ..., v<sub>n</sub>: T<sub>n</sub>){tc}: T {...}
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: S<sub>1</sub>, ..., v<sub>n</sub>: S<sub>n</sub>){sc}: S {...}
</pre>

if it is the case that the constraint erasures of the types "T<sub>1</sub>",
..., "T<sub>n</sub>" are
equivalent to the constraint erasures of the types "S<sub>1</sub>, ..., T<sub>n</sub>"
respectively.


<div class="p"><!----></div>
In addition, the guard of a overriding method must be 
no stronger than the guard of the overridden method.   This
ensures that any virtual call to the method
satisfies the guard of the callee.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
If a class <b>C</b> overrides a method of a class or interface
  <b>B</b>, the guard of the method in <b>B</b> must entail
  the guard of the method in <b>C</b>.


<div class="p"><!----></div>
A class <b>C</b> inherits from its direct superclass and superinterfaces all
their methods visible according to the access modifiers
of the superclass/superinterfaces that are not hidden or overridden. A method "M<sub>1</sub>" in a class
<b>C</b> overrides
a method  in a superclass <b>D</b> if
"M<sub>1</sub>" and "M<sub>2</sub>" have the same signature.
Methods are overriden on a signature-by-signature basis.

<div class="p"><!----></div>
A method invocation &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
is said to have the <em>static signature</em>
 where <b>T</b> is the static type of
<b>o</b>, and
"T<sub>1</sub>",
...,
"T<sub>n</sub>"
are the static types of &#235;<sub>1</sub>", ..., &#235;<sub>n</sub>",
respectively.  As in
Java, it must be the case that the compiler can determine a single
method defined on <b>T</b> with argument type
"T<sub>1</sub>", ... "T<sub>n</sub>"; otherwise, a
compile-time error is declared. However, unlike Java, the X10 type <b>T</b>
may be a dependent type <b>C{c}</b>. Therefore, given a class definition for
<b>C</b> we must determine which methods of <b>C</b> are available at a type
<b>C{c}</b>. But the answer to this question is clear: exactly those methods
defined on <b>C</b> are available at the type <b>C{c}</b>
whose guard <b>d</b> is implied by <b>c</b>.

<div class="p"><!----></div>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>
<pre>
</pre>

 <h2><a name="tth_sEc8.5">
8.5</a>&nbsp;&nbsp;Static initialization</h2>
<a name="StaticInitialization">
</a>
<a name="initialization+static85">
</a>
The X10 runtime implements the following procedure to ensure
reliable initialization of the static state of classes.

<div class="p"><!----></div>
Execution commences with a single thread executing the
<em>initialization</em> phase of an X10 computation at place <b>0</b>. This
phase must complete successfully before the body of the <b>main</b> method is
executed.

<div class="p"><!----></div>
The initialization phase must be thought of as if it is implemented in
the following fashion: (The implementation may do something more
efficient as long as it is faithful to this semantics.)

<div class="p"><!----></div>
<pre>
Within the scope of a new finish
for every static field f of every class C 
   (with type T and initializer e):
async {
  val l = e; 
  ateach (Dist.makeUnique()) {
     assign l to the static f field of 
         the local C class object;
     mark the f field of the local C 
         class object as initialized;
  }
}
</pre>

<div class="p"><!----></div>
During this phase, any read of a static field <b>C.f</b> (where <b>f</b> is of type <b>T</b>)
is replaced by a call to the method <b>C.read_f():T</b> defined on class <b>C</b>
as follows

<div class="p"><!----></div>
<pre>
def read_f():T {
   await (initialized(C.f));
   return C.f;
}
</pre>

<div class="p"><!----></div>
If all these activities terminate normally, all static fields have values of
their declared types, 
and the <b>finish</b> terminates normally. If
any activity throws an exception, the <b>finish</b> throws an
exception. Since no user code is executing which can catch exceptions
thrown by the finish, such exceptions are printed on the console, and
computation aborts.

<div class="p"><!----></div>
If the activities deadlock, the implementation deadlocks.

<div class="p"><!----></div>
In all cases, the main method is executed only once all static fields
have been initialized correctly.

<div class="p"><!----></div>
Since static state is immutable and is replicated to all places via 
the initialization phase as described above, it can be accessed from
any place.

<div class="p"><!----></div>
 <h2><a name="tth_sEc8.6">
8.6</a>&nbsp;&nbsp;User-Defined Operators</h2>

<div class="p"><!----></div>
It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a <b>Poly</b> class of
polynomials - for the sake of illustration, single-variable polynomials with
<b>Int</b> coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: <b>+</b> to add, <b>*</b> to multiply,
<b>-</b> to subtract, and <b>p(x)</b> to compute the value of the polynomial at
argument <b>x</b>.  We would like to write code thus: 

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static def main(Rail[String]):Void {
     val X = new Poly([0,1]);
     val t &lt;: Poly = 7 * X + 6 * X * X * X; 
     val u &lt;: Poly = 3 + 5*X - 7*X*X;
     val v &lt;: Poly = t * u - 1;
     for( [i] in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Writing the same code with method calls, while possible, is far less elegant: 

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t &lt;: UglyPoly = X.mult(7).plus(X.mult(X).mult(X).mult(6));  
     val u &lt;: UglyPoly = const(3).plus(X.mult(5)).minus(X.mult(X).mult(7));
     val v &lt;: UglyPoly = t.mult(u).minus(1);
     for( [i] in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
</pre>

<div class="p"><!----></div>
The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as <b>1+X</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.6.1">
8.6.1</a>&nbsp;&nbsp;Binary Operators</h3>

<div class="p"><!----></div>
Defining the sum <b>P+Q</b> of two polynomials looks much like a method
definition.  It uses the <b>operator</b> keyword instead of <b>def</b>, and
<b>this</b> appears in the definition in the place that a <b>Poly</b> would
appear in a use of the operator.  So, 
<b>operator this + (p:Poly)</b> explains how to add <b>this</b> to a
<b>Poly</b> value.
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public def degree() = coeff.size()-1;
  public def  a(i:Int) = (i&lt;0 </td><td width="150">
&#124;</td><td width="150">
&#124; i&#62;this.degree()) ? 0 : coeff(i);

<div class="p"><!----></div>
  public operator this + (p:Poly) =  new Poly(
     new Array[Int](
        Math.max(this.coeff.size(), p.coeff.size()),
        (i:Int) =&#62; this.a(i) + p.a(i)
     )); 
  // ... 
</pre>

<div class="p"><!----></div>
The sum of a polynomial and an integer, <b>P+3</b>, looks like
an overloaded method definition.  
<pre>
   public operator this + (n : Int) = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
However, we want to allow the sum of an integer and a polynomial as well:
<b>3+P</b>.  It would be quite inconvenient to have to define this as a method
on <b>Int</b>; changing <b>Int</b> is far outside of normal coding.  So, we
allow it as a method on <b>Poly</b> as well.

<div class="p"><!----></div>
<pre>
   public operator (n : Int) + this = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
<b>Poly</b>s could have been written:
<pre>
  public static operator (p:Poly) + (q:Poly) =  new Poly(
     new Array[Int](
        Math.max(q.coeff.size(), p.coeff.size()),
        (i:Int) =&#62; q.a(i) + p.a(i)
     ));
</pre>

<div class="p"><!----></div>
This requires the following syntax:<br />

  :
  |
  
  
  
  <em>
  
<table>

<tr><td align="right">MethodHeader ::=
  <b>operator</b> TypeParameterList<sup>?</sup>&nbsp;<b>this</b> BinOp <b>(</b>  FormalParameter <b>)</b> </td></tr>
<tr><td align="right">&amp;&amp; Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">MethodHeader ::=
  <b>operator</b> TypeParameterList<sup>?</sup>&nbsp;<b>(</b>  FormalParameter <b>)</b> BinOp <b>this</b>  </td></tr>
<tr><td align="right">&amp;&amp; Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right">MethodHeader ::=
  <b>operator</b> TypeParameterList<sup>?</sup>&nbsp;<b>(</b>  FormalParameter <b>)</b> BinOp  <b>(</b>  FormalParameter <b>)</b>  </td></tr>
<tr><td align="right">&amp;&amp; Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
When X10 attempts to typecheck a binary operator expression like <b>P+Q</b>, it
first typechecks <b>P</b> and <b>Q</b>. Then, it looks for operator declarations
for <b>+</b> in the types of <b>P</b> and <b>Q</b>. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a <em>best-matching</em> operation, &lt;em&#62;viz&lt;/em&#62; one which does
not require the operands to be converted to another type. For example,
<b>operator this + (n:Long)</b> and <b>operator this + (n:Int)</b> both apply to
<b>p+1</b>, because <b>1</b> can be converted from an <b>Int</b> to a <b>Long</b>.
However, the <b>Int</b> version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.

<div class="p"><!----></div>
The main difference between expressing a binary operation as an instance
method (with a <b>this</b> in the definition) and a static one (no <b>this</b>)
is that instance methods don't apply any conversions, while static methods
attempt to convert both arguments. 


<div class="p"><!----></div>
     <h3><a name="tth_sEc8.6.2">
8.6.2</a>&nbsp;&nbsp;Unary Operators</h3>

<div class="p"><!----></div>
Unary operators are defined in a similar way, with <b>this</b> appearing in the
<b>operator</b> definition where an actual value would occur in a unary
expression.  The operator to negate a polynomial is: 

<div class="p"><!----></div>
<pre>
  public operator - this = new Poly(
    new Array[Int](coeff.size(), (i:Int) =&#62; -coeff(i))
    );
</pre>

<div class="p"><!----></div>
The syntax for unary operators is:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodHeader ::=
  <b>operator</b> PrefixOp <b>this</b>    Guard<sup>?</sup>&nbsp;ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;
</td></tr></table>
</em>

<div class="p"><!----></div>
The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.6.3">
8.6.3</a>&nbsp;&nbsp;Type Conversions</h3>

<div class="p"><!----></div>
Explicit type conversions, <b>e as T{c}</b>, can be defined as operators on
class <b>T</b>.

<div class="p"><!----></div>
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public static operator (a:Int) as Poly = new Poly([a]);
  public static def main(Rail[String]):Void {
     val three : Poly = 3 as Poly;
  }
}
</pre>

<div class="p"><!----></div>
You may define a type conversion to a constrained type, like <b>Poly</b> in
the previous example.   If you convert to a more specific constraint, X10 will use
the conversion, but insert a dynamic check to make sure that you have
satisfied the more specific constraint.  
For example: 
<pre>
class Uni(n:Int) {
/*
//  LIMITATION: This example should compile, but doesn't.

<div class="p"><!----></div>
  public def this(n:Int) : Uni{self.n==n} = {property(n);}
  static operator (String) as Uni{self.n != 9} = new Uni(3);
  public static def main(Rail[String]):Void {
    val u = "" as Uni{self.n != 9 &amp;&amp; self.n != 3};
  }
*/
}
</pre>
The string <b>""</b> is converted to <b>Uni{self.n != 9}</b> via the defined
conversion operator, and that value is checked against the remaining
constraints <b>{self.n != 3}</b> at runtime.  (In this case it will fail.)

<div class="p"><!----></div>
There may be many conversions from different types to <b>T</b>, but there may
be at most one conversion from any given type to <b>T</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.6.4">
8.6.4</a>&nbsp;&nbsp;Implicit Type Coercions</h3>

<div class="p"><!----></div>
You may also define <em>implicit</em> type coercions to <b>T{c}</b> as static
operators in class <b>T</b>.  The syntax for this is
<b>static operator (x:U) : T{c} = e</b>.
Implicit coercions are used automatically by the compiler.  


<div class="p"><!----></div>
For example, we can define an implicit coercion from <b>Int</b> to <b>Poly</b>,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define <b>+</b> on
two polynomials (using a <b>static</b> operator, so that implicit coercions
will be used - they would not be for an instance method operator).  The
calculation <b>1+x</b> coerces <b>1</b> to a polynomial and uses polynomial
addition to add it to <b>x</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static operator (c : Int) : Poly = new Poly([c]);

<div class="p"><!----></div>
  public static operator (p:Poly) + (q:Poly) = new Poly(
      new Array[Int](
        Math.max(p.coeff.size(), q.coeff.size()),
        (i:Int) =&#62; p.a(i) + q.a(i)
     ));

<div class="p"><!----></div>
  public static def main(Array[String](1)):Void {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.6.5">
8.6.5</a>&nbsp;&nbsp;<b>set</b> and <b>apply</b></h3>
<a name="set86">
</a>
<a name="apply86">
</a>
<a name="()86">
</a>
<a name="()=86">
</a>
<a name="set-and-apply">
</a>
X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The <b>Array</b>-like classes take advantage
of both of these in <b>a(i) = a(i) + 1</b>.  Unlike unary and binary operators,
subscripting and indexed assignment are done by methods, <b>apply</b> and
<b>set</b> respectively.

<div class="p"><!----></div>
<b>a(b,c,d)</b> is short for the method call <b>a.apply(b,c,d)</b>.  Since it is
possible to overload methods, the application syntax can be overloaded.  For
example, an ordered dictionary structure could allow subscripting by numbers
with <b>def apply(i:Int)</b>, and by string-valued keys with 
<b>def apply(s:String)</b>.  

<div class="p"><!----></div>
<b>a(i)=b</b> is short for the method call <b>a.set(b,i)</b>, with one or more
indices <b>i</b>. (This has a
possibly surprising consequence for the order of evaluation: in <b>a(i)=b</b>,
as in <b>a.set(b,i)</b>, <b>a</b> is evaluated first, then <b>b</b>, and finally
<b>i</b>.)  Again, it is possible to overload <b>set</b> to provide a variety of
subscripting operations.  Each <b>set</b> method must have a corresponding
<b>apply</b> method; that is, <b>a(i,j)=b</b> is only defined when <b>a(i,j)</b>
is defined, despite the fact that <b>a(i,j)=b</b> does not evaluate <b>a(i,j)</b>.

<div class="p"><!----></div>
The <b>Oddvec</b> class of somewhat peculiar vectors illustrates this.
<b>a()</b> returns a string representation of the oddvec, which probably should
be done by <b>toString()</b> instead.  <b>a(i)</b> picks out one of the three
coordinates of <b>a</b>, which is sensible.  <b>a(i)=b</b> assigns to one of the
coordinates.  <b>a(i,j)=b</b> assigns different values to <b>a(i)</b> and
<b>a(j)</b>, purely for the sake of the example.

<div class="p"><!----></div>
<pre>
class Oddvec {
  var v : Rail[Int] = Rail.make[Int](3, (Int)=&#62;0);
  public def apply() = "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public def apply(i:Int) = v(i);
  public def apply(i:Int, j:Int) = [v(i),v(j)];
  public def set(newval:Int, i:Int) = {v(i) = newval;}
  public def set(newval:Int, i:Int, j:Int) = {
       v(i) = newval; v(j) = newval+1;} 
  // ... 
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8.7">
8.7</a>&nbsp;&nbsp;Class Guards and Invariants</h2><a name="DepType:ClassGuard">
</a>
<a name="type invariants87">
</a>
<a name="class invariants87">
</a>
<a name="guards87">
</a>

<div class="p"><!----></div>
Classes (and structs and interfaces) may specify a <em>class guard</em>, a
constraint which must hold on all values of the class.    In the following
example, a <b>Line</b> is defined by two distinct <b>Pt</b>s<a href="#tthFtNtABB" name="tthFrefABB"><sup>11</sup></a>
<pre>
class Pt(x:Int, y:Int){}
class Line(a:Pt, b:Pt){a != b} {}
</pre>

<div class="p"><!----></div>
In most cases the class guard could be phrased as a type constraint on a property of
the class instead, if preferred.  Arguably, a symmetric constraint like two
points being different is better expressed as a class guard, rather than
asymmetrically as a constraint on one type: 
<pre>
class Line(a:Pt, b:Pt{a != b}) {}
</pre>

<div class="p"><!----></div>
<a name="DepType:TypeInvariant">
</a><a name="Class invariant87">
</a><a name="DepType:ClassGuardDef">
</a>With every defined class, struct,  or interface <b>T</b> we associate a <em>type
invariant</em> <i>inv</i>(<b>T</b>), which describes the guarantees on the
properties of values of type <b>T</b>.  

<div class="p"><!----></div>
Every value of <b>T</b> satisfies <i>inv</i>(<b>T</b>) at all times.  This
is somewhat stronger than the concept of type invariant in most languages
(which only requires that the invariant holds when no method calls are
active).  X10 invariants only concern properties, which are immutable; thus,
once established, they cannot be falsified.

<div class="p"><!----></div>
The type
invariant associated with <b>x10.lang.Any</b>
is 
<b>true</b>.

<div class="p"><!----></div>
The type invariant associated with any interface or struct <b>I</b> that extends
interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>" and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is given by:

<div class="p"><!----></div>
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) 
    &amp;&amp; self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
    &amp;&amp; c  
</pre>

<div class="p"><!----></div>
Similarly the type invariant associated with any class <b>C</b> that
implements interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>",
extends class <b>D</b> and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is
given by the same thing with the invariant of the superclass <b>D</b> conjoined:
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) 
    &amp;&amp; self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
    &amp;&amp; c  
    &amp;&amp; {inv}(D)
</pre>

<div class="p"><!----></div>
Note that the type invariant associated with a class entails the type
invariants of each interface that it implements (directly or indirectly), and
the type invariant of each ancestor class.
It is guaranteed that for any variable <b>v</b> of
type <b>T{c}</b> (where <b>T</b> is an interface name or a class name) the only
objects <b>o</b> that may be stored in <b>v</b> are such that <b>o</b> satisfies
<i>inv</i>(T[o/this])&#8743;c[o/self].

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7.1">
8.7.1</a>&nbsp;&nbsp;Invariants for <b>implements</b> and <b>extends</b> clauses</h3><a name="DepType:Implements">
</a>
<a name="DepType:Extends">
</a>
<a name="type-checking+implements clause87">
</a>
<a name="type-checking+extends clause87">
</a>
<a name="implements clause87">
</a>
<a name="extends  clause87">
</a>
Consider a class definition
<pre>
{<em>{</em>ClassModifiers}}<sup>{</sup>{?}}
class C(x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>) extends D{d}
   implements I<sub>1</sub>{c<sub>1</sub>}, ..., I<sub>k</sub>{c<sub>k</sub>}
{<em>{</em>ClassBody}}
</pre>

<div class="p"><!----></div>
Each of the following static semantics rules must be satisfied:

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Int-implements):
The type invariant  of <b>C</b> must entail
"c<sub>i</sub>[this/self]" for each i in {{1, ..., k}}


<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Super-extends):
The return type <b>c</b> of each constructor in <em>ClassBody</em>
must entail <b>d</b>.


<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7.2">
8.7.2</a>&nbsp;&nbsp;Invariants and constructor definitions</h3>

<div class="p"><!----></div>
A constructor for a class <b>C</b> is guaranteed to return an object of the
class on successful termination. This object must satisfy  "<i>inv</i>(C)", the
class invariant associated with <b>C</b> (&#167;<a href="#DepType:TypeInvariant">8.7</a>).
However,
often the objects returned by a constructor may satisfy <em>stronger</em>
properties than the class invariant. X10's dependent type system
permits these extra properties to be asserted with the constructor in
the form of a constrained type (the "return type" of the constructor):

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="ConstructorGuard">
</a>The parameter list for the constructor
may specify a <em>guard</em> that is to be satisfied by the parameters
to the list.

<div class="p"><!----></div>
Here is another example, constructed as a simplified 
version of <b>x10.lang.Region</b>.  The <b>mockUnion</b> method 
has the type that a true <b>union</b> method would have.

<div class="p"><!----></div>
<pre>
class MyRegion(rank:Int) {
  static type MyRegion(n:Int)=MyRegion{self.rank==n};
  def this(r:Int):MyRegion(r) {
    property(r);
  }
  def this(diag:Array[Int](1)):MyRegion(diag.size){ 
    property(diag.size);
  }
  def mockUnion(r:MyRegion(rank)):MyRegion(rank) = this;
  def example() {
    val R1 : MyRegion(3) = new MyRegion([4,4,4]); 
    val R2 : MyRegion(3) = new MyRegion([5,4,1]); 
    val R3 = R1.mockUnion(R2); // inferred type MyRegion(3)
  }
}
</pre>
The first constructor returns the empty region of rank <b>r</b>.  The
second constructor takes a <b>ValRail[Int]</b> of arbitrary length
<b>n</b> and returns a <b>MyRegion(n)</b> (intended to represent the set
of points in the rectangular parallelopiped between the origin and the
<b>diag</b>.)

<div class="p"><!----></div>
The code in <b>example</b> typechecks, and <b>R3</b>'s type is inferred as
<b>MyRegion(3)</b>.  

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Super-invoke):
   Let <b>C</b> be a class with properties
   , invariant <b>c</b>
   extending the constrained type <b>D{d}</b> (where <b>D</b> is the name of a class).

<div class="p"><!----></div>
   For every constructor in <b>C</b> the compiler checks that the call to
   super invokes a constructor for <b>D</b> whose return type is strong enough
   to entail <b>d</b>. Specifically, if the call to super is of the form 
     &#223;uper(e<sub>1</sub>, ..., e<sub>k</sub>)"
   and the static type of each expression &#235;<sub>i</sub>" is
   "S<sub>i</sub>", and the invocation
   is statically resolved to a constructor
"def this(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>k</sub>: T<sub>k</sub>){c}: D{d<sub>1</sub>}"
   then it must be the case that 
<pre>
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>i</sub>: S<sub>i</sub> &#124;&mdash; x<sub>i</sub>: T<sub>i</sub>  (for i  &#8712; {1, ..., k})
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> &#124;&mdash; c  
d<sub>1</sub>[a/self], x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> &#124;&mdash; d[a/self]      
</pre>
 where <b>a</b> is a constant that does not appear in 
"x<sub>1</sub>: S<sub>1</sub> &#8743; ... &#8743; x<sub>k</sub>: S<sub>k</sub>".


<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Constructor return):
   The compiler checks that every constructor for <b>C</b> ensures that
   the properties "p<sub>1</sub>,..., p<sub>n</sub>" are initialized with values which satisfy
   , and its own return type <b>c'</b> as follows.  In each constructor, the
   compiler checks that the static types "T<sub>i</sub>" of the expressions &#235;<sub>i</sub>"
   assigned to "p<sub>i</sub>" are such that the following is
   true:
<pre>
p<sub>1</sub>: T<sub>1</sub>, ..., p<sub>n</sub>: T<sub>n</sub> &#124;&mdash; t(C) &#8743; c'     
</pre>

(Note that for the assignment of &#235;<sub>i</sub>" to "p<sub>i</sub>"
to be type-correct it must be the
    case that "p<sub>i</sub>: T<sub>i</sub> &#8743; p<sub>i</sub>: P<sub>i</sub>".) 

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Constructor invocation):
The compiler must check that every invocation "C(e<sub>1</sub>, ..., e<sub>n</sub>)" to a
constructor is type correct: each argument &#235;<sub>i</sub>" must have a static type
that is a subtype of the declared type "T<sub>i</sub>" for the ith
argument of the
constructor, and the conjunction of static types of the argument must
entail the <em>Guard</em> in the parameter list of the constructor.


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7.3">
8.7.3</a>&nbsp;&nbsp;Object Initialization</h3>

<div class="p"><!----></div>
X10 does object initialization safely.  It avoids a few classes of bad things: 

<ol type="1">
<li> Use of a field before the field has been initialized.
<div class="p"><!----></div>
</li>

<li> <b>this</b> escaping from a constructor;
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
It should be unsurprising that fields must not be used before they are
initialized. At best, it is uncertain what value will be in them, as in
<b>x</b> below. Worse, the value might not even be an allowable value; <b>y</b>,
declared to be nonzero in the following example, might be zero before it is
initialized. 
<pre>
// Not correct X10
class ThisIsWrong {
  val x : Int;
  val y : Int{y != 0};
  def this() {
    x10.io.Console.OUT.println("x=" + x + "; y=" + y);
    x = 1; y = 2;
  }
}
</pre>

<div class="p"><!----></div>
One particularly insidious way to read uninitialized fields is to allow
<b>this</b> to escape from a constructor. For example, the constructor could
put <b>this</b> into a data structure before initializing it, and another
activity could read it from the data structure and look at its fields: 
<pre>
class Wrong {
  val shouldBe8 : Int;
  static Cell[Wrong] wrongCell = new Cell[Wrong]();
  static def doItWrong() {
     finish { 
       async { new Wrong(); } // (A)
       assert( wrongCell().shouldBe8 == 8); // (B)
     }
  }
  def this() {
     wrongCell.set(this); // (C) - ILLEGAL 
     this.shouldBe8 = 8; // (D)
  }
}
</pre>

In this example, the underconstructed <b>Wrong</b> object is leaked into a
storage cell at line <b>(C)</b>, and then initialized.  The <b>doItWrong</b>
method constructs a new <b>Wrong</b> object, and looks at the <b>Wrong</b>
object in the storage cell to check on its <b>shouldBe8</b> field.  One
possible order of events is the following: 

<ol type="1">
<li> <b>doItWrong()</b> is called.
<div class="p"><!----></div>
</li>

<li> <b>(A)</b> is started.  Space for a new <b>Wrong</b> object is allocated.
      Its <b>shouldBe8</b> field, not yet initialized, contains some garbage
      value.
<div class="p"><!----></div>
</li>

<li> <b>(C)</b> is executed, as part of the process of constructing a new
      <b>Wrong</b> object.  The new, uninitialized object is stored in
      <b>wrongCell</b>.
<div class="p"><!----></div>
</li>

<li> Now, the initialization activity is paused, and execution of the main activity 
      proceeds from <b>(B)</b>.
<div class="p"><!----></div>
</li>

<li> The value in <b>wrongCell</b> is retrieved, and is <b>shouldBe8</b> field
      is read.  This field contains garbage, and the assertion fails.
<div class="p"><!----></div>
</li>

<li> Now let the initialization activity proceed with <b>(D)</b>,
      initializing <b>shouldBe8</b> - too late.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
X10 must protect against such possibilities.  The rules explaining how
constructors can be written are somewhat intricate; they are designed to allow
as much programming as possible without leading to potential problems.
Ultimately, they simply are elaborations of the fundamental principles that
uninitialized fields must never be read, and <b>this</b> must never be leaked.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7.4">
8.7.4</a>&nbsp;&nbsp;Constructors and NonEscaping Methods</h3>

<div class="p"><!----></div>
In general, constructors must not be allowed to call methods with<b>this</b> as
an argument or receiver. Such calls could leak references to <b>this</b>,
either directly from a call to <b>cell.set(this)</b>, or indirectly because
<b>toString</b> leaks <b>this</b>, and the concatenation 
`&#203;scaper = "+this` calls <b>toString</b>.<a href="#tthFtNtABC" name="tthFrefABC"><sup>12</sup></a>
<pre>
class Escaper {
  static val Cell[Escaper] cell = new Cell[Escaper]();
  def toString() {
    cell.set(this);
    return &#203;vil!";
  }
  def this() {
    cell.set(this);
    x10.io.Console.OUT.println(&#203;scaper = " + this);
  }
}
</pre>

<div class="p"><!----></div>
However, it is convenient to be able to call methods from constructors; <em>
e.g.</em>, a class might have eleven constructors whose common behavior is best
described by three methods.  
Under certain stringent conditions, it <em>is</em>
safe to call a method: the method called must not leak references to
<b>this</b>, and must not read <b>val</b>s or <b>var</b>s which might not have
been assigned.   

<div class="p"><!----></div>
So, X10 performs a static dataflow analysis, sufficient to guarantee that
method calls in constructors are safe.  This analysis requires having access
to or guarantees about all the code that could possibly be called.  This can
be accomplished in two ways: 

<ol type="1">
<li> Ensuring that only code from the class itself can be called, by 
      forbidding overriding of
      methods called from the constructor: they can be marked <b>final</b> or
      <b>private</b>, or the whole class can be <b>final</b>.
<div class="p"><!----></div>
</li>

<li> Marking the methods called from the constructor by
      <b>@NonEscaping("v1,v2")</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>

<h4>Non-Escaping Methods</h4>
<a name="method+non-escaping87">
</a>
<a name="method+implicitly non-escaping87">
</a>
<a name="method+87">
</a>
<a name="implicitly non-escaping87">
</a>
<a name="non-escaping87">
</a>
<a name="non-escaping+implicitly87">
</a>
<a name="87">
</a>

<div class="p"><!----></div>
A method may be annotated with <b>@NonEscaping("v1,v2")</b>.  This
imposes several restrictions on the method body, and on all methods overriding
it.  However, it is the only way that a method can be called from
constructors, and simultaneously be overridable and non-private.  The
<b>@NonEscaping</b> annotation makes explicit all the X10 compiler's needs for
constructor-safety.  

<div class="p"><!----></div>
A method can, however, be safe to call from constructors without being marked
<b>@NonEscaping</b>. We call such methods <em>implicitly non-escaping</em>.
Implicitly non-escaping methods need to obey the same constraints on
<b>this</b>, <b>super</b>, and variable usage as <b>@NonEscaping</b> methods. An
implicitly non-escaping method <em>could</em> be marked as
<b>@NonEscaping("v1,v2")</b> for some list of variables; the compiler, in
effect, infers the annotation. In addition, implicitly non-escaping methods
must be <b>private</b> or <b>final</b> or members of a <b>final</b> class; this
corresponds to the hereditary nature of <b>@NonEscaping</b> (by forbidding
inheritance of implicitly non-escaping methods).

<div class="p"><!----></div>
We say that a method is <em>non-escaping</em> if it is either implicitly
non-escaping, or annotated <b>@NonEscaping</b>.

<div class="p"><!----></div>
The first requirement on non-escaping methods is that they do not allow
<b>this</b> to escape. Inside of their bodies, <b>this</b> and <b>super</b> may
only be used for field access and assignment, and as the receiver of
non-escaping methods.

<div class="p"><!----></div>
<b>@NonEscaping("v1,v2")</b> methods specify a list of fields of <b>this</b>, as
a string argument of the annotation: in this example, the fields are <b>v1</b>
and <b>v2</b>.  These are the only fields of <b>this</b> that can be <em>read</em>
in the body of the method.  So, <b>x = this.v3</b> would be forbidden-as
would a call to a method which reads <b>v3</b>, even if that method were
non-escaping. 

<div class="p"><!----></div>
For a method to be implicitly non-escaping, there must be <em>some</em> such list
of fields.  

<div class="p"><!----></div>
Finally, if a method <b>m</b> in class <b>C</b> is marked
<b>@NonEscaping("v1,v2")</b>, then every method which overrides <b>m</b> in any
subclass of <b>C</b> must be annotated with precisely the same annotation,
<b>@NonEscaping("v1,v2")</b>, as well.  

<div class="p"><!----></div>
The following example uses most of the possible variations (leaving out
<b>final</b> class).  <b>aplomb()</b> explicitly forbids reading any field but
<b>a</b>. <b>boric()</b> is called after <b>a</b> and <b>b</b> are set, but
{c} is not. 
The <b>@NonEscaping</b> annotation on <b>boric()</b> is optional, but the
compiler will print a warning if it is left out.
<b>cajoled()</b> is only called after all fields are set, so it
can read anything; its annotation, too, is not required.   <b>SeeAlso</b> is able to override <b>aplomb()</b>, because
<b>aplomb()</b> is <b>@NonEscaping(&#228;")</b>; it cannot override the final method
<b>boric()</b> or the private one <b>cajoled()</b>.  Even for overriding
<b>aplomb()</b>, it is crucial that <b>SeeAlso.aplomb()</b> be 
declared <b>@NonEscaping(&#228;")</b>, just like <b>C2.aplomb()</b>.
<pre>
import x10.compiler.*;

<div class="p"><!----></div>
class C2 {
  protected val a:Int, b:Int, c:Int;
  protected var x:Int, y:Int, z:Int;
  def this() {
    a = 1;
    this.aplomb();
    b = 2;
    this.boric();
    c = 3;
    this.cajoled();
  }
  @NonEscaping(&#228;") def aplomb() {
    x = a;
    // this.boric(); // not allowed; boric reads b.
    // z = b; // not allowed - only 'a' can be read here
  }
  @NonEscaping("b") final def boric() {
    y = b;
    this.aplomb(); // allowed; a is definitely set before boric is called
    // z = c; // not allowed; c is not definitely written 
  }
  @NonEscaping("c") private def cajoled() {
    z = c;
  }  
}

<div class="p"><!----></div>
class See extends C2 {}

<div class="p"><!----></div>
class SeeAlso extends See { 
  @NonEscaping(&#228;") def aplomb() {
    x = a + 2;
  }
}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7.5">
8.7.5</a>&nbsp;&nbsp;Fine Structure of Constructors</h3>
<a name="SFineStructCtors">
</a>

<div class="p"><!----></div>
The code of a constructor consists of four segments, three of them optional
and one of them implicit.

<ol type="1">
<li> The first segment is an optional call to <b>this(...)</b> or
      <b>super(...)</b>.  If this is supplied, it must be the first statement
      of the constructor.  If it is not supplied, the compiler treats it as a
      nullary super-call <b>super()</b>;
<div class="p"><!----></div>
</li>

<li> If the class or struct has properties, there must be a single
      <b>property(...)</b> command in the constructor.  Every execution path
      through the constructor must go through this <b>property(...)</b> command
      precisely once.   The second segment of the constructor is the code
      following the first segment, up to and including the <b>property()</b>
      statement.  

<div class="p"><!----></div>
      If the class or struct has no properties, the <b>property()</b> call is
      optional. If it is present, the second segment is defined as before.  If
      it is absent, the second segment is empty.
<div class="p"><!----></div>
</li>

<li> The third segment is automatically generated.  Fields with initializers
      are initialized immediately after the <b>property</b> statement.  
      In the following example, <b>b</b> is initialized to <b>y*9000</b> in
      segment three.  The initialization makes sense and does the right
      thing; <b>b</b> will be <b>y*9000</b> for every <b>Overdone</b> object. 
      (This would not be possible if field initializers were processed
      earlier, before properties were set.)
<div class="p"><!----></div>
</li>

<li> The fourth segment is the remainder of the constructor body.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The segments in the following code are shown in the comments.
<pre>
class Overlord(x:Int) {
  def this(x:Int) { property(x); }
}//Overlord
class Overdone(y:Int) extends Overlord  {
  val a : Int;
  val b =  y * 9000;
  def this(r:Int) {
    super(r);                      // (1)
    x10.io.Console.OUT.println(r); // (2)
    property(r+1);                 // (2)
    // field initializations here  // (3)
    a = r + 2;                     // (4)
  }
}//Overdone
</pre>

<div class="p"><!----></div>
The rules of what is allowed in the three segments are different, though
unsurprising.  For example, properties of the current class can only be read
in segment 3 or 4-naturally, because they are set at the end of segment 2.  

<div class="p"><!----></div>

<h4>Initialization and Inner Classses</h4>
<a name="constructor+inner classes in87">
</a>

<div class="p"><!----></div>
Constructors of inner classes are tantamount to method calls on <b>this</b>.  
For example, the constructor for Inner <b>is</b> acceptable.  It does not leak
<b>this</b>.  It leaks <b>Outer.this</b>, which is an utterly different object.  
So, the call to <b>this.new Inner()</b> in the <b>Outer</b> constructor <em>
is</em> illegal.  It would leak <b>this</b>.  There is no special rule in effect
preventing this; a constructor call of an inner class is no 
different from a method as far as leaking is concerned.
<pre>
class Outer {
  static val leak : Cell[Outer] = new Cell[Outer](null);
  class Inner {
     def this() {Outer.leak.set(Outer.this);}
  }
  def /*Outer*/this() {
     //ILLEGAL: val inner = this.new Inner(); 
  }
}
</pre>

<div class="p"><!----></div>

<h4>Initialization and Closures</h4>
<a name="constructor+closure in87">
</a>

<div class="p"><!----></div>
Closures in constructors are valid if they were invoked (or inlined) at the
place of creation. For example, <b>closure</b> below is acceptable because it
only refers to fields defined at the point it was written.  <b>badClosure</b>
would not be acceptable, because it refers to fields that were not defined at
that point, although they were defined later.
<pre>
class C {
  val a = 3;
  val closure = () =&#62; a*10; // This is OK
  //val badClosure = () =&#62; b*10; 
  val b = 4;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7.6">
8.7.6</a>&nbsp;&nbsp;Definite Initialization in Constructors</h3>

<div class="p"><!----></div>
An instance field <b>var x:T</b>, when <b>T</b> has a default value, need not be
explicitly initialized.  In this case, <b>x</b> will be initialized to the
default value of type <b>T</b>.  For example, a <b>Score</b> object will have
its <b>currently</b> field initialized to zero, below:
<pre>
class Score {
  public var currently : Int;
}
</pre>

<div class="p"><!----></div>
All other sorts of instance fields do need to be initialized before they can
be used.  <b>val</b> fields must be initialized, even if their type has a
default value.  It would be silly to have a field <b>val z : Int</b> that was
always given default value of <b>0</b> and, since it is <b>val</b>, can never be
changed.  <b>var</b> fields whose type has no default value must be initialized
as well, such as <b>var y : Int{y != 0}</b>, since it cannot be assigned a
sensible initial value. 

<div class="p"><!----></div>
The fundamental principles are: 

<ol type="1">
<li> <b>val</b> fields must be assigned precisely once in each constructor on every
possible execution path.
<div class="p"><!----></div>
</li>

<li> <b>var</b> fields of defaultless type must be
assigned at least once on every possible execution path, but may be assigned
more than once.
<div class="p"><!----></div>
</li>

<li> No variable may be read before it is guaranteed to have been
assigned.
<div class="p"><!----></div>
</li>

<li> Initialization may be by field initialization expressions (<b>val x :
      Int = y+z</b>), or by uninitialized fields <b>val x : Int;</b> plus
an initializing assignment <b>x = y+z</b>.  Recall that field initialization
expressions are performed after the <b>property</b> statement, in segment 3 in
the terminology of &#167;<a href="#SFineStructCtors">8.7.5</a>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7.7">
8.7.7</a>&nbsp;&nbsp;Summary of Restrictions on Classes and Constructors</h3>

<div class="p"><!----></div>

<table>
<tr><td align="left">&#126;
  &amp; <b>Example</b>
  &amp; <b>Prop.</b>
  &amp; <b><tt><font size="-1">self==this</font></tt>(1)</b>
  &amp; <b>Prop.Meth.</b>
  &amp; <b><tt>this</tt></b>
  &amp; <b>fields</b>
</td></tr>
<tr><td align="left">Type of property 
  &amp; (A) 
  &amp; %?properties
    yes (2)
  &amp; no %? self==this
  &amp; no %? property methods
  &amp; no %? this may be used
  &amp; no %? fields may be used
</td></tr>
<tr><td align="left">Class Invariant
  &amp; (B) 
  &amp; yes %?properties
  &amp; yes %? self==this
  &amp; yes %? property methods
  &amp; yes %? this may be used
  &amp; no %? fields may be used
</td></tr>
<tr><td align="left">Supertype (3)
  &amp; (C), (D)
  &amp; yes%?properties
  &amp; yes%? self==this
  &amp; yes%? property methods
  &amp; no%? this may be used
  &amp; no%? fields may be used
</td></tr>
<tr><td align="left">Property Method Body
  &amp; (E) 
  &amp; yes %?properties
  &amp; yes %? self==this
  &amp; yes %? property methods
  &amp; yes %? this may be used
  &amp; no %? fields may be used
</td></tr>
<tr><td align="left">Static field (4)
  &amp; (F) (G) 
  &amp; no %?properties
  &amp; no %? self==this
  &amp; no %? property methods
  &amp; no %? this may be used
  &amp; no %? fields may be used
</td></tr>
<tr><td align="left">Instance field (5)
  &amp; (H), (I) 
  &amp; yes %?properties
  &amp; yes %? self==this
  &amp; yes %? property methods
  &amp; yes %? this may be used
  &amp; yes %? fields may be used
</td></tr>
<tr><td align="left">Constructor arg. type
  &amp; (J) 
  &amp; no %?properties
  &amp; yes %? self==this
  &amp; no  %? property methods
  &amp; yes %? this may be used
  &amp; no %? fields may be used
</td></tr>
<tr><td align="left">Constructor guard
  &amp; (K) 
  &amp; no %?properties
  &amp; yes %? self==this
  &amp; no %? property methods
  &amp; no %? this may be used
  &amp; no %? fields may be used
</td></tr>
<tr><td align="left">Constructor ret. type
  &amp; (L) 
  &amp; yes %?properties
  &amp; yes %? self==this
  &amp; yes %? property methods
  &amp; yes %? this may be used
  &amp; no %? fields may be used
</td></tr>
<tr><td align="left">Constructor segment 1 
  &amp; (M) 
  &amp; no%?properties
  &amp; yes%? self==this
  &amp; no%? property methods
  &amp; no%? this may be used
  &amp; no%? fields may be used
</td></tr>
<tr><td align="left">Constructor segment 2
  &amp; (N) 
  &amp; no%?properties
  &amp; yes%? self==this
  &amp; no%? property methods
  &amp; no%? this may be used
  &amp; no%? fields may be used
</td></tr>
<tr><td align="left">Constructor segment 4
  &amp; (O) 
  &amp; yes%?properties
  &amp; yes%? self==this
  &amp; yes%? property methods
  &amp; yes%? this may be used
  &amp; yes%? fields may be used
</td></tr>
<tr><td align="left">Methods
  &amp; (P) 
  &amp; yes %?properties
  &amp; yes %? self==this
  &amp; yes %? property methods
  &amp; yes %? this may be used
  &amp; yes %? fields may be used
</td></tr>
<tr><td align="left">place
  &amp; (pos) 
  &amp; %?properties
  &amp; %? self==this
  &amp; %? property methods
  &amp; %? this may be used
  &amp; %? fields may be used
</td></tr></table>


<div class="p"><!----></div>
Details:

<div class="p"><!----></div>

<ul>
<li> (1) Top-level <tt>self</tt> only.
<div class="p"><!----></div>
</li>

<li> (2) The type of the i<sup>th</sup> property may only mention
                 properties 1 through i.
<div class="p"><!----></div>
</li>

<li> (3) Super-interfaces follow the same rules as supertypes.
<div class="p"><!----></div>
</li>

<li> (4) The same rules apply to types and initializers.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The example indices refer to the following code: 
<pre>
class Example (
   prop : Int,
   proq : Int{prop != proq},                    // (A)
   pror : Int
   )
   {prop != 0}                                  // (B)
   extends Supertype[Int{self != prop}]         // (C)
   implements SuperInterface[Int{self != prop}] // (D)
{
   property def propmeth() = (prop == pror);    // (E)
   static staticField 
      : Cell[Int{self != 0}]                    // (F)
      = new Cell[Int{self != 0}](1);            // (G)
   var instanceField                            
      : Int {self != prop}                      // (H)
      = (prop + 1) as Int{self != prop};        // (I)
   def this(
      a : Int{a != 0},
      b : Int{b != a}                           // (J)
      )
      {a != b}                                  // (K)
      : Example{self.prop == a &amp;&amp; self.proq==b} // (L)
   {
      super();                                  // (M)
      property(a,b,a);                          // (N)
      // fields initialized here
      instanceField = b as Int{self != prop};   // (O)
   }

<div class="p"><!----></div>
   def someMethod() = 
        prop + staticField + instanceField;     // (P)
}
</pre>


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc8.8">
8.8</a>&nbsp;&nbsp;Method Resolution</h2>

<div class="p"><!----></div>
Method resolution is the problem of determining, statically, which method (or
constructor or operator)
should be invoked, when there are several choices that could be invoked.  For
example, the following class has two overloaded <b>zap</b> methods, one taking
an <b>Object</b>, and the other a <b>Resolve</b>.  Method resolution will figure
out that the call <b>zap(1..4)</b> should call <b>zap(Object)</b>, and
<b>zap(new Resolve())</b> should call <b>zap(Resolve)</b>.  

<div class="p"><!----></div>
<pre>
class Resolve {
  static def zap(Object) = &#214;bject";
  static def zap(Resolve) = "Resolve";
  public static def main(argv:Array[String](1)) {
    Console.OUT.println(zap(1..4));
    Console.OUT.println(zap(new Resolve()));
  }
}
</pre>

<div class="p"><!----></div>
The basic concept of method resolution is quite straightforward: 

<ol type="1">
<li> List all the methods that could possibly be used;
<div class="p"><!----></div>
</li>

<li> Pick the most specific one;
<div class="p"><!----></div>
</li>

<li> Fail if there is not a unique most specific one.
<div class="p"><!----></div>
</li>
</ol>

In the presence of X10's highly-detailed type system, some subtleties arise. 
One point, at least, is <em>not</em> subtle. The same procedure is used, <em>
mutatis mutandis</em> for method, constructor, and operator resolution.  

<div class="p"><!----></div>
Generics introduce several subtleties, especially with the inference of
generic types. 

<div class="p"><!----></div>
For the purposes of method resolution, all that matters about a method,
constructor, or operator <b>M</b> - we use the word method" to include all
three choices for this section - is: 

<ol type="1">
<li> The method name <b>m</b>;
<div class="p"><!----></div>
</li>

<li> The generic type parameters "G<sub>1</sub>,&#8230;, G<sub>g</sub>".  If there
      are no generic type parameters, x=0.
<div class="p"><!----></div>
</li>

<li> The types "x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>" of the formal parameters.  If
      there are no formal parameters, f=0. In the case of an instance
      method, the receiver will be the first formal parameter.<a href="#tthFtNtABD" name="tthFrefABD"><sup>13</sup></a>
<div class="p"><!----></div>
</li>

<li> The constraint <b>c</b>. If no constraint is specified, <b>c</b> is
      <b>true</b>.
<div class="p"><!----></div>
</li>

<li> A <em>unique identifier</em> <b>id</b>, sufficient to tell the compiler
      which method body is intended.  A file name and position in that file
      would suffice.  The details of the identifier are not relevant.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
For the purposes of understanding method resolution, we assume that all the
actual parameters of an invocation are simply variables: <b>x1.meth(x2,x3)</b>.
This is done routinely by the compiler in any case; the code 
<b>tbl(i).meth(true, a+1)</b> would be treated roughly as 
<pre>
val x1 = tbl(i);
val x2 = true;
val x3 = a+1;
x1.meth(x2,x3);
</pre>

<div class="p"><!----></div>
All that matters about an invocation <b>I</b> is: 

<ol type="1">
<li> The method name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> The generic type parameters "G&#8242;<sub>1</sub>,&#8230;, G&#8242;<sub>g</sub>".  If there
      are no generic type parameters, x=0.
<div class="p"><!----></div>
</li>

<li> The names and types "x<sub>1</sub>:T&#8242;<sub>1</sub>,&#8230;, x<sub>f</sub>:T&#8242;<sub>f</sub>" of the actual parameters.  If
      there are no actual parameters, f=0. In the case of an instance
      method, the receiver is the first actual parameter.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The signature of the method resolution procedure is: 
<b>resolve(invo : Invocation, context: Set[Method]) : MethodID</b>.  
Given a particular invocation and the set <b>context</b> of all methods
which could be called at that point of code, method resolution either returns
the unique identifier of the method that should be called, or (conceptually)
throws an exception if the call cannot be resolved.

<div class="p"><!----></div>
The procedure for computing <b>resolve(invo, context)</b> is: 

<ol type="1">
<li> Eliminate from <b>context</b> those methods which are not <em>
      acceptable</em>; , those whose name, type parameters, formal parameters,
      and constraint do not suitably match <b>invo</b>.  In more detail:
      
<ul>
<li> The method name <b>m</b> must simply equal the invocation name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> X10 infers type parameters, by an algorithm given in &#167;.
<div class="p"><!----></div>
</li>

<li> The method's type parameters are bound to the invocation's for the
            remainder of the acceptability test.
<div class="p"><!----></div>
</li>

<li> The actual parameter types must be subtypes of the formal
            parameter types:  "T&#8242;<sub>i</sub> &lt;: Ti<sub>i</sub>" for each <em>i</em>.
<div class="p"><!----></div>
</li>

<li> The formal constraint <b>c</b> must be satisfied in the invoking
            context.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Eliminate from <b>context</b> those methods which are not <em>
      available</em>; , those which cannot be called due to visibility
      constraints, such as methods from other classes marked <b>private</b>.
      The remaining methods are both acceptable and available; they might be
      the one that is intended.
<div class="p"><!----></div>
</li>

<li> From the remaining methods, find the unique <b>ms</b> which is more specific than all the
      others, , for which <b>specific(ms,mo) = true</b> for all other
      methods <b>mo</b>
      The specificity test <b>specific</b> is given next.
      
<ul>
<li> If there is a unique such <b>ms</b>, then
            <b>resolve(invo,context)</b> returns the <b>id</b> of <b>ms</b>.
<div class="p"><!----></div>
</li>

<li> If there is not a unique such <b>ms</b>, then <b>resolve</b> reports
            an error.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The subsidiary procedure <b>specific(m1, m2)</b> determines whether method
<b>m1</b> is equally or more specific than <b>m2</b>.  <b>specific</b> is not a
total order: is is possible for each one to be considered more specific than
the other, or either to be more specific.  <b>specific</b> is computed as: 

<ol type="1">
<li> Construct an invocation <b>invo1</b> based on <b>m1</b>: 
      
<ul>
<li> <b>invo1</b>'s method name is <b>m1</b>'s method name;
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s generic parameters are those of <b>m1</b>- simply
            some type variables.
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s parameters are those of <b>m1</b>.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> If <b>m2</b> is acceptable for the invocation <b>invo1</b>,
      <b>specific(m1,m2)</b> returns true; otherwise, it returns false.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp9">
Chapter 9 </a><br />Structs</h1>
<a name="XtenStructs">
</a>
<a name="StructClasses">
</a>
<a name="Structs">
</a>
<a name="structs90">
</a>

<div class="p"><!----></div>
X10 objects are a powerful general-purpose programming tool. However, the
power must be paid for in space and time. In space, a typical object
implementation requires some extra memory for run-time class information, as
well as a pointer for each reference to the object.  In time, a typical object
requires an extra indirection to read or write data, and some computation to
figure out which method body to call.  

<div class="p"><!----></div>
For high-performance computing, this overhead may not be acceptable for all
objects. X10 provides structs, which are stripped-down objects. They are less
powerful than objects; in particular they lack inheritance and mutable fields.
Without inheritance, method calls do not need to do any lookup; they can be
implemented directly. Accordingly, structs can be implemented and used more
cheaply than objects, potentially avoiding the space and time overhead.
(Currently, the C++ back end avoids the overhead, but the Java back end
implements structs as Java objects and does not avoid it.)

<div class="p"><!----></div>
Structs and classes are interoperable. Both can implement interfaces (in
particular, like all X10 values they implement <b>Any</b>), and subprocedures
whose arguments are defined by interfaces can take both structs and classes.
(Some caution is necessary here: referring to a struct through an interface
requires overhead similar to that required for an object.)

<div class="p"><!----></div>
They are also interconvertable, within the constraints of structs. If you
start off defining a struct and decide you need a class instead, the code
change required is simply changing the keyword <b>struct</b> to <b>class</b>. If
you have a class that does not use inheritance or mutable fields, it can be
converted to a struct by changing its keyword.

<div class="p"><!----></div>
 <h2><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Struct declaration</h2>
A struct declaration has the structure: 
<pre>
{<em>{</em>StructModifiers}}<sup>{</sup>{?}}
struct C[X<sub>1</sub>, &#8230;, X<sub>n</sub>](p<sub>1</sub>:T<sub>1</sub>, &#8230;, p<sub>n</sub>:T<sub>n</sub>){c} 
   implements I<sub>1</sub>, &#8230;, I<sub>k</sub> {
{<em>{</em>StructBody}}
}
</pre>

<div class="p"><!----></div>
All fields of a struct must be <b>val</b>.

<div class="p"><!----></div>
A struct <b>S</b> cannot contain a field of type <b>S</b>, or a field of struct
type <b>T</b> which, recursively, contains a field of type <b>S</b>.  This
restriction is necessary to permit <b>S</b> to be implemented as a contiguous
block of memory of size equal to the sum of the sizes of its fields.  

<div class="p"><!----></div>
Values of a struct <b>C</b> type can be created by invoking a constructor
defined in <b>C</b>, but without prefixing it with <b>new</b>: 
<pre>
struct Polar(r:Double, theta:Double){
  def this(r:Double, theta:Double) {property(r,theta);}
  static val Origin = Polar(0,0);
  static val x0y1 = Polar(1, 3.14159/2);
}
</pre>

<div class="p"><!----></div>
Structs support the same notions of generics, properties, and constrained
types that classes do.  For example, the <b>Pair</b> type below provides pairs
of values; the <b>diag()</b> method applies only when the two elements of the
pair are equal, and returns that common value: 
<pre>
struct Pair[T,U](t:T, u:U) {
  def this(t:T, u:U) { property(t,u); }
  def diag(){T==U &amp;&amp; t==u} = t;
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;Boxing of structs</h2>
<a name="auto-boxing+struct to interface92">
</a>
<a name="auto-boxing">
</a> 
If a struct <b>S</b> implements an interface <b>I</b> (&lt;em&#62;e.g.&lt;/em&#62;, <b>Any</b>),
a value {v} of type <b>S</b> can be assigned to a variable of type
<b>I</b>. The implementation creates an object <b>o</b> that is an
instance of an anonymous class implementing <b>I</b> and containing
{v}.  The result of invoking a method of <b>I</b> on <b>o</b> is the
same as invoking it on {v}. This operation is termed <em>auto-boxing</em>.
It allows full interoperability of structs and objects-at the cost of losing
the extra efficiency of the structs when they are boxed.

<div class="p"><!----></div>
In a generic class or struct obtained by instantiating a type parameter
<b>T</b> with a struct <b>S</b>, variables declared at type <b>T</b> in the body
of the class are not boxed. They are implemented as if they were declared at
type <b>S</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc9.3">
9.3</a>&nbsp;&nbsp;Optional Implementation of <b>Any</b> methods</h2>
<a name="StructAnyMethods">
</a>
<a name="Any+structs93">
</a>

<div class="p"><!----></div>
Unlike objects, structs do not have global identity. Instead, two
structs are equal (<b>==</b>) if and only if their corresponding fields
are equal (<b>==</b>). 

<div class="p"><!----></div>
All structs implement <b>x10.lang.Any</b>. 
Structs are required to implement the following methods from <b>Any</b>.  
Programmers need not provide them; X10 will produce them automatically if 
the program does not include them. 
<pre>
  public def equals(Any):Boolean;
  public def hashCode():Int;
  public def typeName():String;
  public def toString():String;  
</pre>

<div class="p"><!----></div>
A programmer who provides an explicit implementation
of <b>equals(Any)</b> for a struct <b>S</b> should also consider
supplying a definition for <b>equals(S):Boolean</b>. This will often
yield better performance since the cost of an upcast to <b>Any</b> and
then a downcast to <b>S</b> can be avoided.

<div class="p"><!----></div>
 <h2><a name="tth_sEc9.4">
9.4</a>&nbsp;&nbsp;Primitive Types</h2>

<div class="p"><!----></div>
Certain types that might be built in to other languages are in fact
implemented as structs in package <b>x10.lang</b> in X10. Their methods and
operations are often provided with <b>@Native</b> (&#167;) rather
than X10 code, however. These types are:
<pre>
boolean, char, byte, short, int, long
float, double, ubyte, ushort, uint, ulong
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc9.5">
9.5</a>&nbsp;&nbsp;Generic programming with structs</h2>

<div class="p"><!----></div>
An unconstrained type variable <b>X</b> can be instantiated with <b>Object</b> or
its subclasses or structs or functions.

<div class="p"><!----></div>
Within a generic struct, all the operations of <b>Any</b> are available
on a variable of type <b>X</b>. Additionally, variables of type <b>X</b> may
be used with <b>==, !=</b>, in <b>instanceof</b>, and casts.

<div class="p"><!----></div>
The programmer must be aware of the different interpretations of
equality for structs and classes and ensure that the code is correctly
written for both cases. If necessary the programmer can write code
that distinguishes between the two cases (a type parameter <b>X</b> is
instantiated to a struct or not) as follows:

<div class="p"><!----></div>
<pre>
val x:X = ...;
if (x instanceof Object) { // x is a real object
   val x2 = x as Object; // this cast will always succeed.
   ...
} else { // x is a struct
   ...
}
</pre>

<div class="p"><!----></div>
   <h2><a name="tth_sEc9.6">
9.6</a>&nbsp;&nbsp;Example structs</h2>

<div class="p"><!----></div>
<b>x10.lang.Complex</b> provides a detailed example of a practical struct,
suitable for use in a library.  For a shorter example, we define the
<b>Pair</b> struct-available in <b>x10.util.Pair</b>.  A <b>Pair</b> packages
two values of possibly unrelated type together in a single value, &lt;em&#62;e.g.&lt;/em&#62;, to
return two values from a function.

<div class="p"><!----></div>
<pre>
struct Pair[T,U] {
    public val first:T;
    public val second:U;
    public def this(first:T, second:U):Pair[T,U] {
        this.first = first;
        this.second = second;
    }
    public def toString():String {
        return "(" + first + ", " + second + ")";
    }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp10">
Chapter 10 </a><br />Functions</h1>
<a name="Functions">
</a>
<a name="functions">
</a>
<a name="functions100">
</a>
<a name="Closures">
</a>

<div class="p"><!----></div>
 <h2><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;Overview</h2>
Functions, the last of the three kinds of values in X10, encapsulate pieces of
code which can be applied to a vector of arguments to produce a value.
Functions, when applied, can do nearly anything that any other code could do:
fail to terminate, throw an exception, offer values, modify variables, spawn activities,
execute in several places, and so on. X10 functions are not mathematical
functions: the <b>f(1)</b> may return <b>true</b> on one call and <b>false</b> on
an immediately following call.

<div class="p"><!----></div>
It is a limitation of X10 v2.1 that functions do not support
type arguments. This limitation may be removed in future versions of
the language.

<div class="p"><!----></div>
A <em>function literal</em> <b>(x1:T1,..,xn:Tn){c}:T=&#62;e</b> creates a function of
type<br /><b>(x1:T1,...,xn:Tn){c}=&#62;T</b> (&#167;<a href="#FunctionType">4.6</a>).  For example, 
<b>(x:Int) =&#62; x*x</b> is a function literal describing the squaring function on
integers.   
<b>null</b> is also a function value.

<div class="p"><!----></div>
Function application is written <b>f(a,b,c)</b>, following common mathematical
usage. 
<a name="Exception+unchecked101">
</a>
Function invocation may throw unchecked exceptions. 

<div class="p"><!----></div>
The function body may be a block.  To compute integer squares by repeated
addition (inefficiently), one may write: 
<pre>
val sq: (Int) =&#62; Int 
      = (n:Int) =&#62; {
           var s : Int = 0;
           val abs_n = n &lt; 0 ? -n : n;
           for ([i] in 1..abs_n) s += abs_n;
           s
        };
</pre>

<div class="p"><!----></div>
A function literal evaluates to a function entity &#981;. When &#981; is
applied to a suitable list of actual parameters <b>a1</b>-<b>an</b>, it
evaluates <b>e</b> with the formal parameters bound to the actual parameters.
So, the following are equivalent, where <b>e</b> is an expression involving
<b>x1</b> and <b>x2</b><a href="#tthFtNtABE" name="tthFrefABE"><sup>14</sup></a>

<div class="p"><!----></div>
<pre>
{
  val f = (x1:T1,x2:T2){true}:T =&#62; e;
  val a1 : T1 = arg1();
  val a2 : T2 = arg2();
  result = f(a1,a2);
}
</pre>
and 
<pre>
{
  val a1 : T1 = arg1();
  val a2 : T2 = arg2();
  {
     val x1 : T1 = a1;
     val x2 : T2 = a2;
     result = e;
  }  
}
</pre>

This doesn't quite work if the body is a statement rather than an expression.
A few language features are forbidden (<b>break</b> or <b>continue</b> of a loop
that surrounds the function literal) or mean something different (<b>return</b>
inside a function returns from the function). 

<div class="p"><!----></div>
The <em>method selector expression</em> <b>e.m.(x1:T1,...,xn:Tn)</b> (&#167;)
permits the specification of the function underlying
the method <b>m</b>, which takes arguments of type <b>(x1:T1,..., xn:Tn)</b>.
Within this function, <b>this</b> is bound to the result of evaluating {e}.

<div class="p"><!----></div>
Function types may be used in <b>implements</b> clauses of class
definitions. Instances of such classes may be used as functions of the
given type.  Indeed, an object may behave like any (fixed) number of
functions, since the class it is an instance of may implement any
(fixed) number of function types.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc10.2">
10.2</a>&nbsp;&nbsp;Function Literals</h2>
<a name="literal+function102">
</a>
<a name="FunctionLiteral">
</a>

<div class="p"><!----></div>
X10 provides first-class, typed functions, including
<em>closures</em>, <em>operator functions</em>, and <em>method
  selectors</em>.

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">ClosureExpression ::=
        <b>(</b>
        Formals
        <b>)</b>
</td></tr>
<tr><td align="right">&amp;&amp;
        Guard
        ReturnType
        Throws
        Offers
        <b>=&#62;</b> ClosureBody </td></tr>
<tr><td align="right">ClosureBody ::=
        Expression </td></tr>
<tr><td align="right">&#124; <b> Statement <b></b></b> </td></tr>
<tr><td align="right">&#124; <b> Statement Expression <b></b></b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Functions have zero or more formal parameters, an optional return type, an
optional set of exceptions throws by the body, and an optional type offered by
the body.  The body has the
same syntax as a method body; it may be either an expression, a block
of statements, or a block terminated by an expression to return. In
particular, a value may be returned from the body of the function
using a return statement (&#167;). 

<div class="p"><!----></div>
The type of a
function is a function type (&#167;<a href="#FunctionType">4.6</a>).  In some cases the
return type <b>T</b> is also optional and defaults to the type of the
body. If a formal <b>xi</b> does not occur in any
<b>Tj</b>, {c}, <b>T</b> or {e}, the declaration <b>xi:Ti</b> may
be replaced by just <b>Ti</b>: <b>(Int)=&#62;7</b> is the integer function returning
7 for all inputs.

<div class="p"><!----></div>
<a name="ClosureGuard">
</a>As with methods, a function may declare a guard to
constrain the actual parameters with which it may be invoked.
The guard may refer to the type parameters, formal parameters,
and any <b>val</b>s in scope at the function expression.

<div class="p"><!----></div>
The body of the function is evaluated when the function is
invoked by a call expression (&#167;), not at the function's
place in the program text.

<div class="p"><!----></div>
As with methods, a function with return type <b>Void</b> cannot
have a terminating expression. 
If the return type is omitted, it is inferred, as described in
&#167;<a href="#TypeInference">4.11</a>.
It is a static error if the return type cannot be inferred.  ,
<b>(Int)=&#62;null</b> is not well-defined; X10 does not know which type of
<b>null</b> is intended.  
But <b>(Int):Rail[Double] =&#62; null</b> is legal.

<div class="p"><!----></div>
The following method takes a function parameter and uses it to
test each element of the list, returning the first matching
element.  It returns <b>otherwise</b> if no element matches.

<div class="p"><!----></div>
<pre>

<div class="p"><!----></div>
def find[T](f: (T) =&#62; Boolean, xs: List[T], absent:T): T = {
  for (x: T in xs)
    if (f(x)) return x;
  absent
  }
</pre>

<div class="p"><!----></div>
The method may be invoked thus:
<pre>
xs: List[Int] = new ArrayList[Int]();
x: Int = find((x: Int) =&#62; x&#62;0, xs, 0);
</pre>

<div class="p"><!----></div>
As with a normal method, the function may have a <b>throws</b>
clause. It is a static error if the body of the function throws a
checked exception that is not declared in the function's <b>throws</b>
clause.

<div class="p"><!----></div>
Similarly, it may have an <b>offers T</b> clause; it is a static error if the
body offers any value not of type <b>T</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc10.2.1">
10.2.1</a>&nbsp;&nbsp;Outer variable access</h3>

<div class="p"><!----></div>
In a function
"(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} =&#62; { s }"
the types , the guard <b>c</b> and the body <b>s</b>
may access many, though not all, sorts of variables from outer scopes.  
Specifically, they can access: 

<ul>
<li> All fields of the enclosing object and class;
<div class="p"><!----></div>
</li>

<li> All type parameters;
<div class="p"><!----></div>
</li>

<li> All <b>val</b> variables;
<div class="p"><!----></div>
</li>

<li> <b>var</b> variables with the <b>shared</b> annotation.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<em><em>Limitation</em> <b>shared</b> is not currently supported.</em>

<div class="p"><!----></div>
The function body may refer to instances of enclosing classes using
the syntax <b>C.this</b>, where <b>C</b> is the name of the
enclosing class.  <b>this</b> refers to the instance of the immediately
enclosing class, as usual.

<div class="p"><!----></div>
For example, the following is legal.  However, it would not be legal to add
<b>e</b> or <b>h</b> to the sum; they are non-<b>shared</b> <b>var</b>s from the
surrounding scope.

<div class="p"><!----></div>
<pre>
class Lambda {
   var a : Int = 0;
   val b = 0;
   def m(var c : Int, shared var d : Int,  val e : Int) {
      var f : Int = 0;
      shared var g : Int = 0;
      val h : Int = 0;
      val closure = (var i: Int, val j: Int) =&#62; {
    	  return a + b + d + g + i + j + this.a + Lambda.this.a;
      };
      return closure;
   }
}
</pre>

<div class="p"><!----></div>
<b>Rationale:</b> Non-<b>shared</b> <b>var</b>s like <b>e</b> and <b>h</b> are
excluded in X10, as in many other languages, for practical implementation
reasons. They are allocated on the stack, which is desirable for efficiency.
However, the closure may exist for long after the stack frame containing
<b>e</b> and <b>h</b> has been freed, so those storage locations are no longer
valid for those variables. <b>shared var</b>s are heap-allocated, which is less
efficient but allows them to exist after <b>m</b> returns. 

<div class="p"><!----></div>
<b>shared</b> does not guarantee <b>atomic</b> access to the shared variable. As
with any code that might mutate shared data concurrently, be sure to protect
references to mutable shared state with <b>atomic</b>. For example, the
following code returns a pair of closures which operate on the same shared
variable <b>a</b>, which are concurrency-safe-even if invoked many times
simultaneously. Without <b>atomic</b>, it would no longer be concurrency-safe.

<div class="p"><!----></div>
<pre>
  def counters() {
      shared var a : Int = 0;
       return [
          () =&#62; {atomic a ++;},
          () =&#62; {atomic return a;}
          ];
   }
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc10.3">
10.3</a>&nbsp;&nbsp;Method selectors</h2>
<a name="MethodSelectors">
</a>
<a name="function+method selector103">
</a>
<a name="method+underlying function103">
</a>

<div class="p"><!----></div>
A method selector expression allows a method to be used as a
first-class function, without writing a function expression for it.
For example, consider a class <b>Span</b> defining ranges of integers.  

<div class="p"><!----></div>
<pre>
class Span(low:Int, high:Int) {
  def this(low:Int, high:Int) {property(low,high);}
  def between(n:Int) = low &lt;= n &amp;&amp; n &lt;= high;
  def example() {
    val digit = new Span(0,9);
    val isDigit : (Int) =&#62; Boolean = digit.between.(Int);
    if (isDigit(8)) x10.io.Console.OUT.println("8 is!");
  }
}
</pre>


<div class="p"><!----></div>
In <b>example()</b>, 
<b>digit.between.(Int)</b> 
is a unary function testing whether its argument is between zero
and nine.  It could also be written 
<b>(n:Int) =&#62; digit.between(n)</b>.

<div class="p"><!----></div>
This is formalized thus:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodSelector ::=
        Primary <b>.</b>
        MethodName <b>.</b>
                TypeParameters <b>(</b> Formals <b>)</b> </td></tr>
<tr><td align="right">&#124;
        TypeName <b>.</b>
        MethodName <b>.</b>
                TypeParameters <b>(</b> Formals <b>)</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The <em>method selector expression</em> <b>e.m.(T1,...,Tn)</b> is type
correct only if  the static type of {e} is a
class or struct or interface <b>V</b> with a method
<b>m(x1:T1,...xn:Tn){c}:T</b> defined on it (for some
<b>x1,...,xn,c,T)</b>. At runtime the evaluation of this expression
evaluates {e} to a value {v} and creates a function <b>f</b>
which, when applied to an argument list <b>(a1,...,an)</b> (of the right
type) yields the value obtained by evaluating <b>v.m(a1,...,an)</b>.

<div class="p"><!----></div>
Thus, the method selector

<div class="p"><!----></div>
<pre>
e.m.[X<sub>1</sub>, ..., X<sub>m</sub>](T<sub>1</sub>, ..., T<sub>n</sub>)
</pre>
 behaves as if it were the function
<pre>
((v:V)=&#62;
  [X<sub>1</sub>, ..., X<sub>m</sub>](x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} 
  =&#62; v.m[X<sub>1</sub>, ..., X<sub>m</sub>](x<sub>1</sub>, ..., x<sub>n</sub>))
(e)
</pre>

<div class="p"><!----></div>
<em><em>Limitation</em> X10 functions, including method selectors, do not currently accept
generic arguments.</em>

<div class="p"><!----></div>
Because of overloading, a method name is not sufficient to
uniquely identify a function for a given class (in Java-like languages).
One needs the argument type information as well.
The selector syntax (dot) is used to distinguish <b>e.m()</b> (a
method invocation on <b>e</b> of method named <b>m</b> with no arguments)
from <b>e.m.()</b>
(the function bound to the method). 

<div class="p"><!----></div>
A static method provides a binding from a name to a function that is
independent of any instance of a class; rather it is associated with the
class itself. The static function selector
"T.m.(T<sub>1</sub>, ..., T<sub>n</sub>)" denotes the
function bound to the static method named <b>m</b>, with argument types
 for the type <b>T</b>. The return type
of the function is specified by the declaration of <b>T.m</b>.

<div class="p"><!----></div>
Users of a function type do not care whether a function was defined
directly (using the function syntax), or obtained via (static or
instance) function selectors.

<div class="p"><!----></div>
 <h2><a name="tth_sEc10.4">
10.4</a>&nbsp;&nbsp;Operator functions</h2>
<a name="OperatorFunction">
</a>
<a name="function+operator104">
</a>
Every operator (e.g.,
<b>+</b>,
<b>-</b>,
<b>*</b>,
<b>/</b>,
...) has a family of functions, one for
each type on which the operator is defined. The function can be
selected using the "." syntax:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">OperatorFunction
        ::= TypeName <b>.</b> Operator <b>(</b> Formals <b>)</b> </td></tr>
<tr><td align="right">&#124; TypeName <b>.</b> Operator </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
If an operator has more than one arity (, unary and binary
<b>-</b>), the unary version may be selected by giving the
formal parameter types.  The binary version is selected by
default, or the types may be specified for clarity.
For example, the following equivalences hold:

<div class="p"><!----></div>
<pre>
String.+              &#8801;  (x: String, y: String): String =&#62; x + y
Long.-                &#8801;  (x: Long, y: Long): Long =&#62; x - y
Float.-(Float,Float)  &#8801;  (x: Float, y: Float): Float =&#62; x - y
Int.-(Int)            &#8801;  (x: Int): Int =&#62; -x
Boolean.&amp;             &#8801;  (x: Boolean, y: Boolean): Boolean =&#62; x &amp; y
Boolean.!             &#8801;  (x: Boolean): Boolean =&#62; !x
Int.&lt;(Int,Int)        &#8801;  (x: Int, y: Int): Boolean =&#62; x &lt; y
Dist.</td><td width="150">
&#124;(Place)         &#8801;  (d: Dist, p: Place): Dist =&#62; d </td><td width="150">
&#124; p
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
Unary and binary promotion (&#167;) is not performed
when invoking these
operations; instead, the operands are coerced individually via implicit
coercions (&#167;), as appropriate.

<div class="p"><!----></div>
<b>The following is not implemented in version 2.0.3:</b>

<div class="p"><!----></div>
Additionally, for every expression <b>e</b> of a type <b>T</b> at which a binary
operator <b>OP</b> is defined, the expression <b>e.OP</b> or
<b>e.OP(T)</b> represents the function
defined by:

<div class="p"><!----></div>
<pre>
(x: T): T =&#62; { e OP x }
</pre>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Primary ::= Expr <b>.</b> Operator <b>(</b> Formals <b>)</b> </td></tr>
<tr><td align="right">&#124; Expr <b>.</b> Operator </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
For example,
one may write an expression that adds one to each member of a
list <b>xs</b> by:

<div class="p"><!----></div>
<pre>
xs.map(1.+);
</pre>


<div class="p"><!----></div>
 <h2><a name="tth_sEc10.5">
10.5</a>&nbsp;&nbsp;Functions as objects of type <b>Any</b></h2>
<a name="FunctionAnyMethods">
</a>

<div class="p"><!----></div>
<a name="FunctionEquality">
</a><a name="function+equality105">
</a> <a name="equality+function105">
</a> Two functions <b>f</b> and
<b>g</b> are equal ("<b>==</b>") if both are instances of classes and the same
object, or if both were obtained by the same evaluation of a function
literal.<a href="#tthFtNtABF" name="tthFrefABF"><sup>15</sup></a> Further, it is guaranteed that if two
functions are equal then they refer to the same locations in the environment
and represent the same code, so their executions in an identical situation are
indistinguishable. (Specifically, if <b>f == g</b>, then <b>f(1)</b> can be
substituted for <b>g(1)</b> and the result will be identical. However, there is
no guarantee that <b>f(1)==g(1)</b> will evaluate to true. Indeed, there is no
guarantee that <b>f(1)==f(1)</b> will evaluate to true either, as <b>f</b> might
be a function which returns n on its n<sup>th</sup> invocation. However,
<b>f(1)==f(1)</b> and <b>f(1)==g(1)</b> are interchangeable.)
<a name="function+==105">
</a>

<div class="p"><!----></div>
Every function type implements all the methods of <b>Any</b>.
b<b>f.equals(g)</b> is equivalent to <b>f==g</b>.  <b>f.hashCode()</b>, 
<b>f.toString()</b>, and <b>f.typeName()</b> are implementation-dependent, but
respect <b>equals</b> and the basic contracts of <b>Any</b>. 
<b>f.home()</b> returns <b>here</b> and <b>f.at(x)</b>
always returns true, as for structs.

<div class="p"><!----></div>
<a name="function+equals105">
</a><a name="function+hashCode105">
</a><a name="function+toString105">
</a><a name="function+typeName105">
</a><a name="function+home105">
</a><a name="function+at(Place)105">
</a><a name="function+at(Object)105">
</a>
<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp11">
Chapter 11 </a><br />Expressions</h1><a name="XtenExpressions">
</a><a name="expressions110">
</a>

<div class="p"><!----></div>
X10 has a rich expression language.
Evaluating an expression produces a value, or, in a few cases, no value. 
Expression evaluation may have side effects, such as change of the value of a 
<b>var</b> variable or a data structure, allocation of new values, or throwing
an exception. 

<div class="p"><!----></div>
Evaluation is performed left to right, wherever possible.  For example, in 
<b>f()(a(),b())</b>, <b>f()</b> is evaluated, then <b>a()</b>, then <b>b()</b>,
andd then the application.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Literals</h2>

<div class="p"><!----></div>
Literals denote fixed values of built-in types. 
The syntax for literals is given in &#167;<a href="#Literals">3</a>. 

<div class="p"><!----></div>
The type that X10 gives a literal often includes its value. , <b>1</b>
is of type <b>Int{self==1}</b>, and <b>true</b> is of type
<b>Boolean{self==true}</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;<b>this</b></h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">ThisExpression ::= <b>this</b> </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> <b>this</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The expression <b>this</b> is a  local <b>val</b> containing a reference
to an instance of the lexically enclosing class.
It may be used only within the body of an instance method, a
constructor, or in the initializer of a instance field - that is, the places
where there is an instance of the class under consideration.

<div class="p"><!----></div>
Within an inner class, <b>this</b> may be qualified with the
name of a lexically enclosing class.  In this case, it
represents an instance of that enclosing class.  
For example, <b>Outer</b> is a class containing <b>Inner</b>.  Each instance of
<b>Inner</b> has a reference <b>outer</b> to the <b>Outer</b> involved in its
creation, which is acquired by use of <b>Outer.this</b>.
<pre>
class Outer {
/* REDO THIS EXAMPLE 
  val inner : Inner = new Inner();
  class Inner {
    val outer : Outer = Outer.this;
  }
  def alwaysTrue() = (this == inner.outer);
*/}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
The type of a <b>this</b> expression is the
innermost enclosing class, or the qualifying class,
constrained by the class invariant and the
method guard, if any.

<div class="p"><!----></div>
The <b>this</b> expression may also be used within constraints in
a class or interface header (the class invariant and
<b>extends</b> and <b>implements</b> clauses).  Here, the type of
<b>this</b> is restricted so that only properties declared in the
class header itself, and specifically not any members declared in the class
body or in supertypes, are accessible through <b>this</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Local variables</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">LocalExpression ::= Identifier </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A local variable expression consists simply of the name of the local variable,
field of the current object, formal parameter in scope, etc. It evaluates to
the value of the local variable. <b>n</b> in the second line below is a local
variable expression. 
<pre>
val n = 22;
val m = n + 56;
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.4">
11.4</a>&nbsp;&nbsp;Field access</h2>
<a name="FieldAccess">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">FieldExpression ::= Expression <b>.</b> Identifier </td></tr>
<tr><td align="right">&#124; <b>super</b> <b>.</b> Identifier </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> Identifier </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> <b>super</b> <b>.</b> Identifier </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A field of an object instance may be  accessed
with a field access expression.

<div class="p"><!----></div>
The type of the access is the declared type of the field with the
actual target substituted for <b>this</b> in the type. 

<div class="p"><!----></div>
The field accessed is selected from the fields and value properties
of the static type of the target and its superclasses.

<div class="p"><!----></div>
If the field target is given by the keyword <b>super</b>, the target's type is
the superclass of the enclosing class.  This form is used to access fields of
the parent class shadowed by same-named fields of the current class.

<div class="p"><!----></div>
If the field target is <b>Cls.super</b>, then the target's type is <b>Cls</b>,
which must be an ancestor class of the enclosing class.  This (admittedly
obscure) form is used to access fields of an ancestor class which are shadowed
by same-named fields of some more recent ancestor.  The following example
illustrates all four cases:

<div class="p"><!----></div>
<pre>
class Uncle {
  public static val f = 1;
}
class Parent {
  public val f = 2;
}
class Ego extends Parent {
  public val f = 3;
  class Child extends Ego {
     public val f = 4;
     def expDotId() = this.f; // 4
     def superDotId() = super.f; // 3
     def classNameDotId() = Uncle.f; // 1;
     def cnDotSuperDotId() = Ego.super.f; // 2
  }
}
</pre>

<div class="p"><!----></div>
If the field target is <b>null</b>, a <b>NullPointerException</b>
is thrown.

<div class="p"><!----></div>
If the field target is a class name, a static field is selected.

<div class="p"><!----></div>
It is illegal to access  a field that is not visible from
the current context.
It is illegal to access a non-static field
through a static field access expression.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.5">
11.5</a>&nbsp;&nbsp;Function Literals</h2>
Function literals are described in &#167;.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.6">
11.6</a>&nbsp;&nbsp;Calls</h2>
<a name="Call">
</a>
<a name="MethodInvocation">
</a>
<a name="MethodInvocationSubstitution">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">MethodCall ::= TypeName <b>.</b> Identifier TypeArguments <b>(</b> ArgumentList <b>)</b> </td></tr>
<tr><td align="right">&#124; <b>super</b> <b>.</b> Identifier TypeArguments <b>(</b> ArgumentList <b>)</b> </td></tr>
<tr><td align="right">&#124; ClassName <b>.</b> <b>super</b> <b>.</b> Identifier TypeArguments <b>(</b> ArgumentList <b>)</b> </td></tr>
<tr><td align="right">Call ::= Primary TypeArguments <b>(</b> ArgumentList <b>)</b> </td></tr>
<tr><td align="right">TypeArguments ::= <b>[</b> Type ( <b>,</b> Type ) <b>]</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A <em>MethodCall</em> may be to either a <b>static</b> or an 
instance method.  A <em>Call</em> may invoke either a method
or a closure.  

<div class="p"><!----></div>
The syntax is ambiguous; the target must be type-checked to determine if it is
the name of a method or if it refers to a field containing a closure. It is a
static error if a call may resolve to both a closure call or to a method call.
<pre>
class Callsome {
  static val closure = () =&#62; 1;
  static def method () = 2;
  static val closureEvaluated = Callsome.closure();
  static val methodEvaluated = Callsome.method();
}
</pre>
However, adding a static method called <b>closure</b> makes <b>Callsome.closure()</b>
ambiguous: it could be a call to the closure, or to the static method: 

<div class="p"><!----></div>
<pre>
  static def closure () = 3;
  // ERROR: static errory = Callsome.closure();
</pre>

<div class="p"><!----></div>
A closure call &#235;(...)" is shorthand for a method call
&#235;.apply(...)". 

<div class="p"><!----></div>
Method selection rules are similar to that of Java.
For a call with no explicit type arguments, a method with 
no parameters is considered more specific than a method with one or more
type parameters that would have to be inferred.

<div class="p"><!----></div>
It is a static error if a method's <em>Guard</em> is not satisfied by the
caller. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.7">
11.7</a>&nbsp;&nbsp;Assignment</h2><a name="assignment117">
</a><a name="AssignmentStatement">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Expression ::= Assignment </td></tr>
<tr><td align="right">Assignment ::= SimpleAssignment </td></tr>
<tr><td align="right">&#124; OpAssignment </td></tr>
<tr><td align="right">SimpleAssignment ::= LeftHandSide <b>=</b> Expression </td></tr>
<tr><td align="right">OpAssignment ::= LeftHandSide <b>+=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>-=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>*=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>/=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>%=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>&amp;=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b></td><td align="center">&#124;=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>^=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>&lt;&lt;=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>&#62;&#62;=</b> Expression </td></tr>
<tr><td align="right">::= LeftHandSide <b>&#62;&#62;&#62;=</b> Expression </td></tr>
<tr><td align="right">LeftHandSide ::= Identifier </td></tr>
<tr><td align="right">&#124; Primary <b>.</b> Identifier </td></tr>
<tr><td align="right">&#124; Primary <b>(</b> Expression <b>)</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The assignment expression <b>x = e</b> assigns a value given by
expression <b>e</b>
to a variable <b>x</b>.  
Most often, <b>x</b> is a mutable (<b>var</b> variable).  The same syntax is
used for delayed initialization of a <b>val</b>, but <b>val</b>s can only be
initialized once.
<pre>
  var x : Int;
  val y : Int;
  x = 1;
  y = 2; // Correct; initializes y
  x = 3; 
  // Incorrect: y = 4;
</pre>

<div class="p"><!----></div>
There are three syntactic forms of
assignment: 

<ol type="1">
<li> <b>x = e;</b>, assigning to a local variable, formal parameter, field of
      <b>this</b>, etc.
<div class="p"><!----></div>
</li>

<li> <b>x.f = e;</b>, assigning to a field of an object.
<div class="p"><!----></div>
</li>

<li> `a(i<sub>1</sub>,&#8230;,i<sub>n</sub>) = v;`, where n  &#8805; 0, assigning to
      an element of an array or some other such structure. This is syntactic
      sugar for a method call: `a.set(v,i<sub>1</sub>,&#8230;,i<sub>n</sub>)`.
      Naturally, it is a static error if no suitable <b>set</b> method exists
      for <b>a</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
For a binary operator &#9674;, the &#9674;-assignment expression
"x &#9674;= e" combines the current value of <b>x</b> with the value
of <b>e</b> by &#9674;, and stores the result back into <b>x</b>.  
<b>i += 2</b>, for example, adds 2 to <b>i</b>. For variables and fields, 
"x &#9674;= e" behaves just like "x = x &#9674; e". 

<div class="p"><!----></div>
The subscripting forms of &#228;(i) &#9674;= b" are slightly subtle.
Subexpressions of <b>a</b> and <b>i</b> are only evaluated once.  However,
<b>a(i)</b> and <b>a(i)=c</b> are each executed once-in particular, there is
one call to <b>a.apply(i)</b> and one to <b>a.set(i,c)</b>, the desugared forms
of <b>a(i)</b> and <b>a(i)=c</b>.  If subscripting is implemented strangely for
the class of <b>a</b>, the behavior is <em>not</em> necessarily updating a single
storage location. Specifically, <b>A()(I()) += B()</b> is tantamount to: 
<pre>
{
  val aa = A();  // Evaluate A() once
  val ii = I();  // Evaluate I() once
  val bb = B();  // Evaluate B() once
  val tmp = aa(ii) + bb; // read aa(ii)
  aa(ii) = tmp;  // write sum back to aa(ii)
}
</pre>

<div class="p"><!----></div>
<em><em>Limitation</em> += does not currently meet this specification.</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.8">
11.8</a>&nbsp;&nbsp;Increment and decrement</h2>

<div class="p"><!----></div>
The operators <b>++</b> and <b>-</b> increment and decrement
a variable, respectively.  
<b>x++</b> and <b>++x</b> both increment <b>x</b>, just as the statement 
<b>x += 1</b> would, and similarly for <b>-</b>.  

<div class="p"><!----></div>
The difference between the two is the return value.  
<b>++x</b> returns the <em>new</em> value of <b>x</b>, after incrementing.
<b>x++</b> returns the <em>old</em> value of <b>, before incrementing.</b>

<div class="p"><!----></div>
<em><em>Limitation</em> This currently only works for numeric types.</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.9">
11.9</a>&nbsp;&nbsp;Numeric Operations</h2>
<a name="XtenPromotions">
</a>
<a name="promotion119">
</a>
<a name="numeric promotion119">
</a>

<div class="p"><!----></div>
Numeric types (<b>Byte</b>, <b>Short</b>, <b>Int</b>, <b>Long</b>, <b>Float</b>,
<b>Double</b>, and unsigned variants of fixed-point types) are normal X10
structs, though most of their methods are implemented via native code. They
obey the same general rules as other X10 structs. For example, numeric
operations are defined by <b>operator</b> definitions, the same way you could
for any struct.

<div class="p"><!----></div>
Promoting a numeric value to a longer numeric type preserves the sign of the
value.  For example, <b>(255 as UByte) as UInt</b> is 255.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.9.1">
11.9.1</a>&nbsp;&nbsp;Conversions and coercions</h3>

<div class="p"><!----></div>
Specifically, each numeric type can be converted or coerced into each other
numeric type, perhaps with loss of accuracy.
<pre>
val f : (Int)=&#62;Boolean = (Int) =&#62; true; 
val n : Byte = 123 as Byte; // explicit 
val ok = f(n); // implicit
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.9.2">
11.9.2</a>&nbsp;&nbsp;Unary plus and unary minus</h3>

<div class="p"><!----></div>
The unary <b>+</b> operation on numbers is an identity function.
The unary <b>-</b> operation on numbers is a negation function.
On unsigned numbers, these are two's-complement.  For example, 
<b>-(0x0F as UByte)</b> is 
<b>(0xF1 as UByte)</b>.


<div class="p"><!----></div>
 <h2><a name="tth_sEc11.10">
11.10</a>&nbsp;&nbsp;Bitwise complement</h2>

<div class="p"><!----></div>
The unary <b>&#126;</b> operator, only defined on integral types, complements each
bit in its operand.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.11">
11.11</a>&nbsp;&nbsp;Binary arithmetic operations</h2> 

<div class="p"><!----></div>
The binary arithmetic operators perform the familiar binary arithmetic
operations: <b>+</b> adds, <b>-</b> subtracts, <b>*</b> multiplies, 
<b>/</b> divides, and <b>%</b>
computes remainder.

<div class="p"><!----></div>
On integers, the operands are coerced to the longer of their two types, and
then operated upon.  
Floating point operations are determined by the IEEE 754
standard. 
The integer <b>/</b> and <b>%</b> throw a <b>DivideByZeroException</b>
if the right operand is zero.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.12">
11.12</a>&nbsp;&nbsp;Binary shift operations</h2>

<div class="p"><!----></div>
The operands of the binary shift operations must be of integral type.
The type of the result is the type of the left operand.

<div class="p"><!----></div>
If the promoted type of the left operand is <b>Int</b>,
the right operand is masked with <b>0x1f</b> using the bitwise
AND (<b>&amp;</b>) operator, giving a number  &#8804;  the number of bits in an
<b>Int</b>. 
If the promoted type of the left operand is <b>Long</b>,
the right operand is masked with <b>0x3f</b> using the bitwise
AND (<b>&amp;</b>) operator, giving a number  &#8804;  the number of bits in a
<b>Long</b>. 

<div class="p"><!----></div>
The <b>&lt;&lt;</b> operator left-shifts the left operand by the number of
bits given by the right operand.
The <b>&#62;&#62;</b> operator right-shifts the left operand by the number of
bits given by the right operand.  The result is sign extended;
that is, if the right operand is k,
the most significant k bits of the result are set to the most
significant bit of the operand.

<div class="p"><!----></div>
The <b>&#62;&#62;&#62;</b> operator right-shifts the left operand by the number of
bits given by the right operand.  The result is not sign extended;
that is, if the right operand is k,
the most significant k bits of the result are set to <b>0</b>.
This operation is deprecated, and may be removed in a later version of the
language. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.13">
11.13</a>&nbsp;&nbsp;Binary bitwise operations</h2>

<div class="p"><!----></div>
The binary bitwise operations operate on integral types, which are promoted to
the longer of the two types.
The <b>&amp;</b> operator  performs the bitwise AND of the promoted operands.
The <b></td><td width="150">
&#124;</b> operator  performs the bitwise inclusive OR of the promoted operands.
The <b>^</b> operator  performs the bitwise exclusive OR of the promoted operands.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.14">
11.14</a>&nbsp;&nbsp;String concatenation</h2>

<div class="p"><!----></div>
The <b>+</b>  operator is used for string concatenation 
 as well as addition.
If either operand is of static type <b>x10.lang.String</b>,
 the other operand is converted to a <b>String</b> , if needed,
  and  the two strings  are concatenated.
 String conversion of a non-<b>null</b> value is  performed by invoking the
 <b>toString()</b> method of the value.
  If the value is <b>null</b>, the value is converted to 
  '"null''.

<div class="p"><!----></div>
The type of the result is <b>String</b>.

<div class="p"><!----></div>
 For example, 
      <b>&#246;ne " + 2 + here</b> 
      evaluates to something like <b>one 2(Place 0)</b>.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.15">
11.15</a>&nbsp;&nbsp;Logical negation</h2>

<div class="p"><!----></div>
The operand of the  unary <b>!</b> operator 
must be of type <b>x10.lang.Boolean</b>.
The type of the result is <b>Boolean</b>.
If the value of the operand is <b>true</b>, the result is <b>false</b>; if
if the value of the operand  is <b>false</b>, the result is <b>true</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.16">
11.16</a>&nbsp;&nbsp;Boolean logical operations</h2>

<div class="p"><!----></div>
Operands of the binary boolean logical operators must be of type <b>Boolean</b>.
The type of the result is <b>Boolean</b>

<div class="p"><!----></div>
The <b>&amp;</b> operator  evaluates to <b>true</b> if both of its
operands evaluate to <b>true</b>; otherwise, the operator
evaluates to <b>false</b>.

<div class="p"><!----></div>
The <b></td><td width="150">
&#124;</b> operator  evaluates to <b>false</b> if both of its
operands evaluate to <b>false</b>; otherwise, the operator
evaluates to <b>true</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.17">
11.17</a>&nbsp;&nbsp;Boolean conditional operations</h2>

<div class="p"><!----></div>
Operands of the binary boolean conditional operators must be of type
<b>Boolean</b>. 
The type of the result is <b>Boolean</b>

<div class="p"><!----></div>
The <b>&amp;&amp;</b> operator  evaluates to <b>true</b> if both of its
operands evaluate to <b>true</b>; otherwise, the operator
evaluates to <b>false</b>.
Unlike the logical operator <b>&amp;</b>,
if the first operand is <b>false</b>,
the second operand is not evaluated.

<div class="p"><!----></div>
The <b></td><td width="150">
&#124;</td><td width="150">
&#124;</b> operator  evaluates to <b>false</b> if both of its
operands evaluate to <b>false</b>; otherwise, the operator
evaluates to <b>true</b>.
Unlike the logical operator <b></td><td width="150">
&#124;</td><td width="150">
&#124;</b>,
if the first operand is <b>true</b>,
the second operand is not evaluated.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.18">
11.18</a>&nbsp;&nbsp;Relational operations</h2> 

<div class="p"><!----></div>
The relational operations compare numbers, producing <b>Boolean</b> results.  

<div class="p"><!----></div>
The <b>&lt;</b> operator evaluates to <b>true</b> if the left operand is
less than the right.
The <b>&lt;=</b> operator evaluates to <b>true</b> if the left operand is
less than or equal to the right.
The <b>&#62;</b> operator evaluates to <b>true</b> if the left operand is
greater than the right.
The <b>&#62;=</b> operator evaluates to <b>true</b> if the left operand is
greater than or equal to the right.

<div class="p"><!----></div>
Floating point comparison is determined by the IEEE 754
standard.  Thus,
if either operand is NaN, the result is <b>false</b>.
Negative zero and positive zero are considered to be equal.
All finite values are less than positive infinity and greater
than negative infinity.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.19">
11.19</a>&nbsp;&nbsp;Conditional expressions</h2>
<a name="Conditional">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">ConditionalExpression ::= Expression
                <b>?</b> Expression
                <b>:</b> Expression 
</td></tr></table>
</em>

<div class="p"><!----></div>
A conditional expression evaluates its first subexpression (the
condition); if <b>true</b>
the second subexpression (the consequent) is evaluated; otherwise,
the third subexpression (the alternative) is evaluated.

<div class="p"><!----></div>
The type of the condition must be <b>Boolean</b>.
The type of the conditional expression is some common 
ancestor (as constrained by &#167;<a href="#LCA">4.9</a>) of the types of the consequent and the
alternative. 

<div class="p"><!----></div>
For example, 
<b>a == b ? 1 : 2</b>
evaluates to <b>1</b> if <b>a</b> and <b>b</b> are the same, and <b>2</b> if they
are different.   As the type of <b>1</b> is <b>Int{self==1}</b> and of <b>2</b>
is <b>Int{self==2}</b>, the type of the conditional expression has the form
<b>Int{c}</b>, where <b>self==1</b> and <b>self==2</b> both imply <b>c</b>.  For
example, it might be <b>Int{true}</b> - or perhaps it might be 
<b>Int{self != 8}</b>. Note that this term has no most accurate type in the X10
type system.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.20">
11.20</a>&nbsp;&nbsp;Stable equality</h2>
<a name="StableEquality">
</a>
<a name="==1120">
</a><a name="+=1120">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">EqualityExpression ::= Expression <b>==</b> Expression </td></tr>
<tr><td align="right">&#124; Expression <b>!=</b> Expression </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The <b>==</b> and <b>!=</b> operators provide a fundamental, though
non-abstract, notion of equality.  <b>a==b</b> is true if the values of <b>a</b>
and <b>b</b> are extremely identical, in a sense defined shortly.  <b>a != b</b>
is true iff <b>a==b</b> is false.

<div class="p"><!----></div>

<ul>
<li> If <b>a</b> and <b>b</b> are values of object type, then <b>a==b</b> holds
      if <b>a</b> and <b>b</b> are the same object.
<div class="p"><!----></div>
</li>

<li> If one operand is <b>null</b>, then <b>a==b</b> holds iff the other is
      also <b>null</b>.
<div class="p"><!----></div>
</li>

<li> If the operands both have struct type, then they must be structurally equal;
that is, they must be instances of the same struct
and all their fields or components must be <b>==</b>.
<div class="p"><!----></div>
</li>

<li> The definition of equality for function types is specified in
      &#167;.
<div class="p"><!----></div>
</li>

<li> If the operands have numeric types, they are coerced into the larger of
      the two types and then compared for numeric equality.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The predicates <b>==</b> and <b>!=</b> may not be overridden by the programmer.
Note that <b>a==b</b> is a form of <em>stable equality</em>; that is, the result of
the equality operation is not affected by the mutable state of the program,
after evaluation of <b>a</b> and <b>b</b>. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.21">
11.21</a>&nbsp;&nbsp;Allocation</h2>
<a name="ClassCreation">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">NewExpression ::= <b>new</b> ClassName TypeArguments <b>(</b> ArgumentList <b>)</b>
        ClassBody </td></tr>
<tr><td align="right">&#124; <b>new</b> InterfaceName TypeArguments <b>(</b> ArgumentList <b>)</b>
        ClassBody
</td></tr></table>
</em>

<div class="p"><!----></div>
An allocation expression creates a new instance of a class and
invokes a constructor of the class.
The expression designates the class name and passes
type and value arguments to the constructor.

<div class="p"><!----></div>
The allocation expression may have an optional class body.
In this case, an anonymous subclass of the given class is
allocated.   An anonymous class allocation may also specify a
single super-interface rather than a superclass; the superclass
of the anonymous class is <b>x10.lang.Object</b>.

<div class="p"><!----></div>
If the class is anonymous-that is, if a class body is
provided-then the constructor is selected from the superclass.
The constructor to invoke is selected using the same rules as
for method invocation (&#167;).

<div class="p"><!----></div>
The type of an allocation expression
is the return type of the constructor invoked, with appropriate
substitutions  of actual arguments for formal parameters, as
specified in &#167;.

<div class="p"><!----></div>
It is illegal to allocate an instance of an <b>abstract</b> class.
It is illegal to allocate an instance of a class or to invoke a
constructor that is not visible at
the allocation expression.

<div class="p"><!----></div>
Note that instantiating a struct type uses function application syntax, not
<b>new</b>.  As structs do not have subclassing, there is no need or
possibility of a <em>ClassBody</em>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.22">
11.22</a>&nbsp;&nbsp;Casts</h2><a name="ClassCast">
</a><a name="classcast1122">
</a>

<div class="p"><!----></div>
The cast operation may be used to cast an expression to a given type:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">UnaryExpression ::= CastExpression </td></tr>
<tr><td align="right">CastExpression ::= UnaryExpression <b>as</b> Type </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The result of this operation is a value of the given type if the cast
is permissible at run time, and either a compile-time error or a runtime
exception 
(<b>x10.lang.TypeCastException</b>) if it is not.  

<div class="p"><!----></div>
When evaluating <b>E as T{c}</b>, first the value of <b>E</b> is converted to
type <b>T</b> (which may fail), and then the constraint <b>{c}</b> is checked. 

<div class="p"><!----></div>

<ul>
<li> If <b>T</b> is a primitive type, then <b>E</b>'s value is converted to type
      <b>T</b> according to the rules of
      &#167;.
<div class="p"><!----></div>
</li>

<li> If <b>T</b> is a class, then the first half of the cast succeeds if the
      run-time value of <b>E</b> is an instance of class <b>T</b>, or of a
      subclass
<div class="p"><!----></div>
</li>

<li> If <b>T</b> is an interface, then the first half of the cast succeeds if
      the run-time value of <b>E</b> is an instance of a class implementing
      <b>T</b>.
<div class="p"><!----></div>
</li>

<li> If <b>T</b> is a struct type, then the first half of the cast succeeds if
      the run-time value of <b>E</b> is an instance of <b>T</b>.
<div class="p"><!----></div>
</li>

<li> If <b>T</b> is a function type, then the first half of the cast succeeds
      if the run-time value of <b>X</b> is a function of precisely that type.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
If the first half of the cast succeeds, the second half - the constraint
<b>{c}</b> - must be checked.  In general this will be done at runtime, though
in special cases it can be checked at compile time.   For example, 
<b>n as Intself != w</b> succeeds if <b>n != w</b> - even if <b>w</b> is a value
read from input, and thus not determined at compile time.

<div class="p"><!----></div>
The compiler may forbid casts that it knows cannot possibly work. If there is
no way for the value of <b>E</b> to be of type <b>T{c}</b>, then 
<b>E as T{c}</b> can result in a static error, rather than a runtime error.  
For example, <b>1 as Int{self==2}</b> may fail to compile, because the compiler
knows that <b>1</b>, which has type <b>Int{self==1}</b>, cannot possibly be of
type <b>Int{self==2}</b>. 

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.23">
11.23</a>&nbsp;&nbsp;<b>instanceof</b></h2>
<a name="instanceOf">
</a>
<a name="\textbf{instanceof}1123">
</a>

<div class="p"><!----></div>
X10 permits types to be used in an in instanceof expression
to determine whether an object is an instance of the given type:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">RelationalExpression ::= RelationalExpression <b>instanceof</b> Type
</td></tr></table>
</em>

<div class="p"><!----></div>
In the above expression, <em>Type</em> is any type. At run time, the
result of this operator is <b>true</b> if the
<em>RelationalExpression</em> can be coerced to <em>Type</em>
without a <b>TypeCastException</b> being thrown or static error occurring.
Otherwise the result is <b>false</b>. This determination may involve checking
that the constraint, if any, associated with the type is true for the given
expression.

<div class="p"><!----></div>
For example, <b>3 instanceof Int{self==x}</b> is an overly-complicated way of
saying <b>3==x</b>.

<div class="p"><!----></div>
However, it is a static error if <b>e</b> cannot possibly be an instance of
<b>C{c}</b>; the compiler will reject <b>1 instanceof Int{self == 2}</b> because
<b>1</b> can never satisfy <b>Int{self == 2}</b>. Similarly, <b>1 instanceof
String</b> is a static error, rather than an expression always returning false. 

<div class="p"><!----></div>
<em><em>Limitation</em> 
X10 does not currently handle <b>instanceof</b> of generics in the way you
might expect.  For example, <b>r instanceof ValRail[Int{self != 0}]</b> does
not test that every element of <b>r</b> is non-zero.
</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.24">
11.24</a>&nbsp;&nbsp;Subtyping expressions</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">SubtypingExpression ::= Expression <b>&lt;:</b> Expression </td></tr>
<tr><td align="right">&#124; Expression <b>:&#62;</b> Expression </td></tr>
<tr><td align="right">&#124; Expression <b>==</b> Expression </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The subtyping expression  evaluates to <b>true</b>
"T<sub>1</sub>" is a subtype of "T<sub>2</sub>".

<div class="p"><!----></div>
The expression  evaluates to <b>true</b>
"T<sub>2</sub>" is a subtype of "T<sub>1</sub>".

<div class="p"><!----></div>
The expression "T<sub>1</sub> == T<sub>2</sub>"
evaluates to  <b>true</b>  is a subtype of  and
if "T<sub>2</sub>" is a subtype of "T<sub>1</sub>".

<div class="p"><!----></div>
Subtyping expressions are particularly useful in giving constraints on generic
types.  <b>x10.util.Ordered[T]</b> is an interface whose values can be compared
with values of type <b>T</b>. 
In particular, <b>T &lt;: x10.util.Ordered[T]</b> is
true if values of type <b>T</b> can be compared to other values of type
<b>T</b>.  So, if we wish to define a generic class <b>OrderedList[T]</b>, of
lists whose elements are kept in the right order, we need the elements to be
ordered.  This is phrased as a constraint on <b>T</b>: 
<pre>
class OrderedList[T]{T &lt;: x10.util.Ordered[T]} {
  // ...
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.25">
11.25</a>&nbsp;&nbsp;Contains expressions</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">ContainsExpression ::= Expression <b>in</b> Expression </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
The expression <b>p in r</b> tests if a value <b>p</b> is in a collection
<b>r</b>; it evaluates to <b>r.contains(p)</b>.
The collection <b>r</b>
must be of type <b>Collection[T]</b> and the value <b>p</b> must
be of type <b>T</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.26">
11.26</a>&nbsp;&nbsp;Array Constructors</h2>

<div class="p"><!----></div>
X10 includes short syntactic forms for constructing one-dimensional arrays.
The shortest form is to enclose some expressions in brackets: 
<pre>
val ints &lt;: Array[Int](1) = [1,3,7,21];
</pre>

<div class="p"><!----></div>
The expression <b>[e1,e2,e3, ..., en]</b> produces an <b>n</b>-element
<b>Array[T](1)</b>, where <b>T</b> is the least common supertype of the <b>
  base types</b> of the expressions <b>ei</b>. For example, the type of
<b>[0,1,2]</b> is <b>Array[Int](1)</b>.    

<div class="p"><!----></div>
More importantly, the type of 
<b>[0]</b> is also <b>Array[Int](1)</b>.  It is <em>not</em> 
<b>Array[Int{self==0}](1)</b>, even though all the elements are all 
of type <b>Int{self==0}</b>.  This is subtle but important. There are many
functions that take <b>Array[Int](1)</b>s, such as conversions to <b>Point</b>.
These functions do <em>not</em> take
<b>Array[Int{self==0}]</b>'s.<a href="#tthFtNtABG" name="tthFrefABG"><sup>16</sup></a>
Since there are far more uses for <b>Array[Int](1)</b> than
<b>Array[Int{self==0}](1)</b>, the compiler produces the former.

<div class="p"><!----></div>
Still, occasionally one does actually need <b>Array[Int{self==0}](1)</b>, 
or, say, <b>Array[Eel{self != null}](1)</b>, an array of non-null <b>Eel</b>s.  
For these cases, X10 provides an array constructor which does allow
specification of the element type: <b>new Array[T][e1...en]</b>.  Each
element <b>ei</b> must be of type <b>T</b>.  The resulting array is of type
<b>Array[T](1)</b>.  
<pre>
val zero &lt;: Array[Int{self == 0}](1) = new Array[Int{self == 0}][0];
val non1 &lt;: Array[Int{self != 1}](1) = new Array[Int{self != 1}][0];
val eels &lt;: Array[Eel{self != null}](1) = 
    new Array[Eel{self != null}][ new Eel() ];
</pre>

<div class="p"><!----></div>
<pre>
</pre>
<pre>
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc11.27">
11.27</a>&nbsp;&nbsp;Coercions and conversions</h2>
<a name="XtenConversions">
</a>
<a name="User-definedCoercions">
</a>
<a name="conversions1127">
</a><a name="coercions1127">
</a>

<div class="p"><!----></div>
X10 v2.1 supports the following coercions and conversions.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.27.1">
11.27.1</a>&nbsp;&nbsp;Coercions</h3>

<div class="p"><!----></div>
A <em>coercion</em> does not change object identity; a coerced object may
be explicitly coerced back to its original type through a cast. A <em>
  conversion</em> may change object identity if the type being converted
to is not the same as the type converted from. X10 permits
user-defined conversions (&#167;).

<div class="p"><!----></div>

<b>Subsumption coercion.&nbsp;&nbsp;</b>
A subtype may be implicitly coerced to any supertype.
<a name="coercions+subsumption coercion1127">
</a>

<div class="p"><!----></div>

<b>Explicit coercion (casting with <b>as</b>)&nbsp;&nbsp;</b>
An object of any class may be explicitly coerced to any other
class type using the <b>as</b> operation.  If <b>Child &lt;: Person</b> and
<b>rhys:Child</b>, then 
<pre>
  rhys as Person
</pre>
is an expression of type <b>Person</b>.  

<div class="p"><!----></div>
If the value coerced is not an instance of the target type,
a <b>ClassCastException</b> is thrown.  Casting to a constrained
type may require a run-time check that the constraint is
satisfied.
<a name="coercions+explicit coercion1127">
</a>
<a name="casting1127">
</a>
<a name="\textbf{as}1127">
</a>

<div class="p"><!----></div>
<em><em>Limitation</em> It is currently a static error, rather than the specified
<b>ClassCastException</b>, when the cast is statically determinable to be
impossible.</em>

<div class="p"><!----></div>

<b>Effects of explicit numeric coercion&nbsp;&nbsp;</b>
<a name="sec:effects-of-explicit-numeric-coercions">
</a>

<div class="p"><!----></div>
Coercing a number of one type to another type gives the best approximation of
the number in the result type, or a suitable disaster value if no
approximation is good enough.  

<div class="p"><!----></div>

<ul>
<li> Casting a number to a <em>wider</em> numeric type is safe and effective,
      and can be done by an implicit conversion as well as an explicit
      coercion.  For example, <b>4 as Long</b> produces the <b>Long</b> value of
      4.
<div class="p"><!----></div>
</li>

<li> Casting a floating-point value to an integer value truncates the digits
      after the decimal point, thereby rounding the number towards zero.  
      <b>54.321 as Int</b> is <b>54</b>, and 
      <b>-54.321 as Int</b> is <b>-54</b>.
      If the floating-point value is too large to represent as that kind of
      integer, the coercion returns the largest or smallest value of that type
      instead: <b>1e110 as Int</b> is 
      <b>Int.MAX_VALUE</b>, <b>2147483647</b>.
<div class="p"><!----></div>
</li>

<li> Casting a <b>Double</b> to a <b>Float</b> normally truncates digits: 
      <b>0.12345678901234567890 as Float</b> is <b>0.12345679f</b>.  This can
      turn a nonzero <b>Double</b> into <b>0.0f</b>, the zero of type
      <b>Float</b>: 
      <b>1e-100 as Float</b> is <b>0.0f</b>.  Since 
      <b>Double</b>s can be as large as about <b>1.79E308</b> and <b>Float</b>s
      can only be as large as about <b>3.4E38f</b>, a large <b>Double</b> will
      be converted to the special <b>Float</b> value of <b>Infinity</b>: 
      <b>1e100 as Float</b> is <b>Infinity</b>.
<div class="p"><!----></div>
</li>

<li> Integers are coerced to smaller integer types by truncating the
      high-order bits. If the value of the large integer fits into the smaller
      integer's range, this gives the same number in the smaller type: 
      <b>12 as Byte</b> is the <b>Byte</b>-sized 12, 
      <b>-12 as Byte</b> is -12. 
      However, if the larger integer <em>doesn't</em> fit in the smaller type,
      the numeric value and even the sign can change: <b>254 as Byte</b> is
      <b>Byte</b>-sized <b>-2</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.27.2">
11.27.2</a>&nbsp;&nbsp;Conversions</h3>

<div class="p"><!----></div>

<b>Widening numeric conversion.&nbsp;&nbsp;</b>
A numeric type may be implicitly converted to a wider numeric type. In
particular, an implicit conversion may be performed between a numeric
type and a type to its right, below:

<div class="p"><!----></div>
<pre>
Byte &lt; Short &lt; Int &lt; Long &lt; Float &lt; Double
</pre>

<div class="p"><!----></div>
<a name="conversions+widening conversions1127">
</a><a name="conversions+numeric conversions1127">
</a>
<b>String conversion.&nbsp;&nbsp;</b>
Any object that is an operand of the binary
<b>+</b> operator may
be converted to <b>String</b> if the other operand is a <b>String</b>.
A conversion to <b>String</b> is performed by invoking the <b>toString()</b>
method of the object.

<div class="p"><!----></div>
<a name="conversions+string conversion1127">
</a>
<b>User defined conversions.&nbsp;&nbsp;</b><a name="sec:user-defined-conversions">
</a>
<a name="conversions+user defined1127">
</a>

<div class="p"><!----></div>
The user may define conversion operators from type <b>A</b> <em>to</em> a
container type <b>B</b> by specifying a method on <b>B</b> as follows:

<div class="p"><!----></div>
<pre>
  public static operator (r: A): T = ... 
</pre>

<div class="p"><!----></div>
The return type <b>T</b> should be a subtype of <b>B</b>. The return
type need not be specified explicitly; it will be computed in the
usual fashion if it is not. However, it is good practice for the
programmer to specify the return type for such operators explicitly.

<div class="p"><!----></div>
For instance, the code for <b>x10.lang.Point</b> contains:

<div class="p"><!----></div>
<pre>
  public static global safe operator (r: Rail[int])
     : Point(r.length) = make(r);
</pre>

<div class="p"><!----></div>
The compiler looks for such operators on the container type <b>B</b>
when it encounters an expression of the form <b>r as B</b> (where
<b>r</b> is of type <b>A</b>). If it finds such a method, it sets the
type of the expression <b>r as B</b> to be the return type of the
method. Thus the type of <b>r as B</b> is guaranteed to be some subtype
of <b>B</b>.

<div class="p"><!----></div>
Consider the following code:  

<div class="p"><!----></div>
<pre>
<pre>
val p  = [2, 2, 2, 2, 2] as Point;
val q = [1, 1, 1, 1, 1] as Point;
val a = p - q;    
</pre>
This code fragment compiles successfully, given the above operator definition. 
The type of <b>p</b> is inferred to be <b>Point(5)</b> (i.e. the type 
<b>Point{self.rank==5}</b>.
Similarly for <b>q</b>. Hence the application of the operator "<b>-</b>" is legal (it requires both arguments to have the same rank). The type of <b>a</b> is computed as <b>Point(5)</b>.

	



<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp12">
Chapter 12 </a><br />Statements</h1><a name="XtenStatements">
</a><a name="statements120">
</a>

<div class="p"><!----></div>
This chapter describes the statements in the sequential core of
X10.  Statements involving concurrency and distribution
are described in &#167;.

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;Empty statement</h2>

<div class="p"><!----></div>
The empty statement <b>;</b> does nothing.  It is useful when a
loop header is evaluated for its side effects.  For example,
the following code sums the elements of a rail.

<div class="p"><!----></div>
<pre>
var sum: Int = 0;
for (var i: Int = 0; i &lt; a.length; i++, sum += a(i))
    ;
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;Local variable declaration</h2>

<div class="p"><!----></div>
Short-lived variables are introduced by local variables declarations, as
described in &#167;<a href="#VariableDeclarations">5</a>. Local variables may be declared only
within a block statement (&#167;). The scope of a local variable
declaration is the statement itself and the subsequent statements in the
block.
<pre>
  if (a &#62; 1) {
     val b = a/2;
     var c : Int = 0;
     // b and c are defined here
  }
  // b and c are not defined here.
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.3">
12.3</a>&nbsp;&nbsp;Block statement</h2>
<a name="Blocks">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= BlockStatement </td></tr>
<tr><td align="right">BlockStatement ::= <b> Statement <b></b></b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A block statement consists of a sequence of statements delimited by
"<b>" and "<b></b></b>". When a block is evaluated, the statements inside
of it are evaluated in order.  Blocks are useful for putting several
statements in a place where X10 asks for a single one, such as the consequent
of an <b>if</b>, and for limiting the scope of local variables.
<pre>
if (b) {
  // This is a block
  val v = 1;
  S1(v); 
  S2(v);
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.4">
12.4</a>&nbsp;&nbsp;Expression statement</h2>

<div class="p"><!----></div>
The expression statement evaluates an expression.  The value of the expression
is not used.
Side effects of the expression occur.  
<pre>
class StmtEx {
  def this() { x10.io.Console.OUT.println("New StmtEx made");  }
  static def call() { x10.io.Console.OUT.println("call!");  }
  def example() {
     var a : Int = 0;
     a = 1; // assignment
     new StmtEx(); // allocation
     call(); // call
  }
}
</pre>
Note that only selected forms of expression can appear in expression
statements.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.5">
12.5</a>&nbsp;&nbsp;Labeled statement</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= LabeledStatement </td></tr>
<tr><td align="right">LabeledStatement ::= Identifier <b>:</b> LoopStatement </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Loop statements (<b>for</b>, <b>while</b>, <b>do</b>, <b>ateach</b>,
<b>foreach</b>) may be labeled. The label may be used as the target of a break
or continue statement. The scope of a label is the statement labeled.
<pre>
lbl : for ([i] in 1..10) {
   for ([j] in i..10) {  
      if (a(i,j) == 0) break lbl;
      if (a(i,j) == 1) continue lbl;
      do_things_to(a(i,j)); 
   }
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.6">
12.6</a>&nbsp;&nbsp;Break statement</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= BreakStatement </td></tr>
<tr><td align="right">BreakStatement ::= <b>break</b> Identifier </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
An unlabeled break statement exits the currently enclosing loop or switch
statement. An labeled break statement exits the enclosing loop or switch
statement with the given label.
It is illegal to break out of a loop not defined in the current
method, constructor, initializer, or closure.  

<div class="p"><!----></div>
The following code searches for an element of a two-dimensional
array and breaks out of the loop when it is found:

<div class="p"><!----></div>
<pre>
var found: Boolean = false;
outer: for (var i: Int = 0; i &lt; a.length; i++)
    for (var j: Int = 0; j &lt; a(i).length; j++)
        if (a(i)(j) == v) {
            found = true;
            break outer;
        }
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.7">
12.7</a>&nbsp;&nbsp;Continue statement</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= ContinueStatement </td></tr>
<tr><td align="right">ContinueStatement ::= <b>continue</b> Identifier </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
An unlabeled <b>continue</b> skips the rest of the current iteration of the
innermost enclosing loop, and proceeds on to the next.  A labeled
<b>continue</b> does the same to the enclosing loop with that label.
It is illegal to continue a loop not defined in the current
method, constructor, initializer, or closure.

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.8">
12.8</a>&nbsp;&nbsp;If statement</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= IfThenStatement </td></tr>
<tr><td align="right">&#124; IfThenElseStatement </td></tr>
<tr><td align="right">IfThenStatement ::= <b>if</b> <b>(</b> Expression <b>)</b> Statement </td></tr>
<tr><td align="right">IfThenElseStatement ::= <b>if</b> <b>(</b> Expression <b>)</b> Statement <b>else</b> Statement </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
An if statement comes in two forms: with and without an else
clause.

<div class="p"><!----></div>
The if-then statement evaluates a condition expression, which must be of type
<b>Boolean</b>. If the condition is <b>true</b>, it evaluates the then-clause.
If the condition is <b>false</b>, the if-then statement completes normally.

<div class="p"><!----></div>
The if-then-else statement evaluates a condition expression and 
evaluates the then-clause if the condition is
<b>true</b>; otherwise, the <b>else</b>-clause is evaluated.

<div class="p"><!----></div>
As is traditional in languages derived from Algol, the if-statement is syntactically
ambiguous.  That is, 
<pre>
if (B1) if (B2) S1 else S2
</pre>
could be intended to mean either 
<pre>
if (B1) { if (B2) S1 else S2 }
</pre>
or 
<pre>
if (B1) {if (B2) S1} else S2
</pre>
X10, as is traditional, attaches an <b>else</b> clause to the most recent
<b>if</b> that doesn't have one.
This example is interpreted as 
<b>if (B1) { if (B2) S1 else S2 }</b>. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.9">
12.9</a>&nbsp;&nbsp;Switch statement</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= SwitchStatement </td></tr>
<tr><td align="right">SwitchStatement ::= <b>switch</b> <b>(</b> Expression <b>)</b> <b> Case <b></b></b> </td></tr>
<tr><td align="right">Case ::= <b>case</b> Expression <b>:</b> Statement </td></tr>
<tr><td align="right">&#124; <b>default</b> <b>:</b> Statement </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A switch statement evaluates an index expression and then branches to
a case whose value equal to the value of the index expression.
If no such case exists, the switch branches to the 
<b>default</b> case, if any.

<div class="p"><!----></div>
Statements in each case branch evaluated in sequence.  At the
end of the branch, normal control-flow falls through to the next case, if
any.  To prevent fall-through, a case branch may be exited using
a <b>break</b> statement.

<div class="p"><!----></div>
The index expression must be of type <b>Int</b>.
Case labels must be of type <b>Int</b>, <b>Byte</b>, <b>Short</b>, or <b>Char</b>
and must be compile-time 
constants.  Case labels cannot be duplicated within the
<b>switch</b> statement.

<div class="p"><!----></div>
In the following example, case <b>1</b> falls through to case3 <b>2</b>.  The
other cases are separated by <b>break</b>s.
<pre>
switch (i) {
  case 1: println(&#246;ne, and ");
  case 2: println("two"); 
          break;
  case 3: println("three");
          break;
  default: println("Something else");
           break;
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.10">
12.10</a>&nbsp;&nbsp;While statement</h2>
<a name="\textbf{while}1210">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= WhileStatement </td></tr>
<tr><td align="right">WhileStatement ::= <b>while</b> <b>(</b> Expression <b>)</b> Statement </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A while statement evaluates a <b>Boolean</b>-valued condition and executes a
loop body if <b>true</b>. If the loop body completes normally (either by
reaching the end or via a <b>continue</b> statement with the loop header as
target), the condition is reevaluated and the loop repeats if <b>true</b>. If
the condition is <b>false</b>, the loop exits.

<div class="p"><!----></div>
<pre>
  while (n &#62; 1) {
     n = (n % 2 == 1) ? 3*n+1 : n/2;
  }
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.11">
12.11</a>&nbsp;&nbsp;Do-while statement</h2>
<a name="\textbf{do}1211">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= DoWhileStatement </td></tr>
<tr><td align="right">DoWhileStatement ::= <b>do</b> Statement <b>while</b> <b>(</b> Expression <b>)</b> <b>;</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A do-while statement executes a loop body, and then evaluates a
<b>Boolean</b>-valued condition expression. If <b>true</b>, the loop repeats.
Otherwise, the loop exits.

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.12">
12.12</a>&nbsp;&nbsp;For statement</h2>
<a name="\textbf{for}1212">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= ForStatement </td></tr>
<tr><td align="right">&#124; EnhancedForStatement </td></tr>
<tr><td align="right">ForStatement ::= <b>for</b> <b>(</b>
        ForInit <b>;</b> Expression <b>;</b> ForUpdate
        <b>)</b> Statement </td></tr>
<tr><td align="right">ForInit ::=
        StatementExpression ( <b>,</b> StatementExpression )
        </td></tr>
<tr><td align="right">&#124; LocalVariableDeclaration </td></tr>
<tr><td align="right">ForUpdate ::=
        StatementExpression ( <b>,</b> StatementExpression )</td></tr>
<tr><td align="right">EnhancedForStatement ::= <b>for</b> <b>(</b>
        Formal <b>in</b> Expression 
        <b>)</b> Statement </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
<b>for</b> statements provide bounded iteration, such as looping over a list.
It has two forms: a basic form allowing near-arbitrary iteration, <em>a la</em>
C, and an enhanced form designed to iterate over a collection.

<div class="p"><!----></div>
A basic <b>for</b> statement provides for arbitrary iteration in a somewhat
more organized fashion than a <b>while</b>.  <b>for(init; test; step)body</b> is
equivalent to: 
<pre>
{
   init;
   while(test) {
      body;
      step;
   }
}
</pre>

<div class="p"><!----></div>
<b>init</b> is performed before the loop, and is traditionally used to declare
and/or initialize the loop variables. It may be a single variable binding
statement, such as <b>var i:Int = 0</b> or <b>var i:Int=0, j:Int=100</b>. (Note
that a single variable binding statement may bind multiple variables.)
Variables introduced by <b>init</b> may appear anywhere in the <b>for</b>
statement, but not outside of it.  Or, it may be a sequence of expression
statements, such as <b>i=0, j=100</b>, operating on already-defined variables.
If omitted, <b>init</b> does nothing.

<div class="p"><!----></div>
<b>test</b> is a Boolean-valued expression; an iteration of the loop will only
proceed if <b>test</b> is true at the beginning of the loop, after <b>init</b>
on the first iteration or or <b>step</b> on later ones. If omitted, <b>test</b>
defaults to <b>true</b>, giving a loop that will run until stopped by some
other means such as <b>break</b>, <b>return</b>, or <b>throw</b>.

<div class="p"><!----></div>
<b>step</b> is performed after the loop body, between one iteration and the
next. It traditionally updates the loop variables from one iteration to the
next: &lt;em&#62;e.g.&lt;/em&#62;, <b>i++</b> and <b>i++,j-</b>.  If omitted, <b>step</b> does nothing.

<div class="p"><!----></div>
<b>body</b> is a statement, often a code block, which is performed whenever
<b>test</b> is true.  If omitted, <b>body</b> does nothing.

<div class="p"><!----></div>
<a name="ForAllLoop">
</a>An enhanced for statement is used to iterate over a collection, or other
structure designed to support iteration by implementing the interface
<b>Iterable[T]</b>.    The loop variable must be of type <b>T</b>, 
or destructurable from a value of type <b>T</b>
(&#167;<a href="#exploded-syntax">5</a>; in practice, this means that 
<b>for ([i] in 1..10)</b> iterates over numbers from 1 to 10, while 
<b>for (i in 1..10</b> iterates over <b>Point</b>s from 1 to 10).
Each iteration of the loop
binds the iteration variable to another element of the collection.

<div class="p"><!----></div>
<pre>
  var sum : Int = 0;
  for ([i] in 1..n) sum += i;
</pre>

<div class="p"><!----></div>
Certain common variant cases are accepted.  If collection is of type
<b>Region</b>, the iteration variable may be of type <b>Point</b>. 
If the iteratable <b>e</b> is of type <b>Dist</b> or <b>Array</b>, it is treated
as if it were <b>e.region</b>.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.13">
12.13</a>&nbsp;&nbsp;Throw statement</h2>
<a name="throw1213">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= ThrowStatement </td></tr>
<tr><td align="right">ThrowStatement ::= <b>throw</b> Expression <b>;</b>
</td></tr></table>
</em>

<div class="p"><!----></div>
<a name="Exception1213">
</a>The <b>throw</b> statement throws an exception, which 
must be an instance of <b>x10.lang.Throwable</b>. 

<div class="p"><!----></div>
For example, the following code checks if an index is in range and
throws an exception if not.

<div class="p"><!----></div>
<pre>
if (i &lt; 0 </td><td width="150">
&#124;</td><td width="150">
&#124; i &#62;= x.length)
    throw new MyIndexOutOfBoundsException();
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.14">
12.14</a>&nbsp;&nbsp;Try-catch statement</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= TryStatement </td></tr>
<tr><td align="right">TryStatement ::= <b>try</b> BlockStatement Catch  </td></tr>
<tr><td align="right">&#124; <b>try</b> BlockStatement Catch Finally </td></tr>
<tr><td align="right">Catch ::= <b>catch</b> <b>(</b> Formal <b>)</b> BlockStatement </td></tr>
<tr><td align="right">Finally ::= <b>finally</b> BlockStatement </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Exceptions are handled with a <b>try</b> statement.
A <b>try</b> statement consists of a <b>try</b> block, zero or more
<b>catch</b> blocks, and an optional <b>finally</b> block.

<div class="p"><!----></div>
First, the <b>try</b> block is evaluated.  If the block throws an
exception, control transfers to the first matching <b>catch</b>
block, if any.  A <b>catch</b> matches if the value of the
exception thrown is a subclass of the <b>catch</b> block's formal
parameter type.

<div class="p"><!----></div>
The <b>finally</b> block, if present, is evaluated on all normal
and exceptional control-flow paths from the <b>try</b> block.
If the <b>try</b> block completes normally
or via a <b>return</b>, a <b>break</b>, or a
<b>continue</b> statement, 
the <b>finally</b>
block is evaluated, and then control resumes at
the statement following the <b>try</b> statement, at the branch target, or at
the caller as appropriate.
If the <b>try</b> block completes
exceptionally, the <b>finally</b> block is evaluated after the
matching <b>catch</b> block, if any, and then the
exception is rethrown.

<div class="p"><!----></div>
It is a static error to attempt to catch an exception type which is not
throwable by the block.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc12.15">
12.15</a>&nbsp;&nbsp;Return statement</h2>
<a name="ReturnStatement">
</a>
<a name="ReturnStatement1215">
</a>

  :
  |
  
  
  
  <em>
  
<table>

<tr><td align="right">Statement ::= ReturnStatement </td></tr>
<tr><td align="right">ReturnStatement ::= <b>return</b> Expression <b>;</b> </td></tr>
<tr><td align="right">&#124; <b>return</b> <b>;</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
Methods and closures may return values using a return statement.
If the method's return type is expliclty declared <b>Void</b>,
the method must return without a value; otherwise, it must return
a value of the appropriate type.

<div class="p"><!----></div>
	
<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp13">
Chapter 13 </a><br />Places</h1>
<a name="XtenPlaces">
</a>
<a name="places130">
</a>

<div class="p"><!----></div>
An X10 place is a repository for data and activities, corresponding
loosely to a process or a processor. Places induce a concept of "local". The
activities running in a place may access data items located at that place with
the efficiency of on-chip access. Accesses to remote places may take orders of
magnitude longer. X10's system of places is designed to make this obvious.
Programmers are aware of the places of their data, and know when they are
incurring communication costs, but the actual operation to do so is easy. It's
not hard to use non-local data; it's simply hard to to do so accidentally.

<div class="p"><!----></div>
The set of places available to a computation is determined at the time that
the program is started, and remains fixed through the run of the program. See
the <tt>README</tt> documentation on how to set command line and configuration
options to set the number of places.

<div class="p"><!----></div>
Places are first-class values in X10, as instances of the built-in struct,
<b>x10.lang.Place</b>.   <b>Place</b> provides a number of useful ways to
query places, such as <b>Place.places</b>, a <b>ValRail</b> of all the places
available to the current run of the program.

<div class="p"><!----></div>
Objects and structs (with one exception) are created in a single place - the
place that the constructor call was running in. They cannot change places.
They can be <em>copied</em> to other places, and the special library struct
<b>GlobalRef</b> allows values at one place to point to values at another.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc13.1">
13.1</a>&nbsp;&nbsp;The Structure of Places</h2>

<div class="p"><!----></div>
Places are numbered 0 through <b>Places.MAX_PLACES-1</b>, stored in the field
<b>pl.id</b>.  The <b>ValRail</b> <b>Place.places</b> contains the places of the
program, in numeric order. 
The program starts by executing a <b>main</b> method at
<b>Place.FIRST_PLACE</b>, which is <b>Place.places(0)</b>; see
&#167;. 

<div class="p"><!----></div>
Operations on places include <b>pl.next()</b>, which gives the next entry
(looping around) in <b>Place.places</b> and its opposite <b>pl.prev()</b>. In
particular, <b>here.next()</b> means &#228; place other than <b>here</b>", except
in single-place executions.
There are also a number of tests, like <b>pl.isSPE()</b> and 
<b>pl.isCUDA()</b>, which test for particular kinds of processors.

<div class="p"><!----></div>
Future versions of the language may permit user-definable
places, and the ability to dynamically create places.

<div class="p"><!----></div>
Place expressions <a name="place expression131">
</a> (, expressions of type
<b>Place</b>), such as <b>here</b> 
and <b>globRef.home</b>, are used in <b>at</b> and
<b>async</b> statements.  

<div class="p"><!----></div>
 <h2><a name="tth_sEc13.2">
13.2</a>&nbsp;&nbsp;<tt>here</tt></h2><a name="here132">
</a><a name="Here">
</a>

<div class="p"><!----></div>
The variable <b>here</b> is always bound to the place at which the current
computation is running, in the same way that <b>this</b> is always bound to the
instance of the current class (for non-static code), or <b>self</b> is bound to
the instance of the type currently being constrained.  
<b>here</b> may denote different places in the same method body, due to
place-shifting operations. In the following code, <b>here</b> has one value at
<b>h0</b>, and a different one at <b>h1</b>. 
<pre>
val h0 = here;
at (here.next()) {
  val h1 = here; 
  assert (h0 != h1);
}
</pre>

(Similar examples show that <b>self</b> and <b>this</b> have the same behavior:
<b>self</b> can be modified by constrained types appearing inside of type
constraints, and <b>this</b> by inner classes.)

<div class="p"><!----></div>
The following example looks through a list of references to <b>Thing</b>s.  
It finds those references to things that are <b>here</b>, and deals with them.  
<pre>
  public static def deal(things: List[GlobalRef[Thing]]) {
     for(gr in things) {
        if (gr.home == here) {
           val grHere = 
               gr as GlobalRef[Thing]{gr.home == here};
           val thing &lt;: Thing = grHere();
           dealWith(thing);
        }
     }
  }
</pre>

<div class="p"><!----></div>
	
<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp14">
Chapter 14 </a><br />Activities</h1><a name="XtenActivities">
</a>

<div class="p"><!----></div>
An <em>activity</em> is a statement being executed, independently, with its own
local variables; it may be thought of as a very light-weight thread. An
X10 computation may have many concurrent <em>activities</em> executing at any
give time.  All X10 code runs as part of an activity; when an X10 program is
started, the <b>main</b> method is invoked in an activity, called the <em>root
activity</em>.<a name="root
activity140">
</a>

<div class="p"><!----></div>
Activities coordinate their execution by various control and data structures.
For example, `
<b>when(x==0);</b> blocks the current activity until some other activity
sets <b>x</b> to zero.  However, activities determine the places at which they
may be blocked and resumed, by <b>when</b> and similar constructs.  There are
no means by which one activity can arbitrarily interrupt, block, or resume
another, no method  <b>activity.interrupt()</b>.

<div class="p"><!----></div>
An activity may be <em>running</em>, <em>blocked</em> on some condition or <em>
terminated</em>. If it is terminated, it is terminated in the same way that its
statement is: in particular, if the statement terminates abruptly, the
activity terminates abruptly for the same reason.
(&#167;).

<div class="p"><!----></div>
Activities can be long-running entities with a good deal of local state.  In
particular they can involve recursive method calls (and therefore have runtime
stacks).  However, activities can also be short-running light-weight entities,
&lt;em&#62;e.g.&lt;/em&#62;, it is reasonable to have an activity that simply increments a variable.

<div class="p"><!----></div>
An activity may asynchronously and in parallel launch activities at
other places.  Every activity except the initial <b>main</b> activity is spawned
by another.  Thus, at any instant, the activities in a program form a tree.

<div class="p"><!----></div>
X10 uses this tree in crucial ways.  
First is the distinction 
between <em>local</em> termination and <em>global</em>
termination of a statement. The execution of a statement by an
activity is said to terminate locally when the activity has finished
all its computation. (For instance the
creation of an asynchronous activity terminates locally when the
activity has been created.)  It is said to terminate globally when it
has terminated locally and all activities that it may have spawned at
any place have, recursively, terminated globally.
For example, consider: 
<pre>
async {s1();}
async {s2();}
</pre>
The primary activity spawns two child activities and then terminates locally,
very quickly.  The child activities may take arbitrary amounts of time to
terminate (and may spawn grandchildren).  When <b>s1()</b>, <b>s2()</b>, and
all their descendants terminate locally, then the primary activity terminates
globally. 

<div class="p"><!----></div>
The program as a whole terminates when the root activity terminates globally.
In particular, X10 does not permit the creation of 
daemon threads-threads that outlive the lifetime of the root
activity.  We say that an X10 computation is <em>rooted</em>
(&#167;).

<div class="p"><!----></div>
<em>
<b>Future Extensions.&nbsp;&nbsp;</b> We may permit the initial activity to be a daemon activity
to permit reactive computations, such as webservers, that may not
terminate.</em>

<div class="p"><!----></div>
 <h2><a name="tth_sEc14.1">
14.1</a>&nbsp;&nbsp;The X10 rooted exception model</h2>
<a name="ExceptionModel">
</a>
<a name="Exception+model141">
</a>

<div class="p"><!----></div>
The rooted nature of X10 computations permits the definition of a
<em>rooted exception model.</em> In multi-threaded programming languages
there is a natural parent-child relationship between a thread and a
thread that it spawns. Typically the parent thread continues execution
in parallel with the child thread. Therefore the parent thread cannot
serve to catch any exceptions thrown by the child thread. 

<div class="p"><!----></div>
The presence of a root activity and the concept of global termination permits
X10 to adopt a more powerful exception model. In any state of the
computation, say that an activity A is <em>a root of</em> an activity B if
A is an ancestor of B and A is blocked at a statement (such as the
<b>finish</b> statement &#167;) awaiting the termination of B (and
possibly other activities). For every X10 computation, the <em>root-of</em>
relation is guaranteed to be a tree. The root of the tree is the root activity
of the entire computation. If A is the nearest root of B, the path from
A to B is called the <em>activation path</em> for the activity.<a href="#tthFtNtABH" name="tthFrefABH"><sup>17</sup></a>

<div class="p"><!----></div>
We may now state the exception model for X10.  An uncaught exception
propagates up the activation path to its nearest root activity, where
it may be handled locally or propagated up the <em>root-of</em> tree when
the activity terminates (based on the semantics of the statement being
executed by the activity).<a href="#tthFtNtABI" name="tthFrefABI"><sup>18</sup></a>  In Java, exceptions may be overlooked because there is no good
place to put a <b>try</b>-<b>catch</b> block; this is never the case in X10.

<div class="p"><!----></div>
 <h2><a name="tth_sEc14.2">
14.2</a>&nbsp;&nbsp; <tt>at</tt>: Place Changing and Object Copying</h2><a name="AtStatement">
</a>
<a name="at142">
</a>

<div class="p"><!----></div>
An activity may change place using the <b>at</b> statement or
<b>at</b> expression:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= AtStatement </td></tr>
<tr><td align="right">AtStatement ::= <b>at</b> PlaceExpressionSingleList Statement </td></tr>
<tr><td align="right">Expression ::= AtExpression </td></tr>
<tr><td align="right">AtExpression ::= <b>at</b> PlaceExpressionSingleList ClosureBody 
</td></tr></table>
</em>

<div class="p"><!----></div>
The statement <b>at (p) S</b> executes the statement <b>S</b>
synchronously at a place described by <b>p</b>.
The expression <b>at (p) E</b> executes the statement <b>E</b>
synchronously at place <b>p</b>, returning the result to the
originating place.  

<div class="p"><!----></div>
<b>p</b> may be an expression of type <b>Place</b>, in which case its value is
used as the place to execute the body: 
<pre>
   at (here.next()) S();
</pre>


<div class="p"><!----></div>
<b>at(p)S</b> does <em>not</em> start a new activity.  It should be thought of as
transporting the current activity to <b>p</b>, running <b>S</b> there, and then
transporting it back.    If you want to start a new activity, use <b>async</b>;
if you want to start a new activity at <b>p</b>, use 
<b>at(p) async S</b>.  

<div class="p"><!----></div>
As a consequence of this, <b>S</b> may contain constructs which only make sense
within a single activity.  
For example, 
<pre>
    for(x in globalRefsToThings) 
      if (at(x.home) x().nice()) 
        return x();
</pre>
returns the first nice thing in a collection.   If we had used 
<b>async at(x.home)</b>, this would not be allowed; 
you can't <b>return</b> from an
<b>async</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc14.2.1">
14.2.1</a>&nbsp;&nbsp;Implicit copying from <tt>at</tt> </h3>
<a name="at+copying142">
</a>

<div class="p"><!----></div>
<b>at(p)S</b> copies nearly all data that <b>S</b> might reference, and sends it
to place <b>p</b>, before executing <b>S</b> there. The only things that are not
copied are values only reachable through <b>GlobalRef</b>s.    If <b>x</b> is a
variable name referring to some object <b>ob</b> outside of <b>S</b>, then the
same variable name <b>x</b> refers to a deep copy <b>ob&#8242;</b> of <b>ob</b>
inside of <b>S</b>.  In this way the body <b>S</b> is in a separate block with
different variable bindings.

<div class="p"><!----></div>
For example, consider the following program.
<pre>
val c = new Cell[Int](5); // (1)
at (here) {               // (2)
   assert(c() == 5);      // (3)
   c.set(8);              // (4)
   assert(c() == 8);      // (5)
}
assert(c() == 5);         // (6)
</pre>
The <b>at</b> statement implicitly copies the <b>Cell</b> and its contents.  
After <b>(1)</b>, <b>c</b> is a <b>Cell</b> containing 5; call that cell c<sub>1</sub>
At <b>(2)</b>, that cell is copied, resulting in another cell c<sub>2</sub> whose
contents are also 5, as tested at <b>(3)</b>.
(Note that the copying behavior of <b>at</b> happens <em>even when the
destination place is the same as the starting place</em>- even with
<b>at(here)</b>.)
At <b>(4)</b>, the contents of c<sub>2</sub> are changed to 8, as confirmed at <b>(5)</b>; the contents of
c<sub>1</sub> are of course untouched.    Finally, at <b>(c)</b>, outside the scope
of the <b>at</b> started at line <b>(2)</b>, <b>c</b> refers to its original
value c<sub>1</sub> rather than the copy c<sub>2</sub>.  

<div class="p"><!----></div>
The <b>at</b> statement induces a <em>deep copy</em>.  Not only does it copy the
values of variables, it copies values that they refer to through zero or more
levels of reference.  Structures are preserved as well: if two fields
<b>x.f</b> and <b>x.g</b> refer to the same object o<sub>1</sub> in the original, then
<b>x.f</b> and <b>x.g</b> will both refer to the same object o<sub>2</sub> in the
copy.  

<div class="p"><!----></div>
For example, in the following variation of the preceding example,
<b>a</b>'s original value a<sub>1</sub> is an array with two references to the same
<b>Cell[Int]</b> c<sub>1</sub>.  The fact that a<sub>1</sub>(0) and a<sub>1</sub>(1) are both
identical to c<sub>1</sub> is demonstrated in <b>(A)</b>-<b>(C)</b>, as a<sub>1</sub>(0) is modified
and a<sub>1</sub>(1) is observed to change.  In <b>(D)</b>-<b>(F)</b>, the copy
a<sub>2</sub> is tested in the same way, showing that a<sub>2</sub>(0) and a<sub>2</sub>(1) both
refer to the same <b>Cell[Int]</b> c<sub>2</sub>.  However, the test at <b>(G)</b>
shows that c<sub>2</sub> is a different cell from c<sub>1</sub>, because changes to
c<sub>2</sub> did not propagate to c<sub>1</sub>.  
<pre>
val c = new Cell[Int](5);
val a = new Array[Cell[Int]][c,c];
assert(a(0)() == 5 &amp;&amp; a(1)() == 5);     // (A)
c.set(6);                               // (B)
assert(a(0)() == 6 &amp;&amp; a(1)() == 6);     // (C)
at(here) {
  assert(a(0)() == 6 &amp;&amp; a(1)() == 6);   // (D)
  c.set(7);                             // (E)
  assert(a(0)() == 7 &amp;&amp; a(1)() == 7);   // (F)
}
assert(a(0)() == 6 &amp;&amp; a(1)() == 6);     // (G)
</pre>

<div class="p"><!----></div>

<h4>Copying and GlobalRef</h4>
<a name="at+GlobalRef142">
</a>
<a name="at+blocking copying142">
</a>

<div class="p"><!----></div>
The single barrier to the potentially copious copying behavior of <b>at</b>
is the <b>GlobalRef</b> struct.  A <b>GlobalRef[T]</b> contains a reference to
a value of type <b>T</b>, in a form which can be transmitted, and a <b>Place</b>
<b>gr.home</b> indicating where the value lives.
The <b>GlobalRef</b> itself is copied across
<b>at</b> boundaries-but the value referred to is <em>not</em>
copied.<a href="#tthFtNtABJ" name="tthFrefABJ"><sup>19</sup></a> 

<div class="p"><!----></div>
The following example does not copy the value <b>huge</b>.  However, <b>huge</b>
would have been copied if it had been put into a <b>Cell</b>, or simply used
directly. 
<pre>
val huge = &#196; potentially big thing";
val href = GlobalRef(huge);
at (here) {
   use(href);
  }
}
</pre>

<div class="p"><!----></div>
Values protected in <b>GlobalRef</b>s can be retrieved by the <b>gr.apply()</b>
method, often abbreviated simply <b>gr()</b>.  <b>gr.apply()</b> is guarded; it can
only be called when <b>gr.home == here</b>.  If you  want to do anything other
than pass a global reference around or compare two of them for equality, you
need to placeshift back to the home place of the reference, often with
<b>at(gr.home)</b>.   For example, the following (silly) program modifies the
command-line argument array.

<div class="p"><!----></div>
<pre>
  public static def main(argv: Array[String](1)) {
    val argref = GlobalRef[Array[String](1)](argv);
    at(here.next()) use(argref);
  }
  static def use(argref : GlobalRef[Array[String](1)]) {
    at(argref.home) {
      val argv = argref();
      argv(0) = "Hi!";
    }
  }
</pre>

<div class="p"><!----></div>

<h4>Warnings about <b>at</b></h4>
There are two dangers involved with <b>at</b>: 

<ul>
<li> Careless use of <b>at</b> can result in copying and transmission
of very large data structures.
<div class="p"><!----></div>
</li>

<li> As seen in the examples above, changes made to copied objects are not
      propagated back to the originals.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
 <h2><a name="tth_sEc14.3">
14.3</a>&nbsp;&nbsp;<b>async</b>: Spawning an activity</h2><a name="AsynchronousActivity">
</a><a name="AsyncActivity">
</a>

<div class="p"><!----></div>
Asynchronous activities serve as a single abstraction for supporting a
wide range of concurrency constructs such as message passing, threads,
DMA, streaming, data prefetching. (In general, asynchronous operations
are better suited for supporting scalability than synchronous
operations.)

<div class="p"><!----></div>
An activity is created by executing the <b>async</b> statement: 

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= AsyncStatement </td></tr>
<tr><td align="right">AsyncStatement ::= <b>async</b>  Statement </td></tr>
<tr><td align="right">PlaceExpressionSingleList ::= <b>(</b> PlaceExpression <b>)</b> </td></tr>
<tr><td align="right">PlaceExpression ::= Expression 
</td></tr></table>
</em> 

<div class="p"><!----></div>
The basic form of <b>async</b> is <b>async S</b>, which starts a new activity
located <b>here</b> executing <b>S</b>.   

<div class="p"><!----></div>
In many cases the compiler may infer the unique place at which the
statement is to be executed by an analysis of the types of the
variables occurring in the statement. (The place must be such that the
statement can be executed safely, without generating a
<b>BadPlaceException</b>.) In such cases the programmer may omit the
place designator; the compiler will throw an error if it cannot
determine the unique designated place.<a href="#tthFtNtACA" name="tthFrefACA"><sup>20</sup></a>

<div class="p"><!----></div>
An activity A executes the statement <b>async (P) S</b> by launching
a new activity B at place <b>P</b> (or <b>P.home</b> if <b>P</b> is of an
object type), to execute <b>S</b>. The statement terminates locally as soon as B is
launched.  The activation path for B is that of A augmented by the
information that A is the parent of B. 
B
terminates normally when S terminates normally.  It terminates
abruptly if S throws an uncaught exception. The exception is
propagated to A if A is a root activity (see &#167;),
otherwise it is propagated through A to A's root activity. Note that while
A is running, exceptions thrown by activities it has already
spawned may propagate through it up to its root activity, without A noticing.

<div class="p"><!----></div>
Multiple activities launched by a single activity at another place are not
ordered in any way. They are added to the set of activities at the target
place and will be executed based on the local scheduler's decisions.
If some particular sequencing of events is needed, <b>when</b>, <b>atomic</b>,
<b>finish</b>, clocks, and other X10 constructs can be used.
X10 implementations are not required to have fair schedulers,
though every implementation should make a best faith effort to ensure
that every activity eventually gets a chance to make forward progress.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
The statement in the body of an <b>async</b> is subject to the
restriction that it must be acceptable as the body of a <b>void</b>
method for an anonymous inner class declared at that point in the code,
which throws no checked exceptions. As such, it may reference
variables in lexically enclosing scopes (including <b>clock</b>
variables, &#167;) provided that such variables are
(implicitly or explicitly) <b>val</b>.


<div class="p"><!----></div>
 <h2><a name="tth_sEc14.4">
14.4</a>&nbsp;&nbsp;Finish</h2><a name="finish144">
</a><a name="finish">
</a>
The statement <b>finish S</b> converts global termination to local
termination and introduces a root activity.   It executes <b>S</b>, and then
waits for all activities spawned by <b>S</b>, directly or indirectly, to
finish. It also collects exceptions thrown by those activities.

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= FinishStatement </td></tr>
<tr><td align="right">FinishStatement ::= <b>finish</b> Statement 
</td></tr></table>
</em>

<div class="p"><!----></div>
An activity A executes <b>finish S</b> by executing <b>S</b>.  The
execution of <b>S</b> may spawn other asynchronous activities (here or
at other places).  Uncaught exceptions thrown or propagated by any
activity spawned by <b>S</b> are accumulated at <b>finish S</b>.
<b>finish S</b> terminates locally when all activities spawned by
<b>S</b> terminate globally (either abruptly or normally). If <b>S</b>
terminates normally, then <b>finish S</b> terminates normally and A
continues execution with the next statement after <b>finish S</b>.  If
<b>S</b> terminates abruptly, then <b>finish S</b> terminates abruptly
and throws a single exception, <b>x10.lang.MultipleExceptions</b>
formed from the collection of exceptions accumulated at <b>finish S</b>.

<div class="p"><!----></div>
Thus a <b>finish S</b> statement serves as a collection point for
uncaught exceptions generated during the execution of <b>S</b>.

<div class="p"><!----></div>
Note that repeatedly <b>finish</b>ing a statement has little effect after
the first <b>finish</b>: <b>finish finish S</b> is indistinguishable
from <b>finish S</b> if <b>S</b> throws no exceptions.  (If <b>S</b> throws
exceptions, <b>finish S</b> wraps them in one layer of 
<b>MultipleExceptions</b> and <b>finish finish S</b> in two layers.)

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc14.5">
14.5</a>&nbsp;&nbsp;Initial activity</h2><a name="initial-computation">
</a><a name="initial activity145">
</a>

<div class="p"><!----></div>
An X10 computation is initiated from the command line on the
presentation of a classname <b>C</b>. The class must have a
<b>public static def main(a: Rail[String]):Void</b> method, otherwise an
exception is thrown
and the computation terminates.  The single statement
<pre>
finish async (Place.FIRST_PLACE) {
  C.main(s);
}
</pre>
 is executed where <b>s</b> is an Rail of strings created
from the command line arguments. This single activity is the root activity
for the entire computation. (See &#167; for a discussion of
places.)

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc14.6">
14.6</a>&nbsp;&nbsp;Ateach statements</h2><a name="\textbf{ateach}146">
</a><a name="ateach-section">
</a>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= AtEachStatement </td></tr>
<tr><td align="right">AtEachStatement ::=
      <b>ateach</b> <b>(</b> Formal <b>in</b> Expression <b>)</b>
         Statement </td></tr>
<tr><td align="right">AtEachStatement ::=
      <b>ateach</b> <b>(</b> Expression <b>)</b>
         Statement 
</td></tr></table>
</em>

<div class="p"><!----></div>
The <b>ateach</b> statement <b>ateach (p in D) S</b>
spawns an activity <b>S</b> at each place <b>p</b> of a distribution <b>D</b>. 
In <b>ateach(p in D) S</b>, 
<b>D</b> must be either of type <b>Dist</b> 
(see &#167;)
or of type
<b>DistArray[T]</b> (see &#167;), 
and <b>p</b> will be of type <b>Point</b> (see &#167;).

<div class="p"><!----></div>
<b>ateach(p in D)S</b> is equivalent to 
<b>for(p in D) at(D(p)) async S</b>.  That is, the elements of <b>D</b> are all
points <b>p</b>.  <b>D(p)</b> is a <b>Place</b>.  <b>ateach(p in D)S</b> executes
the body <b>S</b> at the place <b>D(p)</b> (and may use the point <b>p</b>
there). 

<div class="p"><!----></div>
However, the compiler may implement it more efficiently to avoid extraneous
communications.  In particular, it is recommended that <b>ateach(p in D)S</b>
be implemented as the following code, which coordinates with each place of
<b>D</b> just once, rather than once per element of <b>D</b> at that place: 

<div class="p"><!----></div>
<pre>
for (p in D.places()) async at (p) {
    for (pt in D</td><td width="150">
&#124;here) async {
        S(pt);
    }
}
</pre>

<div class="p"><!----></div>
If <b>e</b> is an <b>DistArray[T]</b>, then <b>ateach (p in e)S</b> is identical to
<b>ateach(p in e.dist)S</b>; the iteration is over the array's underlying
distribution.   
The code below is a common and generally efficient way to work with the
elements of a distributed array:
<pre>
ateach(p in A) 
  dealWith(A(p));
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc14.7">
14.7</a>&nbsp;&nbsp;At expressions</h2>

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Expression ::= <b>at</b> <b>(</b> Expression <b>)</b> Expression
</td></tr></table>
</em>

<div class="p"><!----></div>
An <b>at</b> expression evaluates an expression synchronously at the
given place and returns its value.  For instance a copy of the
value pointed to by a <b>GlobalRef</b> may be obtained using
the <b>fetch</b> method:
<pre>
  def fetch(g:GlobalRef[T]):T = at (g) g();
</pre>

<div class="p"><!----></div>
The expression evaluation may spawn asynchronous activities. The <b>at</b>
expression will return without waiting for those activities to terminate. That
is, <b>at</b> does not have built-in <b>finish</b> semantics.

<div class="p"><!----></div>
 <h2><a name="tth_sEc14.8">
14.8</a>&nbsp;&nbsp;Atomic blocks</h2><a name="AtomicBlocks">
</a><a name="atomic blocks148">
</a>
Languages such as Java use low-level synchronization locks to allow
multiple interacting threads to coordinate the mutation of shared
data. X10 eschews locks in favor of a very simple high-level
construct, the <em>atomic block</em>.

<div class="p"><!----></div>
A programmer may use atomic blocks to guarantee that invariants of
shared data-structures are maintained even as they are being accessed
simultaneously by multiple activities running in the same place.  

<div class="p"><!----></div>
For example, consider a class <b>Redund[T]</b>, which encapsulates a list
<b>list</b> and, (redundantly) keeps the size of the list in a second field
<b>size</b>.  Then <b>r:Redund[T]</b> has the invariant 
<b>r.list.size() == r.size</b>, which must be true at any point that there are
no method calls on <b>r</b> active.

<div class="p"><!----></div>
If the <b>add</b> method on <b>Redund</b> (which adds an element to the list) 
were defined as: 
<pre>
def add(x:T) { // Incorrect
  this.list.add(x);
  this.size = this.size + 1;
}
</pre>
Then two activities simultaneously adding elements to the same <b>r</b> could break the
invariant.  Suppose that <b>r</b> starts out empty.  Let the first activity
perform the <b>list.add</b>, and compute <b>this.size+1</b>, which is 1, but not store it
back into <b>this.size</b> yet.  
(At this point, <b>r.list.size()==1</b> and <b>r.size==0</b>; the invariant
expression is false, but, as the first call to <b>r.add()</b> is active, the
invariant does not need to be true - it only needs to be true when the
call finishes.)
Now, let the second activity do its call to
<b>add</b> to completion, which finishes with <b>r.size==1</b>.  
(As before, the invariant expression is false, but a call to <b>r.add()</b> is
still active, so the invariant need not be true.)
Finally, let
the first activity finish, which assigns the <b>1</b> computed before back into
<b>this.size</b>.  At the end, there are two elements in <b>r.list</b>, but
<b>r.size==1</b>. Since there are no calls to <b>r.add()</b> active, the
invariant must be true, but it is not.

<div class="p"><!----></div>
In this case, the invariant can be maintained by making the increment atomic.
Doing so forbids that sequence of events; the <b>atomic</b> block cannot be
stopped partway.  
<pre>
def add(x:T) { 
  this.list.add(x);
  atomic { this.size = this.size + 1; }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc14.8.1">
14.8.1</a>&nbsp;&nbsp;Unconditional atomic blocks</h3>
The simplest form of an atomic block is the <em>unconditional
atomic block</em>:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::= AtomicStatement </td></tr>
<tr><td align="right">AtomicStatement ::= <b>atomic</b>  Statement </td></tr>
<tr><td align="right">MethodModifier ::= <b>atomic</b> </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>

<div class="p"><!----></div>
Such a statement is executed by an activity as if in a single step
during which all other concurrent activities in the same place are
blocked. If execution of the statement may throw an exception, it is
the programmer's responsibility to wrap the atomic block within a
<b>try</b>/<b>finally</b> clause and include undo code in the finally
clause. Thus the <b>atomic</b> statement only guarantees atomicity on
successful execution, not on a faulty execution.

<div class="p"><!----></div>
We allow methods of an object to be annotated with <b>atomic</b>. Such
a method is taken to stand for a method whose body is wrapped within an
<b>atomic</b> statement.

<div class="p"><!----></div>
Atomic blocks are closely related to non-blocking synchronization
constructs [], and can be used to implement 
non-blocking concurrent algorithms.

<div class="p"><!----></div>
In <b>atomic S</b>, <b>S</b> may include calls to <b>safe</b> methods, and use of
sequential control structures.

<div class="p"><!----></div>
It may <em>not</em> include an <b>async</b> activity (such as creation
of a <b>future</b>).

<div class="p"><!----></div>
It may <em>not</em> include any statement that may potentially block at
runtime (&lt;em&#62;e.g.&lt;/em&#62;, <b>when</b>, <b>force</b> operations, <b>next</b>
operations on clocks, <b>finish</b>). 

<div class="p"><!----></div>
It may <em>not</em> include any <b>at</b> expressions or
statements. (Hence all locations accessed in the atomic block must
belong to the current place.)

<div class="p"><!----></div>
The compiler checks for this condition by checking whether the statement
could be the body of a <b>void</b> method annotated with <b>safe</b> at
that point in the code (&#167;).

<div class="p"><!----></div>

<b>Consequences.&nbsp;&nbsp;</b>
Note an important property of an (unconditional) atomic block:

<div class="p"><!----></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table><tr><td nowrap="nowrap" align="right" colspan="1"> <b><b>atomic</b> {<b>s</b><b>1</b><b>;</b> <b>atomic</b> <b>s</b><b>2</b>}</b> &amp;=&amp; <b><b>atomic</b> {<b>s</b><b>1</b><b>;</b> <b>s</b><b>2</b>}</b></td></tr></table></td><td width="50%"></td><td width="1" align="right">(14.1)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Atomic blocks do not introduce deadlocks.    They may exhibit all the bad
behavior of sequential programs, including throwing exceptions and running
forever, but they are guaranteed not to deadlock.

<div class="p"><!----></div>

<h4>Example</h4>

<div class="p"><!----></div>
The following class method implements a (generic) compare and swap (CAS) operation:

<div class="p"><!----></div>
<pre>
var target:Object = null;
public atomic def CAS(old1: Object, new1: Object): Boolean {
   if (target.equals(old1)) {
     target = new1;
     return true;
   }
   return false;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc14.8.2">
14.8.2</a>&nbsp;&nbsp;Conditional atomic blocks</h3>

<div class="p"><!----></div>
Conditional atomic blocks allow the activity to wait for some condition to be
satisfied before executing an atomic block. For example, consider a
<b>Redund</b> class holding a list <b>r.list</b> and, redundantly, its length
<b>r.size</b>.  A <b>pop</b> operation will delay until the <b>Redund</b> is
nonempty, and then remove an element and update the length.  
<pre>
def pop():T {
  var ret : T;
  when(size&#62;0) {
    ret = list.removeAt(0);
    size -;
    }
  return ret;
}
</pre>

<div class="p"><!----></div>
The execution of the test is atomic with the execution of the block.  This is
important; it means that no other activity can sneak in and make the condition
be false before the block is executed.  In this example, two <b>pop</b>s
executing on a list with one element would work properly. Without the
conditional atomic block - even doing the decrement atomically - one call to
<b>pop</b> could pass the <b>size&#62;0</b> guard; then the other call could run to
completion (removing the only element of the list); then, when the first call
proceeds, its <b>removeAt</b> will fail.  

<div class="p"><!----></div>
Note that <b>if</b> would not work here.  
<b>if(size&#62;0) atomic{size--; return list.removeAt(0);}</b> allows another
activity to act between the test and the atomic block.  
And 
<b>atomic{ if(size&#62;0) {size--; ret = list.removeAt(0);}}</b> 
does not wait for <b>size&#62;0</b> to become true.

<div class="p"><!----></div>
Conditional atomic blocks are of the form:

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Statement ::=  WhenStatement </td></tr>
<tr><td align="right">WhenStatement ::=  <b>when</b> <b>(</b> Expression <b>)</b> Statement </td></tr>
<tr><td align="right">&#124; WhenStatement <b>or</b> <b>(</b> Expression <b>)</b> Statement 
</td></tr></table>
</em>

<div class="p"><!----></div>
In such a statement the one or more expressions are called <em>
guards</em> and must be <b>Boolean</b> expressions. The statements are the
corresponding <em>guarded statements</em>.  

<div class="p"><!----></div>
An activity executing such a statement suspends until such time as any
one of the guards is true in the current state. In that state, the
statement corresponding to the first guard that is true is executed.
The checking of the guards and the execution of the corresponding
guarded statement is done atomically. 

<div class="p"><!----></div>
X10 does not guarantee that a conditional atomic block
will execute if its condition holds only intermittently. For, based on
the vagaries of the scheduler, the precise instant at which a
condition holds may be missed. Therefore the programmer is advised to
ensure that conditions being tested by conditional atomic blocks are
eventually stable, , they will continue to hold until the block
executes (the action in the body of the block may cause the condition
to not hold any more).

<div class="p"><!----></div>

<div class="p"><!----></div>
 Rationale:
The guarantee provided by <b>wait</b>/<b>notify</b> in Java is no
stronger. Indeed conditional atomic blocks may be thought of as a
replacement for Java's wait/notify functionality.
 

<div class="p"><!----></div>
The statement <b>when (true) S</b> is
behaviorally identical to <b>atomic S</b>: it never suspends.

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font>:
For the sake of efficient implementation certain restrictions are
placed on the guards and statements in a conditional atomic
block. 


<div class="p"><!----></div>
Guards are statically required not to have side-effects, not to spawn
asynchronous activities (as for the <b>sequential</b> qualifier on methods) and
to have a statically determinable upper bound on their execution (as for the
<b>nonblocking</b> qualifier on methods).

<div class="p"><!----></div>
The body of a <b>when</b> statement must satisfy the conditions
for the body of an <b>atomic</b> block.

<div class="p"><!----></div>
Note that this implies that guarded statements are required to be <em>
flat</em>, that is, they may not contain conditional atomic blocks. (The
implementation of nested conditional atomic blocks may require
sophisticated operational techniques such as rollbacks.)

<div class="p"><!----></div>
The following class shows how to implement a bounded buffer of size
1 in X10 for repeated communication between a sender and a
receiver.  The call <b>buf.send(ob)</b> waits until the buffer has space, and
then puts <b>ob</b> into it.  Dually, <b>buf.receive()</b> waits until the
buffer has something in it, and then returns that thing.

<div class="p"><!----></div>
<pre>
class OneBuffer[T] {
  var datum: T;
  def this(t:T) { this.datum = t; this.filled = true; }
  var filled: Boolean;
  public def send(v: T) {
    when (!filled) {
      this.datum = v;
      this.filled = true;
    }
  }
  public def receive(): T {
    when (filled) {
      v: T = datum;
      filled = false;
      return v;
    }
  }
}
</pre>


<div class="p"><!----></div>
	
<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp15">
Chapter 15 </a><br />Clocks</h1><a name="XtenClocks">
</a><a name="clocks150">
</a>

<div class="p"><!----></div>
Many concurrent algorithms proceed in phases: in phase k, several
activities work independently, but synchronize together before proceeding on
to phase k+1. X10 supports this communication structure (and many
variations on it) with a generalization of barriers 
called <em>clocks</em>. Clocks are designed so that programs which follow a
simple syntactic discipline will not have either deadlocks or race conditions.

<div class="p"><!----></div>
The following minimalist example of clocked code has two worker activities A
and B, and three phases. In the first phase, each worker activity says its
name followed by 1; in the second phase, by a 2, and in the third, by a 3.  
So, if <b>say</b> prints its argument, 
<b>A-1 B-1 A-2 B-2 B-3 A-3</b>
would be a legitimate run of the program, but
<b>A-1 A-2 B-1 B-2 A-3 B-3</b>
(with <b>A-2</b> before <b>B-1</b>) would not.

<div class="p"><!----></div>
The program creates a clock <b>cl</b> to manage the phases.  Each participating
activity does
the work of its first phase, and then executes <b>next;</b> to signal that it
is finished with that work. <b>next;</b> is blocking, and causes the participant to
wait until all participant have finished with the phase - as measured by the
clock <b>cl</b> to which they are both registered.  
Then they do the second phase, and another <b>next;</b> to make sure that
neither proceeds to the third phase until both are ready.  This example uses
<b>finish</b> to wait for both particiants to finish.  The parent thread is also
registered on the clock just as the particiants are, and executes <b>next;next;</b>
to run through the phases.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
    finish async{
      val cl = Clock.make();
      async clocked(cl) {// Activity A
        say(&#196;-1");
        next;
        say(&#196;-2");
        next;
        say(&#196;-3"); 
      }// Activity A

<div class="p"><!----></div>
      async clocked(cl) {// Activity B
        say("B-1");
        next;
        say("B-2");
        next;
        say("B-3"); 
      }// Activity B
    }
</pre>

<div class="p"><!----></div>
This chapter describes the syntax and semantics of clocks and
statements in the language that have parameters of type <b>Clock</b>. 

<div class="p"><!----></div>
The key invariants associated with clocks are as follows.  At any
stage of the computation, a clock has zero or more <em>registered</em>
activities. An activity may perform operations only on those clocks it
is registered with (these clocks constitute its <em>clock set</em>). 
An attempt by an activity to operate on a clock it is not registered with
will cause a 
<b>ClockUseException</b><a name="clock+ClockUseException150">
</a>. 
to be thrown.  
An activity is registered with zero or more clocks when it is created.
During its lifetime the only additional clocks it is registered with
are exactly those that it creates. In particular it is not possible
for an activity to register itself with a clock it discovers by
reading a data structure.

<div class="p"><!----></div>
The primary operations that an activity <b>a</b> may perform on a clock <b>c</b>
that it is registered upon are: 

<ul>
<li> It may spawn and simultaneously  <em>register</em> a new activity on
      <b>c</b>, with the statement       <b>async clocked(c){S}</b>.
<div class="p"><!----></div>
</li>

<li> It may <em>unregister</em> itself from <b>c</b>, with <b>c.drop()</b>.  After
      doing so, it can no longer use most primary operations on <b>c</b>.
<div class="p"><!----></div>
</li>

<li> It may <em>resume</em> the clock, with <b>c.resume()</b>, indicating that it
      has finished with the current phase associated with <b>c</b> and is ready
      to move on to the next one.
<div class="p"><!----></div>
</li>

<li> It may <em>wait</em> on the clock, with <b>c.next()</b>.  This first does
      <b>c.resume()</b>, and then blocks the current activity until the start
      of the next phase, , until all other activities registered on that
      clock have called <b>c.resume()</b>.
<div class="p"><!----></div>
</li>

<li> It may <em>block</em> on all the clocks it is registered with
      simultaneously, by the command <b>next;</b>.  This, in effect, calls
      <b>c.next()</b> simultaneously 
      on all clocks <b>c</b> that the current activity is registered with.
<div class="p"><!----></div>
</li>

<li> Other miscellaneous operations are available as well; see the
      <b>Clock</b> API.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc15.1">
15.1</a>&nbsp;&nbsp;Clock operations</h2><a name="sec:clock">
</a>
There are two language constructs for working with clocks. 
<b>async clocked(cl) S</b> starts a new activity registered on one or more
clocks.  <b>next;</b> blocks the current activity until all the activities
sharing clocks with it are ready to proceed to the next clock phase. 
Clocks are objects, and have a number of useful methods on them as well.

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.1.1">
15.1.1</a>&nbsp;&nbsp;Creating new clocks</h3><a name="clock+creation151">
</a><a name="sec:clock:create">
</a>

<div class="p"><!----></div>
Clocks are created using a factory method on <b>x10.lang.Clock</b>:

<div class="p"><!----></div>
<pre>
val c: Clock = Clock.make();
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The current activity is automatically registered with the newly
created clock.  It may deregister using the <b>drop</b> method on
clocks (see the documentation of <b>x10.lang.Clock</b>). All activities
are automatically deregistered from all clocks they are registered
with on termination (normal or abrupt).

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.1.2">
15.1.2</a>&nbsp;&nbsp;Registering new activities on clocks</h3>
<a name="clock+clocked statements151">
</a><a name="sec:clock:register">
</a>

<div class="p"><!----></div>
The statement 

<div class="p"><!----></div>
<pre>
  async clocked (c1, c2, c3) S
</pre>
starts a new activity, initially registered with
clocks <b>c1</b>, <b>c2</b>, and <b>c3</b>, and  running <b>S</b>. The activity running this code must
be registered on those clocks. 
Violations of these conditions are punished by the throwing of a
<b>ClockUseException</b><a name="clock+ClockUseException151">
</a>. 

<div class="p"><!----></div>

<div class="p"><!----></div>
If an activity &#945; that has executed <b>c.resume()</b> then starts a
new activity &#946; also registered on <b>c</b> (, via <b>async
clocked(c) S</b>), the new activity &#946; starts out having also resumed
<b>c</b>, as if it too had executed <b>c.resume()</b>.  
<pre>
//alpha
val c = Clock.make();
c.resume();
async clocked(c) {
  // beta;
  c.next();
  beta_phase_two();
}
c.next();
alpha_phase_two();
</pre>
In the proper execution, &#945; and &#946; both perform
<b>c.next()</b> and then their phase-2 actions.  
However, if &#946; were not
initially in the resume state for <b>c</b>, there would be a race condition;
&#946; could perform <b>c.next()</b> and proceed to <b>beta_phase_two</b>
before &#945; performed <b>c.next()</b>.

<div class="p"><!----></div>
An activity may check that it is registered on a clock <b>c</b> by
the predicate <b>c.registered()</b>

<div class="p"><!----></div>
 Note:
X10 does not contain a "register" operation that would allow an activity
to discover a clock in a datastructure and register itself on it. Therefore,
while a clock <b>c</b> may be stored in a data structure by one activity
<b>a</b> and read from it by another activity <b>b</b>, <b>b</b> cannot do much
with <b>c</b> unless it is already registered with it.  In particular, it
cannot register itself on <b>c</b>, and, lacking that registration, cannot
register a sub-activity on it with <b>async clocked(c) S</b>.


<div class="p"><!----></div>
     <h3><a name="tth_sEc15.1.3">
15.1.3</a>&nbsp;&nbsp;Resuming clocks</h3><a name="clock+resume151">
</a><a name="resume">
</a><a name="sec:clock:resume">
</a>
X10 permits <em>split phase</em> clocks. An activity may wish
to indicate that it has completed whatever work it wishes to perform
in the current phase of a  clock <b>c</b> it is registered with, without
suspending altogether. It may do so  by executing 
<b>c.resume()</b>.

<div class="p"><!----></div>
An activity may invoke <b>resume()</b> only on a clock it is registered with,
and has not yet dropped (&#167;). A
<b>ClockUseException</b><a name="clock+ClockUseException151">
</a> is thrown if this
condition is violated. Nothing happens if the activity has already invoked a
<b>resume</b> on this clock in the current phase.

<div class="p"><!----></div>

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.1.4">
15.1.4</a>&nbsp;&nbsp;Advancing clocks</h3><a name="clock+next151">
</a><a name="sec:clock:next">
</a>
An activity may execute the statement
<pre>
next;
</pre>

<div class="p"><!----></div>
 Execution of this statement blocks until all the clocks that the
activity is registered with (if any) have advanced. (The activity
implicitly issues a <b>resume</b> on all clocks it is registered
with before suspending.)

<div class="p"><!----></div>
<b>next;</b> may be thought of as calling <b>c.next()</b> in parallel for all
clocks that the current activity is registered with.  (The parallelism is
conceptually important: if activities &#945; and &#946; are both
registered on clocks <b>c</b> and <b>d</b>, and &#945; executes
<b>c.wait(); d.wait()</b> while &#946; executes <b>d.wait(); c.wait()</b>,
then the two will deadlock.  However, if the two clocks are waited on in
parallel, as <b>next;</b> does, &#945; and &#946; will not deadlock.)

<div class="p"><!----></div>
Equivalently, <b>next;</b> sequentially calls <b>c.resume()</b> for each
registered clock <b>c</b>, in arbitrary order, and then <b>c.wait()</b> for each
clock, again in arbitrary order.  Implementations are more likely to use this 

<div class="p"><!----></div>

<div class="p"><!----></div>
An activity blocked on <b>next</b> resumes execution once
it is marked for progress by all the clocks it is registered with.

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.1.5">
15.1.5</a>&nbsp;&nbsp;Dropping clocks</h3><a name="clock+drop151">
</a><a name="sec:clock:drop">
</a>
An activity may drop a clock by executing <b>c.drop()</b>.

<div class="p"><!----></div>
 The activity is no longer considered registered with this
clock.  A <b>ClockUseException</b> is thrown if the activity has
already dropped <b>c</b>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc15.2">
15.2</a>&nbsp;&nbsp;Deadlock Freedom</h2>

<div class="p"><!----></div>
In general, programs using clocks can deadlock, just as programs using loops
can fail to terminate.  However, programs written with a particular syntactic
discipline <em>are</em> guaranteed to be deadlock-free, just as programs which
use only bounded loops are guaranteed to terminate.  The syntactic discipline
is: 

<ul>
<li> The <b>next()</b> <b>method</b> may not be called on any clock. (The
      <b>next;</b> statement is allowed.)
<div class="p"><!----></div>
</li>

<li> Inside of <b>finishS</b>, all clocked <b>async</b>s must be in the scope
      an unclocked <b>async</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The second clause prevents the following deadlock.  
<pre>
val c:Clock = Clock.make();
async clocked(c) {                // (A) 
      finish async clocked(c) {   // (B) Violates clause 2
            next;                 // (Bnext)
      }
      next;                       // (Anext)
}
</pre>
<b>(A)</b>, first of all, waits for the <b>finish</b> containing <b>(B)</b> to
finish.  
<b>(B)</b> will execute its <b>next</b> at <b>(Bnext)</b>, and then wait for all
other activities registered on <b>c</b> to execute their <b>next</b>s.
However, <b>(A)</b> is registered on <b>c</b>.  So, <b>(B)</b> cannot finish
until <b>(A)</b> has proceeded to <b>(Anext)</b>, and <b>(A)</b> cannot proceed
until <b>(B)</b> finishes. Thus, this causes deadlock.

<div class="p"><!----></div>
 <h2><a name="tth_sEc15.3">
15.3</a>&nbsp;&nbsp;Program equivalences</h2>
From the discussion above it should be clear that the following
equivalences hold:

<div class="p"><!----></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 <b><b>c</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b> <b>next</b><b>;</b></b> &amp;=&amp; <b><b>next</b><b>;</b></b></td></tr></table></td><td width="50%"></td><td width="1" align="right">(15.1)</td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 <b><b>c</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b> <b>d</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b></b> &amp;=&amp; <b><b>d</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b> <b>c</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b></b></td></tr></table></td><td width="50%"></td><td width="1" align="right">(15.2)</td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table><tr><td nowrap="nowrap" align="right" colspan="1"> <b><b>c</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b> <b>c</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b></b> &amp;=&amp; <b><b>c</b><b>.</b><b>resume</b><b>(</b><b>)</b><b>;</b></b></td></tr></table></td><td width="50%"></td><td width="1" align="right">(15.3)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Note that <b>next; next;</b> is not the same as <b>next;</b>. The
first will wait for clocks to advance twice, and the second
once.  

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc15.4">
15.4</a>&nbsp;&nbsp;Clocked Finish</h2>
<a name="finish+clocked154">
</a>
<a name="clocked+finish154">
</a>
<a name="ClockedFinish">
</a>

<div class="p"><!----></div>
In the most common case of a single clock coordinating a few behaviors, X10
allows coding with an implicit clock.  <b>finish</b> and <b>async</b> statements
may be qualified with <b>clocked</b>.  

<div class="p"><!----></div>
A <b>clocked finish</b> introduces a new clock.  It executes its body in the
usual way that a <b>finish</b> does- except that, when its body completes,
the activity executing the <b>clocked finish</b> drops the clock, while it
waits for asynchronous spawned <b>async</b>s to terminate.  

<div class="p"><!----></div>
A <b>clocked async</b> registers its async with the implicit clock of
the surrounding <b>clocked finish</b>.   

<div class="p"><!----></div>
Both the <b>clocked finish</b> and <b>clocked async</b> may use the <b>next</b>
statement to advance implicit clock.  Since the implicit clock is not
available in a variable, it cannot be manipulated directly. (If you want to
manipulate the clock directly, use an explicit clock.)

<div class="p"><!----></div>
The following code starts two activities, each of which perform their first
phase, wait for the other to finish phase 1, and then perform their second
phase.  
<pre>
clocked finish {
  clocked async {
     phase(&#196;", 1);
     next;
     phase(&#196;", 2);
  }
  clocked async {
     phase("B", 1);
     next;
     phase("B", 2);
  }
}
</pre>

<div class="p"><!----></div>
<a name="finish+nested clocked154">
</a><a name="clocked finish+nested154">
</a>Clocked finishes may be nested.  The inner <b>clocked finish</b> operates in a
single phase of the outer one.  
	



<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp16">
Chapter 16 </a><br />Local and Distributed Arrays</h1><a name="XtenArrays">
</a><a name="arrays160">
</a>

<div class="p"><!----></div>
<b>Array</b>s provide indexed access to data at a single <b>Place</b>, <em>via</em>
<b>Point</b>s-indices of any dimensionality. <b>DistArray</b>s is similar, but
spreads the data across multiple <b>Place</b>s, <em>via</em> <b>Dist</b>s.  
We refer to arrays either sort as "general arrays".  

<div class="p"><!----></div>
This chapter provides an overview of the <b>x10.array</b> classes <b>Array</b>
and <b>DistArray</b>, and their supporting classes <b>Point</b>, <b>Region</b>
and <b>Dist</b>.  

<div class="p"><!----></div>
The array library has been under intensive development recently, and
much of the code examples in the language specification are
out-of-date.  We will update this section of the language specification
to match the final set of Array APIs in time for the 2.1.0 release of X10.

<div class="p"><!----></div>
 <h2><a name="tth_sEc16.1">
16.1</a>&nbsp;&nbsp;Points</h2><a name="point-syntax">
</a><a name="point syntax161">
</a>

<div class="p"><!----></div>
General arrays are indexed by <b>Point</b>s-nass="roman">-dimensional tuples of
integers.  The <b>rank</b>
property of a point gives its dimensionality.  Points can be constructed from
integers or <b>ValRail</b>s by
the <b>Point.make</b> factory methods:
<pre>
val origin_1 : Point{self.rank==1} = Point.make(0);
val origin_2 : Point{self.rank==2} = Point.make(0,0);
val origin_5 : Point{self.rank==5} = Point.make([0,0,0,0,0]);
</pre>

<div class="p"><!----></div>
There is an implicit conversion from <b>ValRail[Int]</b> to 
<b>Point</b>, giving
a convenient syntax for constructing points: 

<div class="p"><!----></div>
<pre>
val p : Point = [1,2,3];
val q : Point{rank==5} = [1,2,3,4,5];
val r : Point(3) = [11,22,33];
</pre>

<div class="p"><!----></div>
The coordinates of a point are available by subscripting; <b>p(i)</b> is the
<b>i</b>th coordinate of the point <b>p</b>. 
`Point(nass="roman">)` is a <b>type</b>-defined shorthand  for 
`Point{rank==nass="roman">}`.

<div class="p"><!----></div>
 <h2><a name="tth_sEc16.2">
16.2</a>&nbsp;&nbsp;Regions</h2><a name="XtenRegions">
</a><a name="region162">
</a>

<div class="p"><!----></div>
A region is a set of points of the same rank.  X10
provides a built-in class, <b>x10.lang.Region</b>, to allow the
creation of new regions and to perform operations on regions. 
Each region <b>R</b> has a property <b>R.rank</b>, giving the dimensionality of
all the points in it.

<div class="p"><!----></div>
<pre>
val MAX_HEIGHT=20;
val Null = Region.makeUnit();  // Empty 0-dimensional region
val R1 = 1..100; // 1-dim region with extent 1..100
val R2 = (1..100) as Region(1); // same as R1
val R3 = (0..99) * (-1..MAX_HEIGHT);
val R4 = Region.makeUpperTriangular(10);
val R6 = R4 &amp;&amp; R3; // intersection of two regions
</pre>

<div class="p"><!----></div>
The expression `m..n`, for integer expressions <b>m</b> and <b>n</b>,
evaluates to the rectangular, rank-1 region consisting of the points
{`[m]`, ..., `[n]`}. If `m` is greater than
`n`, the region <b>m..n</b> is empty.

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
<a name="region+upperTriangular162">
</a><a name="region+lowerTriangular162">
</a><a name="region+banded162">
</a>Various built-in regions are provided through  factory
methods on <b>Region</b>.  

<ul>
<li> <b>Region.makeEmpty(n)</b> returns an empty region of rank <b>n</b>.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeFull(n)</b> returns the region containing all points of
      rank <b>n</b>.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeUnit()</b> returns the region of rank 0 containing the
      unique point of rank 0.  It is useful as the identity for Cartesian
      product of regions.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeHalfspace(normal:Point, k:int)</b> returns the unbounded
      half-space of rank <b>normal.rank</b>, consisting of all points <b>p</b>
      satisfying `p&#183;normal  &#8804;  k`.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeRectangular(min, max)</b>, where <b>min</b> and <b>max</b>
      are <b>Int</b> rails or valrails of length <b>n</b>, returns a
      <b>Region(n)</b> equal to: 
      `[min(0) .. max(0), &#8230;, min(n-1)..max(n-1)]`.
<div class="p"><!----></div>
</li>

<li> <b>Region.make(regions)</b> constructs the Cartesian product of the
      <b>Region(1)</b>s in <b>regions</b>.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeBanded(size, upper, lower)</b> constructs the
      banded <b>Region(2)</b> of size <b>size</b>, with <b>upper</b> bands above
      and <b>lower</b> bands below the diagonal.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeBanded(size)</b> constructs the banded <b>Region(2)</b> with
      just the main diagonal.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeUpperTriangular(N)</b> returns a region corresponding
to the non-zero indices in an upper-triangular <b>N x N</b> matrix.
<div class="p"><!----></div>
</li>

<li> <b>Region.makeLowerTriangular(N)</b> returns a region corresponding
to the non-zero indices in a lower-triangular <b>N x N</b> matrix.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
All the points in a region are ordered canonically by the
lexicographic total order. Thus the points of the region <b>(1..2)*(1..2)</b>
are ordered as 
<pre>
(1,1), (1,2), (2,1), (2,2)
</pre>
Sequential iteration statements such as <b>for</b> (&#167;)
iterate over the points in a region in the canonical order.

<div class="p"><!----></div>
A region is said to be <em>rectangular</em><a name="region+convex162">
</a> if it is of
the form `(T<sub>1ass="roman"></sub> * &#8230; * T<sub>kass="roman"></sub>)` for some set of regions
`T<sub>iass="roman"></sub>`. Such a
region satisfies the property that if two points pass="roman"><sub>1ass="roman"></sub> and pass="roman"><sub>3ass="roman"></sub> are
in the region, then so is every point pass="roman"><sub>2ass="roman"></sub> between them (that is, it is <em>convex</em>). 
(Banded and triangular regions are not rectangular.)
The operation
<b>R.boundingBox()</b> gives the smallest rectangular region containing
<b>R</b>.)  

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.2.1">
16.2.1</a>&nbsp;&nbsp;Operations on regions</h3>

<div class="p"><!----></div>
Let <b>R</b> be a region. A <em>sub-region</em> is a subset of <b>R</b>.
<a name="region+sub-region162">
</a>

<div class="p"><!----></div>
Let `R1` and `R2` be two regions whose types establish that
they are of the same rank. Let `S` be another region; its rank is
irrelevant. 

<div class="p"><!----></div>
`R1 &amp;&amp; R2` is the intersection of `R1` and
`R2`, , the region containing all points which are in both
<b>R1</b> and <b>R2</b>.  <a name="region+intersection162">
</a>
For example, <b>1..10 &amp;&amp; 2..20</b> is <b>2..10</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
`R1 * S` is the Cartesian product of `R1` and
`S`,  formed by pairing each point in `R1` with every  point in `S`.
<a name="region+product162">
</a>
Thus, <b>(1..2)*(3..4)*(5..6)</b>
is the region of rank <b>3</b> containing the eight points with coordinates
<b>[1,3,5]</b>, <b>[1,3,6]</b>, <b>[1,4,5]</b>, <b>[1,4,6]</b>,
<b>[2,3,5]</b>, <b>[2,3,6]</b>, <b>[2,4,5]</b>, <b>[2,4,6]</b>.

<div class="p"><!----></div>
For a region `R` and point `p` of the same rank,
<b>R+p</b> 
and
<b>R-p</b> 
represent the translation of the region
forward 
and backward 
by `p`. That is, <b>R+p</b> is the set of points
<b>p+q</b> for all <b>q</b> in <b>R</b>, and <b>R-p</b> is the set of <b>q-p</b>.

<div class="p"><!----></div>
More <b>Region</b> methods are described in the API documentation.

<div class="p"><!----></div>
 <h2><a name="tth_sEc16.3">
16.3</a>&nbsp;&nbsp;Arrays</h2>

<div class="p"><!----></div>
Arrays are organized data, arranged so that it can be accessed by subscript.
An <b>Array[T]</b> <b>A</b> has a <b>Region</b> <b>A.region</b>, telling which
<b>Point</b>s are in <b>A</b>.  For each point <b>p</b> in <b>A.region</b>,
<b>A(p)</b> is the datum of type <b>T</b> associated with <b>p</b>.  X10
implementations should 
attempt to store <b>Array</b>s efficiently, and to make array element accesses
quick-, avoiding constructing <b>Point</b>s when unnecessary.

<div class="p"><!----></div>
This generalizes the concepts of arrays appearing in many other programming
languages.  A <b>Point</b> may have any number of coordinates, so an
<b>Array</b> can have, in effect, any number of integer subscripts.  

<div class="p"><!----></div>
Indeed, it is possible to write code that works on <b>Array</b>s regardless 
of dimension.  For example, to add one <b>Array[Int]</b> <b>src</b> into another
<b>dest</b>, 
<pre>
static def addInto(src: Array[Int], dest:Array[Int])
  {src.region == dest.region}
  = {
    for (p in src.region) 
       dest(p) += src(p);
  }
</pre>

Since <b>p</b> is a <b>Point</b>, it can hold as many coordinates as are
necessary for the arrays <b>src</b> and <b>dest</b>.

<div class="p"><!----></div>
The basic operation on arrays is subscripting: if <b>A</b> is an <b>Array[T]!</b>
and <b>p</b> a point with the same rank as <b>A.region</b>, then
<b>A(p)</b>
is the value of type <b>T</b> associated with point <b>p</b>.

<div class="p"><!----></div>
Array elements can be changed by assignment. If <b>t:T</b>, 
<pre>
A(p) = t;
</pre>
modifies the value associated with <b>p</b> to be {t}, and leaves all other
values in <b>A</b> unchanged.

<div class="p"><!----></div>
An <b>Array[T]</b> <b>A</b> has: 

<ul>
<li> <b>A.region</b>: the <b>Region</b> upon which <b>A</b> is defined.
<div class="p"><!----></div>
</li>

<li> <b>A.size</b>: the number of elements in <b>A</b>.
<div class="p"><!----></div>
</li>

<li> <b>A.rank</b>, the rank of the points usable to subscript <b>A</b>.
      Identical to <b>A.region.rank</b>.
<div class="p"><!----></div>
</li>

<li>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.3.1">
16.3.1</a>&nbsp;&nbsp;Array Constructors</h3>

<div class="p"><!----></div>
To construct an array whose elements all have the same value, call
<b>new Array[T](R, init)</b>, where <b>init:T</b> is the initial value. 
For example, an array of a thousand <b>&#246;h!"</b>s can be made by:
<b>new Array[String](1..1000, &#246;h!")</b>.

<div class="p"><!----></div>
To construct and initialize an array, call the two-argument constructor. 
<b>new Array[T](R, f)</b> constructs an array of elements of type <b>T</b> on
region <b>R</b>, with <b>A(p)</b> initialized to <b>f(p)</b> for each point
<b>p</b> in <b>R</b>.  <b>f</b> must be a function taking a point of rank
<b>R.rank</b> to a value of type <b>T</b>.  , to construct an array of a
hundred zero values, call
<b>new Array[Int](1..100, (Point(1))=&#62;0)</b>. 
To construct a multiplication table, call
<b>new Array[Int]((0..9)*(0..9), (p:Point(2)) =&#62; p(0)*p(1))</b>.

<div class="p"><!----></div>
Other constructors are available; see the API documentation.

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.3.2">
16.3.2</a>&nbsp;&nbsp;Array Operations</h3>

<div class="p"><!----></div>
The basic operation on <b>Array</b>s is subscripting.  If <b>A:Array[T]</b> and 
<b>p:Point{rank == A.rank}, then <b>a(p)</b> is the value of type <b>T</b>
appearing at position <b>p</b> in <b>A</b>.    The syntax is identical to
function application, and, indeed, arrays may be used as functions.
<b>A(p)</b> may be assigned to, as well, by the usual assignment syntax
<b>A(p)=t</b>.
(This uses the application and setting syntactic sugar, as given in &#167;<a href="#set-and-apply">8.6.5</a>.)

<div class="p"><!----></div>
Sometimes it is more convenient to subscript by integers.  Arrays of rank 1-4
can, in fact, be accessed by integers: 
<pre>
val A1 = new Array[Int](1..10, 0);
A1(4) = A1(4) + 1;
val A4 = new Array[Int]((1..2)*(1..3)*(1..4)*(1..5), 0);
A4(2,3,4,5) = A4(1,1,1,1)+1;
</pre>

<div class="p"><!----></div>
Iteration over an <b>Array</b> is defined, and produces the <b>Point</b>s of the
array's region.  If you want to use the values in the array, you have to
subscript it.  For example, you could double every element of an
<b>Array[Int]</b> by: 
<pre>
for (p in A) A(p) = 2*A(p);
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.3.3">
16.3.3</a>&nbsp;&nbsp;Higher-Order Array Operations</h3>

<div class="p"><!----></div>
X10 has powerful operations which operation on the entirety of an array. Most
of these take functions as an argument, explaining what to do to the array.

<div class="p"><!----></div>
<b>A.map(f)</b> applies the function <b>f</b> to all elements of <b>A</b>,
collecting the results into a new array.  For example, 
<pre>
val A = new Array[Int](1..10, (p:Point(1))=&#62;p(0) );
// A = 1,2,3,4,5,6,7,8,9,10
val cube = (i:Int) =&#62; i*i;
val B = A.map(cube);
// B = 1,8,27,64,216,343,512,729,1000
</pre>

<div class="p"><!----></div>
A variant operation lets you specify the array <b>B</b> into which the result
will be stored.   
<pre>
val A = new Array[Int](1..10, (p:Point(1))=&#62;p(0) );
// A = 1,2,3,4,5,6,7,8,9,10
val cube = (i:Int) =&#62; i*i;
val B = new Array[Int](A.region); // B = 0,0,0,0,0,0,0,0,0,0
A.map(B, cube);
// B = 1,8,27,64,216,343,512,729,1000
</pre>

This is convenient if you have an already-allocated array lying around unused.
In particular, it can be used if you don't need <b>A</b> afterwards and want to
reuse its space:
<pre>
val A = new Array[Int](1..10, (p:Point(1))=&#62;p(0) );
// A = 1,2,3,4,5,6,7,8,9,10
val cube = (i:Int) =&#62; i*i;
A.map(A, cube);
// A = 1,8,27,64,216,343,512,729,1000
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc16.4">
16.4</a>&nbsp;&nbsp;Distributions</h2><a name="XtenDistributions">
</a>
<a name="distribution164">
</a>

<div class="p"><!----></div>
A <em>distribution</em> is a mapping from a region to a set of places.
Distributions are embodied by the class <b>x10.lang.Dist</b>.
This class is <b>final</b> in
X10 v2.1; future versions of the language may permit
user-definable distributions. 
The <em>rank</em> of a distribution is the rank of the underlying region, and
thus the rank of every point that the distribution applies to.

<div class="p"><!----></div>
<pre>
val R  &lt;: Region = 1..100;
val D1 &lt;: Dist = Dist.makeBlock(R);
val D2 &lt;: Dist = R -&#62; here;
</pre>

<div class="p"><!----></div>
Let <b>D</b> be a distribution. 
<b>D.region</b> 
denotes the underlying
region. 
Given a point <b>p</b>, the expression
<b>D(p)</b> represents the application of <b>D</b> to <b>p</b>, that is,
the place that <b>p</b> is mapped to by <b>D</b>. The evaluation of the
expression <b>D(p)</b> throws an <b>ArrayIndexOutofBoundsException</b>
if <b>p</b> does not lie in the underlying region.

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.4.1">
16.4.1</a>&nbsp;&nbsp;Operations returning distributions</h3>

<div class="p"><!----></div>
Let <b>R</b> be a region, <b>Q</b> a Sequence of places {<b>p1</b>, ...,
<b>pk</b>} (enumerated in canonical order), and <b>P</b> a place.

<div class="p"><!----></div>

<b>Unique distribution&nbsp;&nbsp;</b> <a name="distribution+unique164">
</a>
The distribution <b>Dist.makeUnique(Q)</b> is the unique distribution from the
region <b>1..k</b> to <b>Q</b> mapping each point <b>i</b> to <b>pi</b>.

<div class="p"><!----></div>

<b>Constant distributions.&nbsp;&nbsp;</b> <a name="distribution+constant164">
</a>
The distribution <b>R-&#62;P</b> maps every point in region <b>R</b> to place <b>P</b>, as does
<b>Dist.makeConstant(R,P)</b>. 

<div class="p"><!----></div>

<b>Block distributions.&nbsp;&nbsp;</b><a name="distribution+block164">
</a>
The distribution <b>Dist.makeBlock(R)</b> distributes the elements of <b>R</b>,
in order, over all the places available to the program. 
Let pass="roman"> equal <b></td><td width="150">
&#124;R</td><td width="150">
&#124; div N</b> and qass="roman"> equal <b></td><td width="150">
&#124;R</td><td width="150">
&#124; mod N</b>,
where <b>N</b> is the size of <b>Q</b>, and 
<b></td><td width="150">
&#124;R</td><td width="150">
&#124;</b> is the size of <b>R</b>.  The first qass="roman"> places get
successive blocks of size (ass="roman">pass="roman">+ass="roman">1ass="roman">)ass="roman"> and the remaining places get blocks of
size pass="roman">.

<div class="p"><!----></div>
There are other <b>Dist.makeBlock</b> methods capable of controlling the
distribution and the set of places used; see the API documentation.

<div class="p"><!----></div>

<div class="p"><!----></div>
<b>Domain Restriction.&nbsp;&nbsp;</b> <a name="distribution+restriction+region164">
</a>

<div class="p"><!----></div>
If <b>D</b> is a distribution and <b>R</b> is a sub-region of <tt>
D.region</tt>, then <b>D </td><td width="150">
&#124; R</b> represents the restriction of <b>D</b> to
<b>R</b>-that is, the distribution that takes each point <b>p</b> in <b>R</b>
to 
<b>D(p)</b>, 
but doesn't apply to any points but those in <b>R</b>.

<div class="p"><!----></div>

<b>Range Restriction.&nbsp;&nbsp;</b><a name="distribution+restriction+range164">
</a>

<div class="p"><!----></div>
If <b>D</b> is a distribution and <b>P</b> a place expression, the term
<b>D </td><td width="150">
&#124; P</b> 
denotes the sub-distribution of <b>D</b> defined over all the
points in the region of <b>D</b> mapped to <b>P</b>.

<div class="p"><!----></div>
Note that <b>D </td><td width="150">
&#124; here</b> does not necessarily contain adjacent points
in <b>D.region</b>. For instance, if <b>D</b> is a cyclic distribution,
<b>D </td><td width="150">
&#124; here</b> will typically contain points that differ by the number of
places. 
An implementation may find a
way to still represent them in contiguous memory, , using a
complex arithmetic function to map from the region index to an index
into the array.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc16.5">
16.5</a>&nbsp;&nbsp;Array initializer</h2><a name="ArrayInitializer">
</a><a name="array!creation">
</a>

<div class="p"><!----></div>
Arrays are instantiated by invoking one of the <b>make</b> factory
methods of the <b>Array</b> class.

<div class="p"><!----></div>
An array creation 
must take either an <b>Int</b> as an argument or a <b>Dist</b>. In the first
case an array is created over the distribution <b>[0:N-1]-&#62;here</b>;
in the second over the given distribution. 

<div class="p"><!----></div>
An array creation operation may also specify an initializer
function.
The function is applied in parallel
at all points in the domain of the distribution. The array
construction operation terminates locally only when the array has been
fully created and initialized (at all places in the range of the
distribution).

<div class="p"><!----></div>
For instance:
<pre>
val data : Array[Int]
    = Array.make[Int](1..1000-&#62;here, ((i):Point) =&#62; i);
val data2 : Array[Int]
    = Array.make[Int]([1..1000,1..1000]-&#62;here, ((i,j):Point) =&#62; i*j);
</pre>

<div class="p"><!----></div>
 The first declaration stores in <b>data</b> a reference to a mutable
array with <b>1000</b> elements each of which is located in the
same place as the array. Each array component is initialized to <b>i</b>.

<div class="p"><!----></div>
The second declaration stores in <b>data2</b> a reference to a mutable
2-d array over <b>[1..1000, 1..1000]</b> initialized with <b>i*j</b>
at point <b>[i,j]</b>.

<div class="p"><!----></div>
Other examples:
<pre>
val D1:Dist(1) = ...; /* An expression that creates a Dist */
val D2:Dist(2) = ...; /* An expression that creates a Dist */

<div class="p"><!----></div>
val data : Array[Int]
    = Array.make[Int](1000, ((i):Point) =&#62; i*i);

<div class="p"><!----></div>
val data2 : Array[Float]
    = Array.make[Float](D1, ((i):Point) =&#62; i*i as Float);

<div class="p"><!----></div>
val result : Array[Float]
   = Array.make[Float](D2, ((i,j):Point) =&#62; i+j as Float);;
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc16.6">
16.6</a>&nbsp;&nbsp;Operations on arrays</h2>
In the following let <b>a</b> be an array with distribution <b>D</b> and
base type <b>T</b>. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.6.1">
16.6.1</a>&nbsp;&nbsp;Element operations</h3><a name="array+access166">
</a>
The value of <b>a</b> at a point <b>p</b> in its region of definition is
obtained by using the indexing operation <b>a(p)</b>. This operation
may be used on the left hand side of an assignment operation to update
the value. The operator assignments <b>a(i) op= e</b> are also available
in X10.

<div class="p"><!----></div>
For array variables, the right-hand-side of an assignment must
have the same distribution <b>D</b> as an array being assigned. This
assignment involves
control communication between the sites hosting <b>D</b>. Each
site performs the assignment(s) of array components locally. The
assignment terminates when assignment has terminated at all
sites hosting <b>D</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.6.2">
16.6.2</a>&nbsp;&nbsp;Constant promotion</h3><a name="ConstantArray">
</a><a name="arrays+constant promotion166">
</a>

<div class="p"><!----></div>
For a distribution <b>D</b> and a val <b>v</b> of
type <b>T</b> the expression <b>new Array[T](D, (p: Point) =&#62; v)</b>
denotes the mutable array with
distribution <b>D</b> and base type <b>T</b> initialized with <b>v</b>
at every point.

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.6.3">
16.6.3</a>&nbsp;&nbsp;Restriction of an array</h3><a name="array+restriction166">
</a>

<div class="p"><!----></div>
Let <b>D1</b> be a sub-distribution of <b>D</b>. Then <b>a </td><td width="150">
&#124; D1</b>
represents the sub-array of <b>a</b> with the distribution <b>D1</b>.

<div class="p"><!----></div>
Recall that a rich set of operators are available on distributions
(&#167;) to obtain sub-distributions
(e.g. restricting to a sub-region, to a specific place etc).

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.6.4">
16.6.4</a>&nbsp;&nbsp;Assembling an array</h3>
Let <b>a1,a2</b> be arrays of the same base type <b>T</b> defined over
distributions <b>D1</b> and <b>D2</b> respectively. Assume that both
arrays are value or reference arrays. 

<div class="p"><!----></div>
<b>Assembling arrays over disjoint regions&nbsp;&nbsp;</b><a name="array+union+disjoint166">
</a>

<div class="p"><!----></div>
If <b>D1</b> and <b>D2</b> are disjoint then the expression <b>a1 </td><td width="150">
&#124;</td><td width="150">
&#124; a2</b> denotes the unique array of base type <b>T</b> defined over the
distribution <b>D1 </td><td width="150">
&#124;</td><td width="150">
&#124; D2</b> such that its value at point <b>p</b> is
<b>a1(p)</b> if <b>p</b> lies in <b>D1</b> and <b>a2(p)</b>
otherwise. This array is a reference (value) array if <b>a1</b> is.

<div class="p"><!----></div>

<b>Overlaying an array on another&nbsp;&nbsp;</b><a name="array+union+asymmetric166">
</a>
The expression
<b>a1.overlay(a2)</b> (read: the array <b>a1</b> <em>overlaid with</em> <b>a2</b>)
represents an array whose underlying region is the union of that of
<b>a1</b> and <b>a2</b> and whose distribution maps each point <b>p</b>
in this region to <b>D2(p)</b> if that is defined and to <b>D1(p)</b>
otherwise. The value <b>a1.overlay(a2)(p)</b> is <b>a2(p)</b> if it is defined and <b>a1(p)</b> otherwise.

<div class="p"><!----></div>
This array is a reference (value) array if <b>a1</b> is.

<div class="p"><!----></div>
The expression <b>a1.update(a2)</b> updates the array <b>a1</b> in place
with the result of <b>a1.overlay(a2)</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc16.6.5">
16.6.5</a>&nbsp;&nbsp;Global operations </h3>

<div class="p"><!----></div>

<b>Pointwise operations&nbsp;&nbsp;</b><a name="ArrayPointwise">
</a><a name="array+pointwise operations166">
</a>
The unary <b>lift</b> operation applies a function to each element of
an array, returning a new array with the same distribution.
The <b>lift</b> operation is implemented by the following method
in <b>Array[T]</b>:
<pre>
def lift[S](f: (T) =&#62; S): Array[S](dist);
</pre>

<div class="p"><!----></div>
The binary <b>lift</b> operation takes a binary function and
another
array over the same distribution and applies the function
pointwise to corresponding elements of the two arrays, returning
a new array with the same distribution.
The <b>lift</b> operation is implemented by the following method
in <b>Array[T]</b>:
<pre>
def lift[S,R](f: (T,S) =&#62; R, Array[S](dist)): Array[R](dist);
</pre>

<div class="p"><!----></div>

<b>Reductions&nbsp;&nbsp;</b><a name="ArrayReductions">
</a><a name="array+reductions166">
</a>

<div class="p"><!----></div>
Let <b>f</b> be a function of type <b>(T,T)=&#62;T</b>.  Let
<b>a</b> be a value or reference array over base type <b>T</b>.
Let <b>unit</b> be a value of type <b>T</b>.
Then the
operation <b>a.reduce(f, unit)</b> returns a value of type <b>T</b> obtained
by performing <b>f</b> on all points in <b>a</b> in some order, and in
parallel.  The function <b>f</b> must be associative and
commutative.  The value <b>unit</b> should satisfy
<b>f(unit,x)</b> <b>==</b> <b>x</b> <b>==</b> <b>f(x,unit)</b>.

<div class="p"><!----></div>
This operation involves communication between the places over which
the array is distributed. The X10 implementation guarantees that
only one value of type <b>T</b> is communicated from a place as part of
this reduction process.

<div class="p"><!----></div>

<b>Scans&nbsp;&nbsp;</b><a name="ArrayScans">
</a><a name="array+scans166">
</a>

<div class="p"><!----></div>
Let <b>f</b> be a reduction operator defined on type <b>T</b>. Let
<b>a</b> be a value or reference array over base type <b>T</b> and
distribution <b>D</b>. Then the operation <b>a</td><td width="150">
&#124;</td><td width="150">
&#124;f()</b> returns an array
of base type <b>T</b> and distribution <b>D</b> whose iass="roman">th element
(in canonical order) is obtained by performing the reduction <b>f</b>
on the first iass="roman"> elements of <b>a</b> (in canonical order).

<div class="p"><!----></div>
This operation involves communication between the places over which
the array is distributed. The X10 implementation will endeavour to
minimize the communication between places to implement this operation.

<div class="p"><!----></div>
Other operations on arrays may be found in <b>x10.lang.Array</b> and
other related classes.
	



<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h1><a name="tth_chAp17">
Chapter 17 </a><br />Annotations and compiler plugins</h1><a name="XtenAnnotations">
</a><a name="annotations170">
</a>

<div class="p"><!----></div>
X10 provides an 
an annotation system and compiler plugin system for to allow the
compiler to be extended with new static analyses and new
transformations.

<div class="p"><!----></div>
Annotations are interface types that decorate the abstract syntax tree
of an X10 program.  The X10 type-checker ensures that an annotation
is a legal interface type.
In X10, interfaces may declare
both methods and properties.  Therefore, like any interface type, an
annotation may instantiate
one or more of its interface's properties.
Unlike with Java
annotations,
property initializers need not be
compile-time constants;
however, a given compiler plugin
may do additional checks to constrain the allowable
initializer expressions.
The X10 type-checker does not check that
all properties of an annotation are initialized,
although this could be enforced by
a compiler plugin.

<div class="p"><!----></div>
 <h2><a name="tth_sEc17.1">
17.1</a>&nbsp;&nbsp;Annotation syntax</h2>

<div class="p"><!----></div>
The annotation syntax consists of an "<tt>@</tt>" followed by an interface type.

<div class="p"><!----></div>
  :  |        <em>  
<table>
<tr><td align="right">Annotation ::= 
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.89.<br />On 12 Oct 2010, 23:42.</small>
</html>
