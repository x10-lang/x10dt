<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Coercions and conversions</title>
</head>

<body>
 <h2><a name="tth_sEc27">
27</a>&nbsp;&nbsp;Coercions and conversions</h2>
<a name="XtenConversions">
</a>
<a name="User-definedCoercions">
</a>



<div class="p"><!----></div>
X10 v2.1 supports the following coercions and conversions.

<div class="p"><!----></div>
     <h3><a name="tth_sEc27.1">
27.1</a>&nbsp;&nbsp;Coercions</h3>

<div class="p"><!----></div>
  
<em>
  
<table>

<tr><td align="right">CastExp ::= CastExp <b>as</b> Type </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
A <em>coercion</em> does not change object identity; a coerced object may
be explicitly coerced back to its original type through a cast. A <em>
  conversion</em> may change object identity if the type being converted
to is not the same as the type converted from. X10 permits
user-defined conversions (&#167;).

<div class="p"><!----></div>

<b>Subsumption coercion.&nbsp;&nbsp;</b>
A value of a subtype may be implicitly coerced to any supertype.  


<div class="p"><!----></div>
If <b>Child &lt;: Person</b> and <b>val rhys:Child</b>, then <b>rhys</b> may be used
in any context that expects a <b>Person</b>.  For example, 
<pre>
class Example {
  def greet(Person) = "Hi!";
  def example(rhys: Child) {
     greet(rhys);
  }
}
</pre>

<div class="p"><!----></div>
Similarly, <b>2</b> (whose innate type is <b>Int{self==2}</b>)
is usable in a context requiring a non-zero integer
(<b>Int{self != 0}</b>).  


<div class="p"><!----></div>

<b>Explicit Coercion (Casting with <b>as</b>)&nbsp;&nbsp;</b>

<div class="p"><!----></div>
All classes and interfaces allow the use of the <b>as</b> operator for explicit
type coercion.  
Any class or
interface may be cast to any interface.  
Any interface may be cast to
any class.  Also, any interface can be cast to a struct that implements
(directly or indirectly) that interface.

<div class="p"><!----></div>
In the following code, a <b>Person</b> is cast to <b>Childlike</b>.  There is
nothing in the class definition of <b>Person</b> that suggests that a
<b>Person</b> can be <b>Childlike</b>.  However, the <b>Person</b> in question,
<b>p</b>, is actually a <b>HappyChild</b> - a subclass of <b>Person</b> - and
is, in fact, <b>Childlike</b>.  

<div class="p"><!----></div>
Similarly, the <b>Childlike</b> value <b>cl</b> is cast to <b>Happy</b>.  Though
these two interfaces are unrelated, the value of <b>cl</b> is, in fact,
<b>Happy</b>.  And the <b>Happy</b> value <b>hc</b> is cast to the class
<b>Child</b>, though there is no relationship between the two, but the actual
value is a <b>HappyChild</b>, and thus the cast is correct at runtime.

<div class="p"><!----></div>
<b>Cyborg</b> is a struct rather than a class.  So, it cannot have substructs,
and all the interfaces of all <b>Cyborg</b>s are known: a <b>Cyborg</b> is
<b>Personable</b>, but not <b>Childlike</b> or <b>Happy</b>.  So, it is correct
and meaningful to cast <b>r</b> to <b>Personable</b>.  There is no way that a
cast to <b>Childlike</b> could succeed, so <b>r as Childlike</b> is a static error.

<div class="p"><!----></div>
<pre>
interface Personable {}
class Person implements Personable {}
interface Childlike extends Personable {}
class Child extends Person implements Childlike {}
struct Cyborg implements Personable {}
interface Happy {}
class HappyChild extends Child implements Happy {}
class Example {
  static def example() {
    var p : Person = new HappyChild();
    val cl : Childlike = p as Childlike; // class -&#62; interface
    val hc : Happy = cl as Happy; //        interface -&#62; interface
    val ch : Child = hc as Child; //        interface -&#62; class
    var r : Cyborg = Cyborg();
    val rl : Personable = r as Personable; 
    // ERROR: r as Childlike
  }
}
</pre>

<div class="p"><!----></div>
If the value coerced is not an instance of the target type,
and no coercion operators that can convert it to that type are defined, 
a <b>ClassCastException</b> is thrown.  Casting to a constrained
type may require a run-time check that the constraint is
satisfied.




<div class="p"><!----></div>
<b><b>Limitation: </b> It is currently a static error, rather than the specified
<b>ClassCastException</b>, when the cast is statically determinable to be
impossible.</b>

<div class="p"><!----></div>

<b>Effects of explicit numeric coercion&nbsp;&nbsp;</b>
<a name="sec:effects-of-explicit-numeric-coercions">
</a>

<div class="p"><!----></div>
Coercing a number of one type to another type gives the best approximation of
the number in the result type, or a suitable disaster value if no
approximation is good enough.  

<div class="p"><!----></div>

<ul>
<li> Casting a number to a <em>wider</em> numeric type is safe and effective,
      and can be done by an implicit conversion as well as an explicit
      coercion.  For example, <b>4 as Long</b> produces the <b>Long</b> value of
      4.
<div class="p"><!----></div>
</li>

<li> Casting a floating-point value to an integer value truncates the digits
      after the decimal point, thereby rounding the number towards zero.  
      <b>54.321 as Int</b> is <b>54</b>, and 
      <b>-54.321 as Int</b> is <b>-54</b>.
      If the floating-point value is too large to represent as that kind of
      integer, the coercion returns the largest or smallest value of that type
      instead: <b>1e110 as Int</b> is 
      <b>Int.MAX_VALUE</b>, <em>viz</em> <b>2147483647</b>.
<div class="p"><!----></div>
</li>

<li> Casting a <b>Double</b> to a <b>Float</b> normally truncates binary digits: 
      <b>0.12345678901234567890 as Float</b> is approximately <b>0.12345679f</b>.  This can
      turn a nonzero <b>Double</b> into <b>0.0f</b>, the zero of type
      <b>Float</b>: 
      <b>1e-100 as Float</b> is <b>0.0f</b>.  Since 
      <b>Double</b>s can be as large as about <b>1.79E308</b> and <b>Float</b>s
      can only be as large as about <b>3.4E38f</b>, a large <b>Double</b> will
      be converted to the special <b>Float</b> value of <b>Infinity</b>: 
      <b>1e100 as Float</b> is <b>Infinity</b>.
<div class="p"><!----></div>
</li>

<li> Integers are coerced to smaller integer types by truncating the
      high-order bits. If the value of the large integer fits into the smaller
      integer's range, this gives the same number in the smaller type: 
      <b>12 as Byte</b> is the <b>Byte</b>-sized 12, 
      <b>-12 as Byte</b> is -12. 
      However, if the larger integer <em>doesn't</em> fit in the smaller type,
      the numeric value and even the sign can change: <b>254 as Byte</b> is
      the <b>Byte</b>sized <b>-2y</b>.
<div class="p"><!----></div>
</li>

<li> Casting an unsigned integer type to a signed integer type of the same
      size (<em>e.g.</em>, <b>UInt</b> to <b>Int</b>) preserves 2's-complement bit pattern
      (<em>e.g.</em>,  
      <b>UInt.MAX_VALUE as Int == -1</b>.   Casting an unsigned integer type to
      a signed integer type of a different size is equivalent to first casting
      to an unsigned integer type of the target size, and then casting to a
      signed integer type.
<div class="p"><!----></div>
</li>

<li> Casting a signed integer type to an unsigned one is similar.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
      <h4><a name="tth_sEc27.1.1">
27.1.1</a>&nbsp;&nbsp;User-defined Coercions</h4>


<div class="p"><!----></div>
Users may define coercions from arbitrary types into the container type
<b>B</b>, and coercions from <b>B</b> to arbitrary types, by providing
<b>static operator</b> definitions for the <b>as</b> operator in the definition of
<b>B</b>.  

<div class="p"><!----></div>
<pre>
class Bee {
  public static operator (x:Bee) as Int = 1;
  public static operator (x:Int) as Bee = new Bee();
  def example() {
    val b:Bee = 2 as Bee; 
    assert (b as Int) == 1;
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc27.2">
27.2</a>&nbsp;&nbsp;Conversions</h3>



<div class="p"><!----></div>

<b>Widening numeric conversion.&nbsp;&nbsp;</b>
<a name="WideningConversions">
</a>
A numeric type may be implicitly converted to a wider numeric type. In
particular, an implicit conversion may be performed between a numeric
type and a type to its right, below:

<div class="p"><!----></div>
<pre>
Byte &lt; Short &lt; Int &lt; Long &lt; Float &lt; Double
UByte &lt; UShort &lt; UInt &lt; ULong
</pre>

<div class="p"><!----></div>
Furthermore, an unsigned integer type may be implicitly coerced a signed type
large 
enough to hold any value of the type: <b>UByte</b> to <b>Short</b>, <b>UShort</b>
to <b>Int</b>, <b>UInt</b> to <b>Long</b>.  There are no implicit conversions
from signed to unsigned numbers, since they cannot treat negatives properly.

<div class="p"><!----></div>
There are no implicit conversions in cases when overflow is possible.  For
example, there is no implicit conversion between <b>Int</b> and <b>UInt</b>.  If
it is necessary to convert between these types, use <b>n as Int</b> or 
<b>n as UInt</b>, generally with a test to ensure that the value will fit and
code to handle the case in which it does not.

<div class="p"><!----></div>

<b>String conversion.&nbsp;&nbsp;</b>
Any value that is an operand of the binary
<b>+</b> operator may
be converted to <b>String</b> if the other operand is a <b>String</b>.
A conversion to <b>String</b> is performed by invoking the <b>toString()</b>
method.

<div class="p"><!----></div>

<b>User defined conversions.&nbsp;&nbsp;</b><a name="sec:user-defined-conversions">
</a>


<div class="p"><!----></div>
The user may define implicit conversion operators from type <b>A</b> <em>to</em> a
container type <b>B</b> by specifying an operator in <b>B</b>'s definition of the form:

<div class="p"><!----></div>
<pre>
  public static operator (r: A): T = ... 
</pre>

<div class="p"><!----></div>
The return type <b>T</b> should be a subtype of <b>B</b>. The return
type need not be specified explicitly; it will be computed in the
usual fashion if it is not. However, it is good practice for the
programmer to specify the return type for such operators explicitly.
The return type can be more specific than simply <b>B</b>, for cases when there
is more information available.

<div class="p"><!----></div>
The code for <b>x10.lang.Point</b> contains a conversion from 
one-dimensional <b>Array</b>s of integers to <b>Point</b>s of the same length: 
<pre>
  public operator (r: Array[Int](1)): Point(r.length) = make(r);
</pre>
This conversion is used whenever an array of integers appears in a 
context that requires a <b>Point</b>, such as subscripting. Note 
that <b>a</b> requires a <b>Point</b> of rank 2 as a subscript, and that 
a two-element <b>Array</b> (like <b>[2,4]</b>) is converted to a 
<b>Point(2)</b>.
<pre>
val a = new Array[String]((2..3) * (4..5), "hi!");
a([2,4]) = "converted!";
</pre>

<div class="p"><!----></div>

</body>
</html>