<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Accumulator variables</title>
</head>

<body>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Accumulator Variables</h2>

<div class="p"><!----></div>
Accumulator variables allow the accumulation of partial results to produce a
final result.  For example, an accumulator variable could compute a running
sum, product, maximum, or minimum of a collection of numbers.  In particular,
many concurrent activites can accumulate safely into the <em>same</em> local
variable, without need for <b>atomic</b> blocks or other explicit coordination.  

<div class="p"><!----></div>
An accumulator variable is associated with a <em>reducer</em>, which explains how
new partial values are accumulated.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Reducers</h3>

<div class="p"><!----></div>
A notion of accumulation has two aspects: 

<ol type="1">
<li> A <b>zero</b> value, which is the initial value of the accumulator,
      before any partial results have been included.  When accumulating a sum,
      the zero value is <b>0</b>; when accumulating a product, it is <b>1</b>.
<div class="p"><!----></div>
</li>

<li> A <b>combining function</b>, explaining how to combine two partial
      accumulations into a whole one.  When accumulating a sum, partial sums
      should be added together; for a product, they should be multiplied.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
In X10, this is represented as a value of type
<b>x10.lang.Reducer[T]</b>: 
<pre>
struct Reducer[T](zero:T, apply: (T,T)=&#62;T){}
</pre>
 
If <b>r:Reducer[T]</b>, then <b>r.zero</b> is the zero element, and
<b>r(a,b)</b> - which can also be written <b>r.apply(a,b)</b> - is the
combination of <b>a</b> and <b>b</b>.

<div class="p"><!----></div>
For example, the reducers for adding and multiplying integers are: 
<pre>
val summer = Reducer[Int](0, Int.+);
val producter = Reducer[Int](1, Int.*);
</pre>

<div class="p"><!----></div>
Reduction is guaranteed to be deterministic if the reducer is <em>
Abelian</em>,<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>
that is, 

<ol type="1">
<li> <b>r.apply</b> is pure; that is, has no side effects;
<div class="p"><!----></div>
</li>

<li> <b>r.apply</b> is commutative; that is, <b>r(a,b) == r(b,a)</b> for all
      inputs <b>a</b> and <b>b</b>;
<div class="p"><!----></div>
</li>

<li> <b>r.apply</b> is associative; that is, 
      <b>r(a,r(b,c)) == r(r(a,b),c)</b> for all <b>a</b>, <b>b</b>, and {c}.
<div class="p"><!----></div>
</li>

<li> <b>r.zero</b> is the identity element for <b>r.apply</b>; that is, 
      <b>r(a, r.zero) == a</b>
      for all <b>a</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
<b>summer</b> and <b>producter</b> satisfy all these conditions, and give
determinate reductions. The compiler does not require or check these, though.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Accumulators</h3>

<div class="p"><!----></div>
If <b>r</b> is a  value of type <b>Reducer[T]</b>, then an accumulator of type
<b>T</b> using <b>r</b> is declared as:
<pre>
acc(r) x : T;
acc(r) y; 
</pre>
The type declaration <b>T</b> is optional; if specified, it must be the same
type that the reducer <b>r</b> uses.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Sequential Use of Accumulators</h3>

<div class="p"><!----></div>
The sequential use of accumulator variables is straightforward, and could be
done as easily without accumulators.  (The power of accumulators is in their
concurrent use, &#167;.)

<div class="p"><!----></div>
A variable declared as <b>acc(r) x:T;</b> is initialized to <b>r.zero</b>.  

<div class="p"><!----></div>
Assignment of values of <b>acc</b> variables has nonstandard semantics.
<b>x = v;</b> causes the value <b>r(v,x)</b> to be stored in <b>x</b> - in
particular, <em>not</em> the value of {v}.

<div class="p"><!----></div>
Reading a value from an accumulator retrieves the current accumulation.

<div class="p"><!----></div>
For example, the sum and product of a list <b>L</b> of integers can be computed
by: 
<pre>
val summer = Reducer[Int](0, Int.+);
val producter = Reducer[Int](1, Int.*);
acc(summer) sum;
acc(producter) prod;
for (x in L) {
  sum = x;
  prod = x;
}
x10.io.Console.OUT.println("Sum = " + sum + "; Product = " + prod);
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Concurrent Use of Accumulators</h3>
<a name="ConcurrentUseOfAccumulators">
</a>


<div class="p"><!----></div>
Accumulator variables are restricted and synchronized in ways that make them
ideally suited for concurrent accumulation of data.   The <em>governing
activity</em> of an accumulator is the activity in which the <b>acc</b> variable is
declared.  

<div class="p"><!----></div>

<ol type="1">
<li> The governing activity can read the accumulator at any point that it has
      no running sub-activities.
<div class="p"><!----></div>
</li>

<li> Any activity that has lexical access to the accumulator can write to it.  
      All
      writes are performed atomically, without need for <b>atomic</b> or other
      concurrency control.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
If the reducer is Abelian, this guarantees that <b>acc</b> variables cannot
cause race conditions; the result of such a computation is determinate,
independent of the scheduling of activities. Read-read conflicts are
impossible, as only a single activity, the governing activity, can read the
<b>acc</b> variable. Read-write conflicts are impossible, as reads are only
allowed at points where the only activity which can refer to the <b>acc</b>
variable is the governing activity. Two activities may try to write the
<b>acc</b> variable at the same time. The writes are performed atomically, so
they behave as if they happened in some (arbitrary) order-and, because the
reducer is Abelian, the order of writes doesn't matter.

<div class="p"><!----></div>
If the reducer is not Abelian-, it is accumulating a string result by
concatenating a lot of partial strings together-the result is indeterminate.
However, because the accumulator operations are atomic, it will be the result
of <em>some</em> combination of the individual elements by the reduction
operation, , the concatenation of the partial strings in <em>some</em> order.  

<div class="p"><!----></div>
For example, the following code computes triangle numbers &#8721;<sub>i=1</sub><sup>n</sup>i
concurrently.<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>

<div class="p"><!----></div>
<pre>
def triangle(n:Int) {
  val summer = Reducer[Int](0, Int.+);
  acc(summer) sum; 
  finish {
    for([i] in 1..n) async {
      sum = i;  // (A)
    }
    // (C)
  }
  return sum; // (B)
}
</pre>

<div class="p"><!----></div>
The governing activity of the <b>acc</b> variable <b>sum</b> is the activity
including the body of <b>triangle</b>.  It starts up <b>n</b> sub-activities,
each of which adds one value to <b>sum</b> at point <b>(A)</b>.  Note that these
activities cannot <em>read</em> the value of <b>sum</b>-only the governing
activity can do that-but they can update it.  

<div class="p"><!----></div>
At point <b>(B)</b>, <b>triangle</b> returns the value in <b>sum</b>. It is
clear, from the <b>finish</b> statement, that all sub-activities started by the
governing process have finished at this point. X10 forbids reading of
<b>sum</b>, even by the governing process, at point <b>(C)</b>, since
sub-activities writing into it could still be active when the governing
activity reaches this point.  The <b>return sum;</b> statement could not be
moved to <b>(C)</b>, which is good, because the program would be wrong if it
were there.

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.4.1">
7.4.1</a>&nbsp;&nbsp;Accumulators and Places</h4>
 Activity variables can be read and written from
any place, without need for <b>GlobalRef</b>s. We may spread the previous
computation out among all the available processors by simply sticking in an
<b>at(...)</b> statement at point <b>(D)</b>, without need for other
restructuring of the program.

<div class="p"><!----></div>
<pre>
def triangle(n:Int) {
  val summer = Reducer[Int](0, Int.+);
  acc(summer) sum; 
  finish {
    for([i] in 1..n) async 
      at(Places.place(i % Places.MAX_PLACES) { //(D)
        sum = i;  // (A)
    }
  }
  return sum; // (B)
}
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.4.2">
7.4.2</a>&nbsp;&nbsp;Accumulator Parameters</h4>



<div class="p"><!----></div>
Accumulators can be passed to methods and closures, by giving the keyword 
<b>acc</b> instead of <b>var</b> or <b>val</b>.  Reducers are not specified; each
accumulator comes with its own reducer.  However, the type <b>T</b> of the
accumulator <em>is</em> required.

<div class="p"><!----></div>
For example, the following method takes a list of numbers, and accumulates
those that are divisible by 2 in <b>evens</b>, and those that are divisible by
3 in <b>triples</b>: 
<pre>
static def split23(L:List[Int], acc evens:Int, acc triples:Int) {
  for(n in L) {
     if (n % 2 == 0) evens = n;
     if (n % 3 == 0) triples = n;
  }
}
static val summer = Reducer[Int](0, Int.+);
static val producter = Reducer[Int](1, Int.*);
static def sumEvenPlusProdTriple(L:List[Int]) {
  acc(summer) sumEven;
  acc(producter) prodTriple;
  split23(L, sumEven, prodTriple);
  return sumEven + prodTriple;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;Indexed Accumulators</h3>



<div class="p"><!----></div>
<pre>
class BoolAccum implements SelfAccumulator[Boolean, Int] {
  var sumTrue = 0, sumFalse = 0;
  def update(k:Boolean, v:Int) { 
     if (k) sumTrue += k; else sumFalse += k;
  }
  def update(ks:Array[Boolean]{rail}, vs:Array[Int]{ks.size == vs.size}) {
     for([i] in ks.region) update(ks(i), vs(i));  }

<div class="p"><!----></div>
}
</pre>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>This code is
unnecessarily turgid for the sake of the example.  One would generally write
<b>public def bump() = ++n;</b>.   
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>This term is borrowed from abstract algebra, where such a
reducer, together with its type, forms an Abelian monoid.
<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>This program is highly inefficient. Even ignoring the
  constant-time formula &#8721;<sub>i=1</sub><sup>n</sup>i = [(n(n+1))/2], this program
  incurs the cost of starting n activities and coordinating n accesses
  to the accumulator. Accumulator variables are of most value in multi-place,
  multi-core computations.
<br /><br />

</body>
</html>